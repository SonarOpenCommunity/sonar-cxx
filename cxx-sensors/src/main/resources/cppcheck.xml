<?xml version="1.0" encoding="UTF-8"?>
<rules>
  <rule>
    <key>CustomRuleTemplate</key>
    <cardinality>MULTIPLE</cardinality>
    <name>Rule template for Cppcheck custom rules</name>
    <description>
      <![CDATA[
<p>
Follow these steps to make your custom rules available in SonarQube:
</p>
<ol>
  <ol>
    <li>Create a new rule in SonarQube by "copying" this rule template and specify the <code>CheckId</code> of your custom rule, a title, a description, and a default severity.</li>
    <li>Enable the newly created rule in your quality profile</li>
  </ol>
  <li>Relaunch an analysis on your projects, et voila, your custom rules are executed!</li>
</ol>
]]>
    </description>
  </rule>
  <rule>
    <key>AssignmentAddressToInteger</key>
    <name>Assigning a pointer to an integer is not portable</name>
    <description>
      <![CDATA[
      <p>
Assigning a pointer to an integer (int/long/etc) is not portable
across different platforms and compilers. For example in 32-bit
Windows and linux they are same width, but in 64-bit Windows and linux
they are of different width. In worst case you end up assigning 64-bit
address to 32-bit integer. The safe way is to store addresses only in
pointer types (or typedefs like uintptr_t).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>AssignmentIntegerToAddress</key>
    <name>Assigning an integer to a pointer is not portable</name>
    <description>
      <![CDATA[
      <p>
Assigning an integer (int/long/etc) to a pointer is not portable
across different platforms and compilers. For example in 32-bit
Windows and linux they are same width, but in 64-bit Windows and linux
they are of different width. In worst case you end up assigning 64-bit
integer to 32-bit pointer. The safe way is to store addresses only in
pointer types (or typedefs like uintptr_t).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>CastAddressToIntegerAtReturn</key>
    <name>Returning an address value in a function with integer return type is not portable</name>
    <description>
      <![CDATA[
      <p>
Returning an address value in a function with integer (int/long/etc)
return type is not portable across different platforms and compilers.
For example in 32-bit Windows and Linux they are same width, but in
64-bit Windows and Linux they are of different width. In worst case
you end up casting 64-bit address down to 32-bit integer. The safe way
is to always return an integer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>CastIntegerToAddressAtReturn</key>
    <name>Returning an integer in a function with pointer return type is not portable</name>
    <description>
      <![CDATA[
      <p>
Returning an integer (int/long/etc) in a function with pointer return
type is not portable across different platforms and compilers. For
example in 32-bit Windows and Linux they are same width, but in 64-bit
Windows and Linux they are of different width. In worst case you end
up casting 64-bit integer down to 32-bit pointer. The safe way is to
always return a pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>ConfigurationNotChecked</key>
    <name>Skipping configuration 'X' since the value of 'X' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly</name>
    <description>
      <![CDATA[
Skipping configuration 'X' since the value of 'X' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>IOWithoutPositioning</key>
    <name>Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
Read and write operations without a call to a positioning function
(fseek, fsetpos or rewind) or fflush in between result in undefined
behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>StlMissingComparison</key>
    <name>Missing bounds check for extra iterator increment in loop</name>
    <description>
      <![CDATA[
      <p>
The iterator incrementing is suspicious - it is incremented at line
and then at line . The loop might unintentionally skip an element in
the container. There is no comparison between these increments to
prevent that the iterator is incremented beyond the end.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/834.html" target="_blank">CWE-834: Excessive Iteration</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>argumentSize</key>
    <name>Buffer 'buffer' is too small, the function 'function' expects a bigger buffer in 2nd argument</name>
    <description>
      <![CDATA[
      <p>
Buffer 'buffer' is too small, the function 'function' expects a bigger
buffer in 2nd argument
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>arithOperationsOnVoidPointer</key>
    <name>'varname' is of type 'vartype'. When using void pointers in calculations, the behaviour is undefined</name>
    <description>
      <![CDATA[
      <p>
'varname' is of type 'vartype'. When using void pointers in
calculations, the behaviour is undefined. Arithmetic operations on
'void *' is a GNU C extension, which defines the 'sizeof(void)' to be
1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/467.html" target="_blank">CWE-467: Use of sizeof() on a Pointer Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>arrayIndexOutOfBounds</key>
    <name>Array 'arr[16]' accessed at index 16, which is out of bounds</name>
    <description>
      <![CDATA[
      <p>
Array 'arr[16]' accessed at index 16, which is out of bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>arrayIndexOutOfBoundsCond</key>
    <name>Array 'arr[16]' accessed at index 16, which is out of bounds</name>
    <description>
      <![CDATA[
      <p>
Array 'arr[16]' accessed at index 16, which is out of bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>arrayIndexThenCheck</key>
    <name>Array index 'i' is used before limits check</name>
    <description>
      <![CDATA[
      <p>
Defensive programming: The variable 'i' is used as an array index
before it is checked that is within limits. This can mean that the
array might be accessed out of bounds. Reorder conditions such as
'(a[i] && i < 10)' to '(i < 10 && a[i])'. That way the array will not
be accessed if the index is out of limits.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>assertWithSideEffect</key>
    <name>Assert statement calls a function which may have desired side effects: 'function'</name>
    <description>
      <![CDATA[
      <p>
Non-pure function: 'function' is called inside assert statement.
Assert statements are removed from release builds so the code inside
assert statement is not executed. If the code is needed also in
release builds, this is a bug.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>assignBoolToPointer</key>
    <name>Boolean value assigned to pointer</name>
    <description>
      <![CDATA[
      <p>
Boolean value assigned to pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/587.html" target="_blank">CWE-587: Assignment of a Fixed Address to a Pointer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>assignIfError</key>
    <name>Mismatching assignment and comparison, comparison '' is always false</name>
    <description>
      <![CDATA[
      <p>
Mismatching assignment and comparison, comparison '' is always false.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>assignmentInAssert</key>
    <name>Assert statement modifies 'var'</name>
    <description>
      <![CDATA[
      <p>
Variable 'var' is modified inside assert statement. Assert statements
are removed from release builds so the code inside assert statement is
not executed. If the code is needed also in release builds, this is a
bug.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>autoVariables</key>
    <name>Address of local auto-variable assigned to a function parameter</name>
    <description>
      <![CDATA[
      <p>
Dangerous assignment - the function parameter is assigned the address
of a local auto-variable. Local auto-variables are reserved from the
stack which is freed when the function ends. So the pointer to a local
variable is invalid after the function ends.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>autovarInvalidDeallocation</key>
    <name>Deallocation of an auto-variable results in undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
The deallocation of an auto-variable results in undefined behaviour.
You should only free memory that has been allocated dynamically.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/590.html" target="_blank">CWE-590: Free of Memory not on the Heap</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>bitwiseOnBoolean</key>
    <name>Boolean expression 'expression' is used in bitwise operation. Did you mean '&amp;&amp;'?</name>
    <description>
      <![CDATA[
      <p>
Boolean expression 'expression' is used in bitwise operation. Did you
mean '&&'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>boostForeachError</key>
    <name>BOOST_FOREACH caches the end() iterator. It's undefined behavior if you modify the container inside</name>
    <description>
      <![CDATA[
      <p>
BOOST_FOREACH caches the end() iterator. It's undefined behavior if
you modify the container inside.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>bufferAccessOutOfBounds</key>
    <name>Buffer is accessed out of bounds: buf</name>
    <description>
      <![CDATA[
      <p>
Buffer is accessed out of bounds: buf
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>bufferNotZeroTerminated</key>
    <name>The buffer 'buffer' is not null-terminated after the call to strncpy()</name>
    <description>
      <![CDATA[
The buffer 'buffer' is not null-terminated after the call to strncpy(). This will cause bugs later in the code if the code assumes the buffer is null-terminated.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>catchExceptionByValue</key>
    <name>Exception should be caught by reference</name>
    <description>
      <![CDATA[
      <p>
The exception is caught by value. It could be caught as a (const)
reference which is usually recommended in C++.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>charArrayIndex</key>
    <name>Signed 'char' type used as array index</name>
    <description>
      <![CDATA[
Signed 'char' type used as array index. If the value can be greater than 127 there will be a buffer underflow because of sign extension.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>charBitOp</key>
    <name>When using 'char' variables in bit operations, sign extension can generate unexpected results</name>
    <description>
      <![CDATA[
      <p>
When using 'char' variables in bit operations, sign extension can
generate unexpected results. For example:
    char c = 0x80;

int i = 0 | c;
    if (i & 0x8000)
        printf("not
expected");
The "not expected" will be printed on the screen.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>charLiteralWithCharPtrCompare</key>
    <name>Char literal compared with pointer 'foo'. Did you intend to dereference it?</name>
    <description>
      <![CDATA[
      <p>
Char literal compared with pointer 'foo'. Did you intend to
dereference it?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/595.html" target="_blank">CWE-595: Comparison of Object References Instead of Object Contents</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>checkCastIntToCharAndBack</key>
    <name>Storing func_name() return value in char variable and then comparing with EOF</name>
    <description>
      <![CDATA[
      <p>
When saving func_name() return value in char variable there is loss of
precision.  When func_name() returns EOF this value is truncated.
Comparing the char variable with EOF can have unexpected results. For
instance a loop "while (EOF != (c = func_name());" loops forever on
some compilers/platforms and on other compilers/platforms it will stop
when the file contains a matching character.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/197.html" target="_blank">CWE-197: Numeric Truncation Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>clarifyCalculation</key>
    <name>Clarify calculation precedence for '+' and '?'</name>
    <description>
      <![CDATA[
      <p>
Suspicious calculation. Please use parentheses to clarify the code.
The code ''a+b?c:d'' should be written as either ''(a+b)?c:d'' or
''a+(b?c:d)''.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/783.html" target="_blank">CWE-783: Operator Precedence Logic Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>clarifyCondition</key>
    <name>Suspicious condition (assignment + comparison); Clarify expression with parentheses</name>
    <description>
      <![CDATA[
      <p>
Suspicious condition (assignment + comparison); Clarify expression
with parentheses.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>clarifyStatement</key>
    <name>In expression like '*A++' the result of '*' is unused. Did you intend to write '(*A)++;'?</name>
    <description>
      <![CDATA[
      <p>
A statement like '*A++;' might not do what you intended. Postfix
'operator++' is executed before 'operator*'. Thus, the dereference is
meaningless. Did you intend to write '(*A)++;'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/783.html" target="_blank">CWE-783: Operator Precedence Logic Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>commaSeparatedReturn</key>
    <name>Comma is used in return statement. The comma can easily be misread as a ';'</name>
    <description>
      <![CDATA[
      <p>
Comma is used in return statement. When comma is used in a return
statement it can easily be misread as a semicolon. For example in the
code below the value of 'b' is returned if the condition is true, but
it is easy to think that 'a+1' is returned:
    if (x)

return a + 1,
    b++;
However it can be useful to use comma in
macros. Cppcheck does not warn when such a macro is then used in a
return statement, it is less likely such code is misunderstood.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>compareBoolExpressionWithInt</key>
    <name>Comparison of a boolean expression with an integer other than 0 or 1</name>
    <description>
      <![CDATA[
      <p>
Comparison of a boolean expression with an integer other than 0 or 1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>comparisonError</key>
    <name>Expression '(X &amp; 0x6) == 0x1' is always false</name>
    <description>
      <![CDATA[
      <p>
The expression '(X & 0x6) == 0x1' is always false. Check carefully
constants and operators used, these errors might be hard to spot
sometimes. In case of complex expression it might help to split it to
separate expressions.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>comparisonFunctionIsAlwaysTrueOrFalse</key>
    <name>Comparison of two identical variables with isless(varName,varName) always evaluates to false</name>
    <description>
      <![CDATA[
      <p>
The function isless is designed to compare two variables. Calling this
function with one variable (varName) for both parameters leads to a
statement which is always false.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>comparisonOfBoolWithBoolError</key>
    <name>Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      <![CDATA[
      <p>
The variable 'var_name' is of type 'bool' and comparing 'bool' value
using relational (<, >, <= or >=) operator could cause unexpected
results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>comparisonOfBoolWithInt</key>
    <name>Comparison of a boolean with an integer that is neither 1 nor 0</name>
    <description>
      <![CDATA[
The expression 'varname' is of type 'bool' and it is compared against an integer value that is neither 1 nor 0.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>comparisonOfFuncReturningBoolError</key>
    <name>Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      <![CDATA[
      <p>
The return type of function 'func_name' is 'bool' and result is of
type 'bool'. Comparing 'bool' value using relational (<, >, <= or >=)
operator could cause unexpected results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>comparisonOfTwoFuncsReturningBoolError</key>
    <name>Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
    <description>
      <![CDATA[
      <p>
The return type of function 'func_name1' and function 'func_name2' is
'bool' and result is of type 'bool'. Comparing 'bool' value using
relational (<, >, <= or >=) operator could cause unexpected results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>constStatement</key>
    <name>Redundant code: Found a statement that begins with type constant</name>
    <description>
      <![CDATA[
      <p>
Redundant code: Found a statement that begins with type constant.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>copyCtorPointerCopying</key>
    <name>Value of pointer 'var', which points to allocated memory, is copied in copy constructor instead of allocating new memory</name>
    <description>
      <![CDATA[
      <p>
Value of pointer 'var', which points to allocated memory, is copied in
copy constructor instead of allocating new memory.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>coutCerrMisusage</key>
    <name>Invalid usage of output stream: '&lt;&lt; std::cout'</name>
    <description>
      <![CDATA[
      <p>
Invalid usage of output stream: '<< std::cout'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>cstyleCast</key>
    <name>C-style pointer casting</name>
    <description>
      <![CDATA[
      <p>
C-style pointer casting detected. C++ offers four different kinds of
casts as replacements: static_cast, const_cast, dynamic_cast and
reinterpret_cast. A C-style cast could evaluate to any of those
automatically, thus it is considered safer if the programmer
explicitly states which kind of cast is expected. See also: https://ww
w.securecoding.cert.org/confluence/display/cplusplus/EXP05-CPP.+Do+not
+use+C-style+casts.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>deadpointer</key>
    <name>Dead pointer usage. Pointer 'pointer' is dead if it has been assigned '&amp;x' at line 0</name>
    <description>
      <![CDATA[
Dead pointer usage. Pointer 'pointer' is dead if it has been assigned '&amp;x' at line 0.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>deallocDealloc</key>
    <name>Deallocating a deallocated pointer: varname</name>
    <description>
      <![CDATA[
      <p>
Deallocating a deallocated pointer: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/415.html" target="_blank">CWE-415: Double Free</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>deallocret</key>
    <name>Returning/dereferencing 'p' after it is deallocated / released</name>
    <description>
      <![CDATA[
      <p>
Returning/dereferencing 'p' after it is deallocated / released
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/672.html" target="_blank">CWE-672: Operation on a Resource after Expiration or Release</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>deallocuse</key>
    <name>Dereferencing 'varname' after it is deallocated / released</name>
    <description>
      <![CDATA[
      <p>
Dereferencing 'varname' after it is deallocated / released
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/416.html" target="_blank">CWE-416: Use After Free</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>derefInvalidIterator</key>
    <name>Possible dereference of an invalid iterator: i</name>
    <description>
      <![CDATA[
      <p>
Possible dereference of an invalid iterator: i. Make sure to check
that the iterator is valid before dereferencing it - not after.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/825.html" target="_blank">CWE-825: Expired Pointer Dereference</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>doubleFree</key>
    <name>Memory pointed to by 'varname' is freed twice</name>
    <description>
      <![CDATA[
      <p>
Memory pointed to by 'varname' is freed twice.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/415.html" target="_blank">CWE-415: Double Free</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>duplInheritedMember</key>
    <name>The class 'class' defines member variable with name 'variable' also defined in its parent class 'class'</name>
    <description>
      <![CDATA[
      <p>
The class 'class' defines member variable with name 'variable' also
defined in its parent class 'class'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>duplicateBranch</key>
    <name>Found duplicate branches for 'if' and 'else'</name>
    <description>
      <![CDATA[
      <p>
Finding the same code in an 'if' and related 'else' branch is
suspicious and might indicate a cut and paste or logic error. Please
examine this code carefully to determine if it is correct.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>duplicateBreak</key>
    <name>Consecutive return, break, continue, goto or throw statements are unnecessary</name>
    <description>
      <![CDATA[
      <p>
Consecutive return, break, continue, goto or throw statements are
unnecessary. The second statement can never be executed, and so should
be removed.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/561.html" target="_blank">CWE-561: Dead Code</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>duplicateExpression</key>
    <name>Same expression on both sides of '&amp;&amp;'</name>
    <description>
      <![CDATA[
      <p>
Finding the same expression on both sides of an operator is suspicious
and might indicate a cut and paste or logic error. Please examine this
code carefully to determine if it is correct.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>eraseDereference</key>
    <name>Invalid iterator 'iter' used</name>
    <description>
      <![CDATA[
      <p>
The iterator 'iter' is invalid before being assigned. Dereferencing or
comparing it with another iterator is invalid operation.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>exceptDeallocThrow</key>
    <name>Exception thrown in invalid state, 'p' points at deallocated memory</name>
    <description>
      <![CDATA[
      <p>
Exception thrown in invalid state, 'p' points at deallocated memory.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>exceptRethrowCopy</key>
    <name>Throwing a copy of the caught exception instead of rethrowing the original exception</name>
    <description>
      <![CDATA[
      <p>
Rethrowing an exception with 'throw varname;' creates an unnecessary
copy of 'varname'. To rethrow the caught exception without unnecessary
copying or slicing, use a bare 'throw;'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>exceptThrowInDestructor</key>
    <name>Class Class is not safe, destructor throws exception</name>
    <description>
      <![CDATA[
      <p>
The class Class is not safe because its destructor throws an
exception. If Class is used and an exception is thrown that is caught
in an outer scope the program will terminate.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>fflushOnInputStream</key>
    <name>fflush() called on input stream 'stdin' may result in undefined behaviour on non-linux systems</name>
    <description>
      <![CDATA[
      <p>
fflush() called on input stream 'stdin' may result in undefined
behaviour on non-linux systems.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>functionConst</key>
    <name>Technically the member function 'class::function' can be const</name>
    <description>
      <![CDATA[
      <p>
The member function 'class::function' can be made a const function.
Making this function 'const' should not cause compiler errors. Even
though the function can be made const function technically it may not
make sense conceptually. Think about your design and the task of the
function first - is it a function that must not change object internal
state?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>functionStatic</key>
    <name>Technically the member function 'class::function' can be static (but you may consider moving to unnamed namespace)</name>
    <description>
      <![CDATA[
      <p>
The member function 'class::function' can be made a static function.
Making a function static can bring a performance benefit since no
'this' instance is passed to the function. This change should not
cause compiler errors but it does not necessarily make sense
conceptually. Think about your design and the task of the function
first - is it a function that must not access members of class
instances? And maybe it is more appropriate to move this function to a
unnamed namespace.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>ignoredReturnValue</key>
    <name>Return value of function malloc() is not used</name>
    <description>
      <![CDATA[
      <p>
Return value of function malloc() is not used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/252.html" target="_blank">CWE-252: Unchecked Return Value</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>incompleteArrayFill</key>
    <name>Array 'buffer' is filled incompletely. Did you forget to multiply the size given to 'memset()' with 'sizeof(*buffer)'?</name>
    <description>
      <![CDATA[
      <p>
The array 'buffer' is filled incompletely. The function 'memset()'
needs the size given in bytes, but an element of the given array is
larger than one byte. Did you forget to multiply the size with
'sizeof(*buffer)'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/131.html" target="_blank">CWE-131: Incorrect Calculation of Buffer Size</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>incorrectLogicOperator</key>
    <name>Logical disjunction always evaluates to true: foo &gt; 3 &amp;&amp; foo &lt; 4</name>
    <description>
      <![CDATA[
      <p>
Logical disjunction always evaluates to true: foo > 3 && foo < 4. Are
these conditions necessary? Did you intend to use && instead? Are the
numbers correct? Are you comparing the correct variables?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>incorrectStringBooleanError</key>
    <name>Conversion of string literal "Hello World" to bool always evaluates to true</name>
    <description>
      <![CDATA[
      <p>
Conversion of string literal "Hello World" to bool always evaluates to
true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>incorrectStringCompare</key>
    <name>String literal "Hello World" doesn't match length argument for substr()</name>
    <description>
      <![CDATA[
      <p>
String literal "Hello World" doesn't match length argument for
substr().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>incrementboolean</key>
    <name>Incrementing a variable of type 'bool' with postfix operator++ is deprecated by the C++ Standard. You should assign it the value 'true' instead</name>
    <description>
      <![CDATA[
      <p>
The operand of a postfix increment operator may be of type bool but it
is deprecated by C++ Standard (Annex D-1) and the operand is always
set to true. You should assign it the value 'true' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>initializerList</key>
    <name>Member variable 'class::variable' is in the wrong place in the initializer list</name>
    <description>
      <![CDATA[
      <p>
Member variable 'class::variable' is in the wrong place in the
initializer list. Members are initialized in the order they are
declared, not in the order they are in the initializer list.  Keeping
the initializer list in the same order that the members were declared
prevents order dependent initialization errors.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>insecureCmdLineArgs</key>
    <name>Buffer overrun possible for long command line arguments</name>
    <description>
      <![CDATA[
Buffer overrun possible for long command line arguments.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>integerOverflow</key>
    <name>Signed integer overflow for expression ''</name>
    <description>
      <![CDATA[
      <p>
Signed integer overflow for expression ''.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/190.html" target="_blank">CWE-190: Integer Overflow or Wraparound</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidFunctionArg</key>
    <name>Invalid func_name() argument nr 1. The value is 0 or 1 (boolean) but the valid values are '1:4'</name>
    <description>
      <![CDATA[
      <p>
Invalid func_name() argument nr 1. The value is 0 or 1 (boolean) but
the valid values are '1:4'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidFunctionArgBool</key>
    <name>Invalid func_name() argument nr 1. A non-boolean value is required</name>
    <description>
      <![CDATA[
      <p>
Invalid func_name() argument nr 1. A non-boolean value is required.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidIterator1</key>
    <name>Invalid iterator: iterator</name>
    <description>
      <![CDATA[
      <p>
Invalid iterator: iterator
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidIterator2</key>
    <name>After push_back|push_front|insert(), the iterator 'iterator' may be invalid</name>
    <description>
      <![CDATA[
After push_back|push_front|insert(), the iterator 'iterator' may be invalid.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidLengthModifierError</key>
    <name>'I' in format string (no. 1) is a length modifier and cannot be used without a conversion specifier</name>
    <description>
      <![CDATA[
      <p>
'I' in format string (no. 1) is a length modifier and cannot be used
without a conversion specifier.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/704.html" target="_blank">CWE-704: Incorrect Type Conversion or Cast</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPointer</key>
    <name>Invalid pointer 'pointer' after push_back()</name>
    <description>
      <![CDATA[
Invalid pointer 'pointer' after push_back().
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPointerCast</key>
    <name>Casting between float* and double* which have an incompatible binary data representation</name>
    <description>
      <![CDATA[
      <p>
Casting between float * and double * which have an incompatible binary
data representation.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/704.html" target="_blank">CWE-704: Incorrect Type Conversion or Cast</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_float</key>
    <name>%f in format string (no. 1) requires 'double' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%f in format string (no. 1) requires 'double' but the argument type is
Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_int</key>
    <name>%X in format string (no. 1) requires 'unsigned int' but the argument type is Unknown</name>
    <description>
      <![CDATA[
%X in format string (no. 1) requires 'unsigned int' but the argument type is Unknown.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_n</key>
    <name>%n in format string (no. 1) requires 'int *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%n in format string (no. 1) requires 'int *' but the argument type is
Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_p</key>
    <name>%p in format string (no. 1) requires an address but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%p in format string (no. 1) requires an address but the argument type
is Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_s</key>
    <name>%s in format string (no. 1) requires 'char *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%s in format string (no. 1) requires 'char *' but the argument type is
Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_sint</key>
    <name>%i in format string (no. 1) requires 'int' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%i in format string (no. 1) requires 'int' but the argument type is
Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidPrintfArgType_uint</key>
    <name>%u in format string (no. 1) requires 'unsigned int' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%u in format string (no. 1) requires 'unsigned int' but the argument
type is Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidScanfArgType_float</key>
    <name>%f in format string (no. 1) requires 'float *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%f in format string (no. 1) requires 'float *' but the argument type
is Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidScanfArgType_int</key>
    <name>%d in format string (no. 1) requires 'int *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%d in format string (no. 1) requires 'int *' but the argument type is
Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidScanfArgType_s</key>
    <name>%s in format string (no. 1) requires a 'char *' but the argument type is Unknown</name>
    <description>
      <![CDATA[
      <p>
%s in format string (no. 1) requires a 'char *' but the argument type
is Unknown.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidScanfFormatWidth</key>
    <name>Width 5 given in format string (no. 10) is larger than destination buffer '[0]', use %-1s to prevent overflowing it</name>
    <description>
      <![CDATA[
      <p>
Width 5 given in format string (no. 10) is larger than destination
buffer '[0]', use %-1s to prevent overflowing it.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/687.html" target="_blank">CWE-687: Function Call With Incorrectly Specified Argument Value</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidscanf</key>
    <name>scanf() without field width limits can crash with huge input data</name>
    <description>
      <![CDATA[
      <p>
scanf() without field width limits can crash with huge input data. Add
a field width specifier to fix this problem.

Sample program
that can crash:
#include &lt;stdio.h&gt;
int main()
{
char c[5];
    scanf("%s", c);
    return 0;
}
Typing
in 5 or more characters may make the program crash. The correct usage
here is 'scanf("%4s", c);', as the maximum field width does not
include the terminating null byte.
Source:
http://linux.die.net/man/3/scanf
Source: http://www.opensource.appl
e.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/119.html" target="_blank">CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidscanf_libc</key>
    <name>scanf without field width limits can crash with huge input data on some versions of libc</name>
    <description>
      <![CDATA[
scanf without field width limits can crash with huge input data on libc versions older than 2.13-25. Add a field width specifier to fix this problem:\012    %i => %3i\012\012Sample program that can crash:\012\012#include &lt;stdio.h&gt;\012int main()\012{\012    int a;\012    scanf("%i", &amp;a);\012    return 0;\012}\012\012To make it crash:\012perl -e 'print "5"x2100000' | ./a.out
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>iterators</key>
    <name>Same iterator is used with different containers 'container1' and 'container2'</name>
    <description>
      <![CDATA[
Same iterator is used with different containers 'container1' and 'container2'.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>leakNoVarFunctionCall</key>
    <name>Allocation with funcName, funcName doesn't release it</name>
    <description>
      <![CDATA[
      <p>
Allocation with funcName, funcName doesn't release it.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/772.html" target="_blank">CWE-772: Missing Release of Resource after Effective Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>leakReturnValNotUsed</key>
    <name>Return value of allocation function 'funcName' is not stored</name>
    <description>
      <![CDATA[
      <p>
Return value of allocation function 'funcName' is not stored.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/771.html" target="_blank">CWE-771: Missing Reference to Active Allocated Resource</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>literalWithCharPtrCompare</key>
    <name>String literal compared with variable 'foo'. Did you intend to use strcmp() instead?</name>
    <description>
      <![CDATA[
      <p>
String literal compared with variable 'foo'. Did you intend to use
strcmp() instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/595.html" target="_blank">CWE-595: Comparison of Object References Instead of Object Contents</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>mallocOnClassError</key>
    <name>Memory for class instance allocated with malloc(), but class contains a std::string</name>
    <description>
      <![CDATA[
      <p>
Memory for class instance allocated with malloc(), but class a
std::string. This is unsafe, since no constructor is called and class
members remain uninitialized. Consider using 'new' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>mallocOnClassWarning</key>
    <name>Memory for class instance allocated with malloc(), but class provides constructors</name>
    <description>
      <![CDATA[
      <p>
Memory for class instance allocated with malloc(), but class provides
constructors. This is unsafe, since no constructor is called and class
members remain uninitialized. Consider using 'new' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memleak</key>
    <name>Memory leak: varname</name>
    <description>
      <![CDATA[
      <p>
Memory leak: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank">CWE-401: Missing Release of Memory after Effective Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memleakOnRealloc</key>
    <name>Common realloc mistake: 'varname' nulled but not freed upon failure</name>
    <description>
      <![CDATA[
      <p>
Common realloc mistake: 'varname' nulled but not freed upon failure
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank">CWE-401: Missing Release of Memory after Effective Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memsetClass</key>
    <name>Using 'memfunc' on class that contains a classname</name>
    <description>
      <![CDATA[
      <p>
Using 'memfunc' on class that contains a classname is unsafe, because
constructor, destructor and copy operator calls are omitted. These are
necessary for this non-POD type to ensure that a valid object is
created.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memsetClassFloat</key>
    <name>Using memset() on class which contains a floating point number</name>
    <description>
      <![CDATA[
      <p>
Using memset() on class which contains a floating point number. This
is not portable because memset() sets each byte of a block of memory
to a specific value and the actual representation of a floating-point
value is implementation defined. Note: In case of an IEEE754-1985
compatible implementation setting all bits to zero results in the
value 0.0.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memsetClassReference</key>
    <name>Using 'memfunc' on class that contains a reference</name>
    <description>
      <![CDATA[
      <p>
Using 'memfunc' on class that contains a reference.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memsetFloat</key>
    <name>The 2nd memset() argument 'varname' is a float, its representation is implementation defined</name>
    <description>
      <![CDATA[
      <p>
The 2nd memset() argument 'varname' is a float, its representation is
implementation defined. memset() is used to set each byte of a block
of memory to a specific value and the actual representation of a
floating-point value is implementation defined.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/688.html" target="_blank">CWE-688: Function Call With Incorrect Variable or Reference as Argument</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memsetValueOutOfRange</key>
    <name>The 2nd memset() argument 'varname' doesn't fit into an 'unsigned char'</name>
    <description>
      <![CDATA[
      <p>
The 2nd memset() argument 'varname' doesn't fit into an 'unsigned
char'. The 2nd parameter is passed as an 'int', but the function fills
the block of memory using the 'unsigned char' conversion of this
value.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>memsetZeroBytes</key>
    <name>memset() called to fill 0 bytes</name>
    <description>
      <![CDATA[
      <p>
memset() called to fill 0 bytes. The second and third arguments might
be inverted. The function memset ( void * ptr, int value, size_t num )
sets the first num bytes of the block of memory pointed by ptr to the
specified value.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/687.html" target="_blank">CWE-687: Function Call With Incorrectly Specified Argument Value</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>mismatchAllocDealloc</key>
    <name>Mismatching allocation and deallocation: varname</name>
    <description>
      <![CDATA[
      <p>
Mismatching allocation and deallocation: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>mismatchSize</key>
    <name>The allocated size sz is not a multiple of the underlying type's size</name>
    <description>
      <![CDATA[
      <p>
The allocated size sz is not a multiple of the underlying type's size.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/131.html" target="_blank">CWE-131: Incorrect Calculation of Buffer Size</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>mismatchingBitAnd</key>
    <name>Mismatching bitmasks. Result is always 0 (X = Y &amp; 0xf0; Z = X &amp; 0x1; =&gt; Z=0)</name>
    <description>
      <![CDATA[
      <p>
Mismatching bitmasks. Result is always 0 (X = Y & 0xf0; Z = X & 0x1;
=> Z=0).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>mismatchingContainers</key>
    <name>Iterators of different containers 'v1' and 'v2' are used together</name>
    <description>
      <![CDATA[
      <p>
Iterators of different containers 'v1' and 'v2' are used together.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>missingInclude</key>
    <name>Include file: "" not found</name>
    <description>
      <![CDATA[
Include file: "" not found.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>missingIncludeSystem</key>
    <name>Include file: &lt;&gt; not found. Please note: Cppcheck does not need standard library headers to get proper results</name>
    <description>
      <![CDATA[
      Include file: <> not found. Please note: Cppcheck does not need standard library headers to get proper results.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>moduloAlwaysTrueFalse</key>
    <name>Comparison of modulo result is predetermined, because it is always less than 1</name>
    <description>
      <![CDATA[
      <p>
Comparison of modulo result is predetermined, because it is always
less than 1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>multiCondition</key>
    <name>Expression is always false because 'else if' condition matches previous condition at line 1</name>
    <description>
      <![CDATA[
      <p>
Expression is always false because 'else if' condition matches
previous condition at line 1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>nanInArithmeticExpression</key>
    <name>Using NaN/Inf in a computation</name>
    <description>
      <![CDATA[
      <p>
Using NaN/Inf in a computation. Although nothing bad really happens,
it is suspicious.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/369.html" target="_blank">CWE-369: Divide By Zero</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>negativeIndex</key>
    <name>Negative array index</name>
    <description>
      <![CDATA[
      <p>
Negative array index
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/786.html" target="_blank">CWE-786: Access of Memory Location Before Start of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>negativeMemoryAllocationSize</key>
    <name>Memory allocation size is negative</name>
    <description>
      <![CDATA[
      <p>
Memory allocation size is negative.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/131.html" target="_blank">CWE-131: Incorrect Calculation of Buffer Size</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>noConstructor</key>
    <name>The class 'classname' does not declare a constructor although it has private member variables which likely require initialization</name>
    <description>
      <![CDATA[
      <p>
The class 'classname' does not declare a constructor although it has
private member variables. Member variables of builtin types are left
uninitialized when the class is instantiated. That may cause bugs or
undefined behavior.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>noCopyConstructor</key>
    <name>Class 'class' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s)</name>
    <description>
      <![CDATA[
'class class' does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>nonreentrantFunctionscrypt</key>
    <name>Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsctermid</key>
    <name>Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsecvt</key>
    <name>Non reentrant function 'ecvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ecvt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'ecvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ecvt_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfcvt</key>
    <name>Non reentrant function 'fcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fcvt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fcvt_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetgrent</key>
    <name>Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetpwent</key>
    <name>Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsfgetspent</key>
    <name>Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgcvt</key>
    <name>Non reentrant function 'gcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gcvt_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gcvt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gcvt_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrent</key>
    <name>Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrgid</key>
    <name>Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetgrnam</key>
    <name>Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyaddr</key>
    <name>Non reentrant function 'gethostbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyaddr_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyaddr_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyname</key>
    <name>Non reentrant function 'gethostbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostbyname2</key>
    <name>Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgethostent</key>
    <name>Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetlogin</key>
    <name>Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetbyaddr</key>
    <name>Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetbyname</key>
    <name>Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetnetgrent</key>
    <name>Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetprotobyname</key>
    <name>Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwent</key>
    <name>Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwnam</key>
    <name>Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetpwuid</key>
    <name>Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcbyname</key>
    <name>Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcbynumber</key>
    <name>Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetrpcent</key>
    <name>Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservbyname</key>
    <name>Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservbyport</key>
    <name>Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetservent</key>
    <name>Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetspent</key>
    <name>Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgetspnam</key>
    <name>Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsgmtime</key>
    <name>Non reentrant function 'gmtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gmtime_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'gmtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gmtime_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionslocaltime</key>
    <name>Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsreaddir</key>
    <name>Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsstrtok</key>
    <name>Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionstempnam</key>
    <name>Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nonreentrantFunctionsttyname</key>
    <name>Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'</name>
    <description>
      <![CDATA[
Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nullPointer</key>
    <name>Null pointer dereference</name>
    <description>
      <![CDATA[
      <p>
Null pointer dereference
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/476.html" target="_blank">CWE-476: NULL Pointer Dereference</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>obsoleteFunctionsasctime_r</key>
    <name>Obsolete function 'asctime_r' called. It is recommended to use the function 'strftime' instead</name>
    <description>
      <![CDATA[
Obsolete function 'asctime_r' called. It is recommended to use the function 'strftime' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsbcmp</key>
    <name>Obsolete function 'bcmp' called. It is recommended to use the function 'memcmp' instead</name>
    <description>
      <![CDATA[
Obsolete function 'bcmp' called. It is recommended to use the function 'memcmp' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsbcopy</key>
    <name>Obsolete function 'bcopy' called. It is recommended to use the 'memmove' or 'memcpy' function instead</name>
    <description>
      <![CDATA[
Obsolete function 'bcopy' called. It is recommended to use the 'memmove' or 'memcpy' function instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsbsd_signal</key>
    <name>Obsolete function 'bsd_signal' called. It is recommended to use the function 'sigaction' instead</name>
    <description>
      <![CDATA[
Obsolete function 'bsd_signal' called. It is recommended to use the function 'sigaction' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsbzero</key>
    <name>Obsolete function 'bzero' called. It is recommended to use the function 'memset' instead</name>
    <description>
      <![CDATA[
Obsolete function 'bzero' called. It is recommended to use the function 'memset' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsctime_r</key>
    <name>Obsolete function 'ctime_r' called. It is recommended to use the function 'strftime' instead</name>
    <description>
      <![CDATA[
Obsolete function 'ctime_r' called. It is recommended to use the function 'strftime' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsecvt</key>
    <name>Obsolete function 'ecvt' called. It is recommended to use the function 'sprintf' instead</name>
    <description>
      <![CDATA[
Obsolete function 'ecvt' called. It is recommended to use the function 'sprintf' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsfcvt</key>
    <name>Obsolete function 'fcvt' called. It is recommended to use the function 'sprintf' instead</name>
    <description>
      <![CDATA[
Obsolete function 'fcvt' called. It is recommended to use the function 'sprintf' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsftime</key>
    <name>Obsolete function 'ftime' called. It is recommended to use time(), gettimeofday() or clock_gettime() instead</name>
    <description>
      <![CDATA[
Obsolete function 'ftime' called. It is recommended to use time(), gettimeofday() or clock_gettime() instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsgcvt</key>
    <name>Obsolete function 'gcvt' called. It is recommended to use the function 'sprintf' instead</name>
    <description>
      <![CDATA[
Obsolete function 'gcvt' called. It is recommended to use the function 'sprintf' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsgetcontext</key>
    <name>Obsolete function 'getcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
Obsolete function 'getcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsgethostbyaddr</key>
    <name>Obsolete function 'gethostbyaddr' called. It is recommended to use the function 'getnameinfo' instead</name>
    <description>
      <![CDATA[
Obsolete function 'gethostbyaddr' called. It is recommended to use the function 'getnameinfo' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsgethostbyname</key>
    <name>Obsolete function 'gethostbyname' called. It is recommended to use the function 'getaddrinfo' instead</name>
    <description>
      <![CDATA[
Obsolete function 'gethostbyname' called. It is recommended to use the function 'getaddrinfo' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsgetwd</key>
    <name>Obsolete function 'getwd' called. It is recommended to use the function 'getcwd' instead</name>
    <description>
      <![CDATA[
Obsolete function 'getwd' called. It is recommended to use the function 'getcwd' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsindex</key>
    <name>Obsolete function 'index' called. It is recommended to use the function 'strchr' instead</name>
    <description>
      <![CDATA[
Obsolete function 'index' called. It is recommended to use the function 'strchr' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsmakecontext</key>
    <name>Obsolete function 'makecontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
Obsolete function 'makecontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionspthread_attr_getstackaddr</key>
    <name>Obsolete function 'pthread_attr_getstackaddr' called. It is recommended to use the function 'pthread_attr_getstack' instead</name>
    <description>
      <![CDATA[
Obsolete function 'pthread_attr_getstackaddr' called. It is recommended to use the function 'pthread_attr_getstack' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionspthread_attr_setstackaddr</key>
    <name>Obsolete function 'pthread_attr_setstackaddr' called. It is recommended to use the function 'pthread_attr_setstack' instead</name>
    <description>
      <![CDATA[
Obsolete function 'pthread_attr_setstackaddr' called. It is recommended to use the function 'pthread_attr_setstack' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsrand_r</key>
    <name>Obsolete function 'rand_r' called. It is recommended to use the function 'rand' instead</name>
    <description>
      <![CDATA[
Obsolete function 'rand_r' called. It is recommended to use the function 'rand' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsrindex</key>
    <name>Obsolete function 'rindex' called. It is recommended to use the function 'strrchr' instead</name>
    <description>
      <![CDATA[
Obsolete function 'rindex' called. It is recommended to use the function 'strrchr' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsscalbln</key>
    <name>Obsolete function 'scalb' called. It is recommended to use 'scalbln', 'scalblnf' or 'scalblnl' instead</name>
    <description>
      <![CDATA[
Obsolete function 'scalb' called. It is recommended to use 'scalbln', 'scalblnf' or 'scalblnl' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsswapcontext</key>
    <name>Obsolete function 'swapcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
Obsolete function 'swapcontext' called. Due to portability issues, applications are recommended to be rewritten to use POSIX threads.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionstmpnam</key>
    <name>Obsolete function 'tmpnam' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
Obsolete function 'tmpnam' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionstmpnam_r</key>
    <name>Obsolete function 'tmpnam_r' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
Obsolete function 'tmpnam_r' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsualarm</key>
    <name>Obsolete function 'ualarm' called. It is recommended to use 'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or 'timer_settime' instead</name>
    <description>
      <![CDATA[
Obsolete function 'ualarm' called. It is recommended to use 'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or 'timer_settime' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsusleep</key>
    <name>Obsolete function 'usleep' called. It is recommended to use the 'nanosleep' or 'setitimer' function instead</name>
    <description>
      <![CDATA[
The obsolete function 'usleep' is called. POSIX.1-2001 declares usleep() function obsolete and POSIX.1-2008 removes it. It is recommended that new applications use the 'nanosleep' or 'setitimer' function.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsutime</key>
    <name>Obsolete function 'utime' called. It is recommended to use the function 'utimensat' instead</name>
    <description>
      <![CDATA[
Obsolete function 'utime' called. It is recommended to use the function 'utimensat' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionsvfork</key>
    <name>Obsolete function 'vfork' called. It is recommended to use the function 'fork' instead</name>
    <description>
      <![CDATA[
Obsolete function 'vfork' called. It is recommended to use the function 'fork' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>obsoleteFunctionswcswcs</key>
    <name>Obsolete function 'wcswcs' called. It is recommended to use the function 'wcsstr' instead</name>
    <description>
      <![CDATA[
Obsolete function 'wcswcs' called. It is recommended to use the function 'wcsstr' instead.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>operatorEq</key>
    <name>'class::operator=' should return 'class &amp;'</name>
    <description>
      <![CDATA[
      <p>
The class::operator= does not conform to standard C/C++ behaviour. To
conform to standard C/C++ behaviour, return a reference to self (such
as: 'class &amp;class::operator=(..) { .. return *this; }'. For safety
reasons it might be better to not fix this message. If you think that
safety is always more important than conformance then please
ignore/suppress this message. For more details about this topic, see
the book "Effective C++" by Scott Meyers.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>operatorEqRetRefThis</key>
    <name>'operator=' should return reference to 'this' instance</name>
    <description>
      <![CDATA[
      <p>
'operator=' should return reference to 'this' instance.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>operatorEqToSelf</key>
    <name>'operator=' should check for assignment to self to avoid problems with dynamic memory</name>
    <description>
      <![CDATA[
      <p>
'operator=' should check for assignment to self to ensure that each
block of dynamically allocated memory is owned and managed by only one
instance of the class.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>operatorEqVarError</key>
    <name>Member variable 'classname::' is not assigned a value in 'classname::operator='</name>
    <description>
      <![CDATA[
      <p>
Member variable 'classname::' is not assigned a value in
'classname::operator='.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>oppositeInnerCondition</key>
    <name>Opposite inner 'if' condition leads to a dead code block</name>
    <description>
      <![CDATA[
      <p>
Opposite inner 'if' condition leads to a dead code block (outer
condition is 'x' and inner condition is '!x').
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>outOfBounds</key>
    <name>index is out of bounds: Supplied size 2 is larger than actual size 1</name>
    <description>
      <![CDATA[
index is out of bounds: Supplied size 2 is larger than actual size 1.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>passedByValue</key>
    <name>Function parameter 'parametername' should be passed by const reference</name>
    <description>
      <![CDATA[
      <p>
Parameter 'parametername' is passed by value. It could be passed as a
const reference which is usually faster and recommended in C++.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>pointerArithBool</key>
    <name>Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
Converting pointer arithmetic result to bool. The boolean result is
always true unless there is pointer arithmetic overflow, and overflow
is undefined behaviour. Probably a dereference is forgotten.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>pointerLessThanZero</key>
    <name>A pointer can not be negative so it is either pointless or an error to check if it is</name>
    <description>
      <![CDATA[
      <p>
A pointer can not be negative so it is either pointless or an error to
check if it is.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>pointerOutOfBounds</key>
    <name>Pointer arithmetic overflow</name>
    <description>
      <![CDATA[
      <p>
Pointer arithmetic overflow.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>pointerPositive</key>
    <name>A pointer can not be negative so it is either pointless or an error to check if it is not</name>
    <description>
      <![CDATA[
      <p>
A pointer can not be negative so it is either pointless or an error to
check if it is not.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>pointerSize</key>
    <name>Size of pointer 'varname' used instead of size of its data</name>
    <description>
      <![CDATA[
      <p>
Size of pointer 'varname' used instead of size of its data. This is
likely to lead to a buffer overflow. You probably intend to write
'sizeof(*varname)'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/467.html" target="_blank">CWE-467: Use of sizeof() on a Pointer Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>possibleBufferAccessOutOfBounds</key>
    <name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination)</name>
    <description>
      <![CDATA[
Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination). The source buffer is larger than the destination buffer so there is the potential for overflowing the destination buffer.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>postfixOperator</key>
    <name>Prefer prefix ++/-- operators for non-primitive types</name>
    <description>
      <![CDATA[
      <p>
Prefix ++/-- operators should be preferred for non-primitive types.
Pre-increment/decrement can be more efficient than post-
increment/decrement. Post-increment/decrement usually involves keeping
a copy of the previous value around and adds a little extra code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>preprocessorErrorDirective</key>
    <name>#error message</name>
    <description>
      <![CDATA[
#error message
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>publicAllocationError</key>
    <name>Possible leak in public function. The pointer 'varname' is not deallocated before it is allocated</name>
    <description>
      <![CDATA[
      <p>
Possible leak in public function. The pointer 'varname' is not
deallocated before it is allocated.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>readWriteOnlyFile</key>
    <name>Read operation on a file that was opened only for writing</name>
    <description>
      <![CDATA[
      <p>
Read operation on a file that was opened only for writing.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantAssignInSwitch</key>
    <name>Variable 'var' is reassigned a value before the old one has been used. 'break;' missing?</name>
    <description>
      <![CDATA[
      <p>
Variable 'var' is reassigned a value before the old one has been used.
'break;' missing?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantAssignment</key>
    <name>Variable 'var' is reassigned a value before the old one has been used</name>
    <description>
      <![CDATA[
      <p>
Variable 'var' is reassigned a value before the old one has been used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>redundantCondition</key>
    <name>Redundant condition: If x &gt; 11 the condition x &gt; 10 is always true</name>
    <description>
      <![CDATA[
      <p>
Redundant condition: If x > 11 the condition x > 10 is always true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>redundantCopy</key>
    <name>Buffer 'var' is being written before its old content has been used</name>
    <description>
      <![CDATA[
      <p>
Buffer 'var' is being written before its old content has been used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantCopyInSwitch</key>
    <name>Buffer 'var' is being written before its old content has been used. 'break;' missing?</name>
    <description>
      <![CDATA[
      <p>
Buffer 'var' is being written before its old content has been used.
'break;' missing?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantCopyLocalConst</key>
    <name>Use const reference for 'varname' to avoid unnecessary data copying</name>
    <description>
      <![CDATA[
      <p>
The const variable 'varname' is assigned a copy of the data. You can
avoid the unnecessary data copying by converting 'varname' to const
reference.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantIfRemove</key>
    <name>Redundant checking of STL container element existence before removing it</name>
    <description>
      <![CDATA[
      <p>
Redundant checking of STL container element existence before removing
it. It is safe to call the remove method on a non-existing element.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>resourceLeak</key>
    <name>Resource leak: varname</name>
    <description>
      <![CDATA[
<p>
Resource leak: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/775.html" target="_blank">CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnAddressOfAutoVariable</key>
    <name>Address of an auto-variable returned</name>
    <description>
      <![CDATA[
      <p>
Address of an auto-variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnAddressOfFunctionParameter</key>
    <name>Address of function parameter 'parameter' returned</name>
    <description>
      <![CDATA[
      <p>
Address of the function parameter 'parameter' becomes invalid after
the function exits because function parameters are stored on the stack
which is freed when the function exits. Thus the returned value is
invalid.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnLocalVariable</key>
    <name>Pointer to local array variable returned</name>
    <description>
      <![CDATA[
      <p>
Pointer to local array variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnReference</key>
    <name>Reference to local variable returned</name>
    <description>
      <![CDATA[
      <p>
Reference to local variable returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnTempReference</key>
    <name>Reference to temporary returned</name>
    <description>
      <![CDATA[
      <p>
Reference to temporary returned.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>seekOnAppendedFile</key>
    <name>Repositioning operation performed on a file opened in append mode has no effect</name>
    <description>
      <![CDATA[
      <p>
Repositioning operation performed on a file opened in append mode has
no effect.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>selfAssignment</key>
    <name>Redundant assignment of 'varname' to itself</name>
    <description>
      <![CDATA[
      <p>
Redundant assignment of 'varname' to itself.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>selfInitialization</key>
    <name>Member variable 'var' is initialized by itself</name>
    <description>
      <![CDATA[
      <p>
Member variable 'var' is initialized by itself.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>shiftNegative</key>
    <name>Shifting by a negative value is undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
Shifting by a negative value is undefined behaviour
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>shiftTooManyBits</key>
    <name>Shifting 32-bit value by 40 bits is undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
Shifting 32-bit value by 40 bits is undefined behaviour
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>signConversion</key>
    <name>Expression 'var' can have a negative value. That is converted to an unsigned value and used in an unsigned calculation</name>
    <description>
      <![CDATA[
      <p>
Expression 'var' can have a negative value. That is converted to an
unsigned value and used in an unsigned calculation.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/195.html" target="_blank">CWE-195: Signed to Unsigned Conversion Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeArgumentAsChar</key>
    <name>The size argument is given as a char constant</name>
    <description>
      <![CDATA[
The size argument is given as a char constant.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofCalculation</key>
    <name>Found calculation inside sizeof()</name>
    <description>
      <![CDATA[
      <p>
Found calculation inside sizeof().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofDereferencedVoidPointer</key>
    <name>'*varname' is of type 'void', the behaviour of 'sizeof(void)' is not covered by the ISO C standard</name>
    <description>
      <![CDATA[
      <p>
'*varname' is of type 'void', the behaviour of 'sizeof(void)' is not
covered by the ISO C standard. A value for 'sizeof(void)' is defined
only as part of a GNU C extension, which defines 'sizeof(void)' to be
1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofDivisionMemfunc</key>
    <name>Division by result of sizeof(). memset() expects a size in bytes, did you intend to multiply instead?</name>
    <description>
      <![CDATA[
      <p>
Division by result of sizeof(). memset() expects a size in bytes, did
you intend to multiply instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofVoid</key>
    <name>Behaviour of 'sizeof(void)' is not covered by the ISO C standard</name>
    <description>
      <![CDATA[
      <p>
Behaviour of 'sizeof(void)' is not covered by the ISO C standard. A
value for 'sizeof(void)' is defined only as part of a GNU C extension,
which defines 'sizeof(void)' to be 1.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofsizeof</key>
    <name>Calling 'sizeof' on 'sizeof'</name>
    <description>
      <![CDATA[
      <p>
Calling sizeof for 'sizeof looks like a suspicious code and most
likely there should be just one 'sizeof'. The current code is
equivalent to 'sizeof(size_t)'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofwithnumericparameter</key>
    <name>Suspicious usage of 'sizeof' with a numeric constant as parameter</name>
    <description>
      <![CDATA[
      <p>
It is unusual to use a constant value with sizeof. For example,
'sizeof(10)' returns 4 (in 32-bit systems) or 8 (in 64-bit systems)
instead of 10. 'sizeof('A')' and 'sizeof(char)' can return different
results.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sizeofwithsilentarraypointer</key>
    <name>Using 'sizeof' on array given as function argument returns size of a pointer</name>
    <description>
      <![CDATA[
      <p>
Using 'sizeof' for array given as function argument returns the size
of a pointer. It does not return the size of the whole array in bytes
as might be expected. For example, this code:
     int f(char
a[100]) {
         return sizeof(a);
     }
returns 4 (in
32-bit systems) or 8 (in 64-bit systems) instead of 100 (the size of
the array in bytes).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/467.html" target="_blank">CWE-467: Use of sizeof() on a Pointer Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sprintfOverlappingData</key>
    <name>Undefined behavior: Variable 'varname' is used as parameter and destination in s[n]printf()</name>
    <description>
      <![CDATA[
      <p>
The variable 'varname' is used both as a parameter and as destination
in s[n]printf(). The origin and destination buffers overlap. Quote
from glibc (C-library) documentation
(http://www.gnu.org/software/libc/manual/html_mono/libc.html
#Formatted-Output-Functions): "If copying takes place between objects
that overlap as a result of a call to sprintf() or snprintf(), the
results are undefined."
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>staticStringCompare</key>
    <name>Unnecessary comparison of static strings</name>
    <description>
      <![CDATA[
      <p>
The compared strings, 'str1' and 'str2', are always unequal. Therefore
the comparison is unnecessary and looks suspicious.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlBoundaries</key>
    <name>Dangerous comparison using operator&lt; on iterator</name>
    <description>
      <![CDATA[
      <p>
Iterator compared with operator<. This is dangerous since the order of
items in the container is not guaranteed. One should use operator!=
instead to compare iterators.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlIfFind</key>
    <name>Suspicious condition. The result of find() is an iterator, but it is not properly checked</name>
    <description>
      <![CDATA[
      <p>
Suspicious condition. The result of find() is an iterator, but it is
not properly checked.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlIfStrFind</key>
    <name>Inefficient usage of string::find() in condition; string::starts_with() could be faster</name>
    <description>
      <![CDATA[
      <p>
Either inefficient or wrong usage of string::find().
string::starts_with() will be faster if string::find's result is
compared with 0, because it will not scan the whole string. If your
intention is to check that there are no findings in the string, you
should compare with std::string::npos.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/597.html" target="_blank">CWE-597: Use of Wrong Operator in String Comparison</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlOutOfBounds</key>
    <name>When i==foo.size(), foo[i] is out of bounds</name>
    <description>
      <![CDATA[
      <p>
When i==foo.size(), foo[i] is out of bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/788.html" target="_blank">CWE-788: Access of Memory Location After End of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlSize</key>
    <name>Possible inefficient checking for 'list' emptiness</name>
    <description>
      <![CDATA[
      <p>
Checking for 'list' emptiness might be inefficient. Using list.empty()
instead of list.size() can be faster. list.size() can take linear time
but list.empty() is guaranteed to take constant time.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlcstr</key>
    <name>Dangerous usage of c_str(). The value returned by c_str() is invalid after this call</name>
    <description>
      <![CDATA[
      <p>
Dangerous usage of c_str(). The c_str() return value is only valid
until its string is deleted.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlcstrParam</key>
    <name>Passing the result of c_str() to a function that takes std::string as argument no. 0 is slow and redundant</name>
    <description>
      <![CDATA[
      <p>
The conversion from const char* as returned by c_str() to std::string
creates an unnecessary string copy. Solve that by directly passing the
string.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/704.html" target="_blank">CWE-704: Incorrect Type Conversion or Cast</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlcstrReturn</key>
    <name>Returning the result of c_str() in a function that returns std::string is slow and redundant</name>
    <description>
      <![CDATA[
      <p>
The conversion from const char* as returned by c_str() to std::string
creates an unnecessary string copy. Solve that by directly returning
the string.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/704.html" target="_blank">CWE-704: Incorrect Type Conversion or Cast</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>strPlusChar</key>
    <name>Unusual pointer arithmetic. A value of type 'char' is added to a string literal</name>
    <description>
      <![CDATA[
      <p>
Unusual pointer arithmetic. A value of type 'char' is added to a
string literal.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stringCompare</key>
    <name>Comparison of identical string variables</name>
    <description>
      <![CDATA[
      <p>
The compared strings, 'varname1' and 'varname2', are identical. This
could be a logic bug.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>strncatUsage</key>
    <name>Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append</name>
    <description>
      <![CDATA[
At most, strncat appends the 3rd parameter's amount of characters and adds a terminating null byte.\012The safe way to use strncat is to subtract one from the remaining space in the buffer and use it as 3rd parameter.Source: http://www.cplusplus.com/reference/cstring/strncat/\012Source: http://www.opensource.apple.com/source/Libc/Libc-167/gen.subproj/i386.subproj/strncat.c
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>suspiciousSemicolon</key>
    <name>Suspicious use of ; at the end of '' statement</name>
    <description>
      <![CDATA[
      <p>
Suspicious use of ; at the end of '' statement.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>switchCaseFallThrough</key>
    <name>Switch falls through case without comment. 'break;' missing?</name>
    <description>
      <![CDATA[
Switch falls through case without comment. 'break;' missing?
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>terminateStrncpy</key>
    <name>The buffer 'buffer' may not be null-terminated after the call to strncpy()</name>
    <description>
      <![CDATA[
If the source string's size fits or exceeds the given size, strncpy() does not add a zero at the end of the buffer. This causes bugs later in the code if the code assumes buffer is null-terminated.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>thisSubtraction</key>
    <name>Suspicious pointer subtraction. Did you intend to write '-&gt;'?</name>
    <description>
      <![CDATA[
      <p>
Suspicious pointer subtraction. Did you intend to write '->'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>toomanyconfigs</key>
    <name>Too many #ifdef configurations - cppcheck only checks 12 configurations. Use --force to check all configurations. For more details, use --enable=information</name>
    <description>
      <![CDATA[
      <p>
The checking of the file will be interrupted because there are too
many #ifdef configurations. Checking of all #ifdef configurations can
be forced by --force command line option or from GUI preferences.
However that may increase the checking time. For more details, use
--enable=information.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unassignedVariable</key>
    <name>Variable 'varname' is not assigned a value</name>
    <description>
      <![CDATA[
      <p>
Variable 'varname' is not assigned a value.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/665.html" target="_blank">CWE-665: Improper Initialization</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>uninitMemberVar</key>
    <name>Member variable 'classname::varname' is not initialized in the constructor</name>
    <description>
      <![CDATA[
      <p>
Member variable 'classname::varname' is not initialized in the
constructor.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitStructMember</key>
    <name>Uninitialized struct member: a.b</name>
    <description>
      <![CDATA[
      <p>
Uninitialized struct member: a.b
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/457.html" target="_blank">CWE-457: Use of Uninitialized Variable</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitdata</key>
    <name>Memory is allocated but not initialized: varname</name>
    <description>
      <![CDATA[
      <p>
Memory is allocated but not initialized: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/457.html" target="_blank">CWE-457: Use of Uninitialized Variable</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitstring</key>
    <name>Dangerous usage of 'varname' (strncpy doesn't always null-terminate it)</name>
    <description>
      <![CDATA[
      <p>
Dangerous usage of 'varname' (strncpy doesn't always null-terminate
it).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/676.html" target="_blank">CWE-676: Use of Potentially Dangerous Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitvar</key>
    <name>Uninitialized variable: varname</name>
    <description>
      <![CDATA[
      <p>
Uninitialized variable: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/457.html" target="_blank">CWE-457: Use of Uninitialized Variable</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unnecessaryForwardDeclaration</key>
    <name>The variable 'name' forward declaration is unnecessary. Type variable is already declared earlier</name>
    <description>
      <![CDATA[
The variable 'name' forward declaration is unnecessary. Type variable is already declared earlier.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unnecessaryQualification</key>
    <name>The extra qualification 'type' is unnecessary and is considered an error by many compilers</name>
    <description>
      <![CDATA[
The extra qualification 'type' is unnecessary and is considered an error by many compilers.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unpreciseMathCall</key>
    <name>Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of precision</name>
    <description>
      <![CDATA[
      <p>
Expression '1 - erf(x)' can be replaced by 'erfc(x)' to avoid loss of
precision.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unreachableCode</key>
    <name>Statements following return, break, continue, goto or throw will never be executed</name>
    <description>
      <![CDATA[
      <p>
Statements following return, break, continue, goto or throw will never
be executed.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/561.html" target="_blank">CWE-561: Dead Code</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unreadVariable</key>
    <name>Variable 'varname' is assigned a value that is never used</name>
    <description>
      <![CDATA[
      <p>
Variable 'varname' is assigned a value that is never used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unsafeClassCanLeak</key>
    <name>Class 'class' is unsafe, 'class::varname' can leak by wrong usage</name>
    <description>
      <![CDATA[
      <p>
The class 'class' is unsafe, wrong usage can cause memory/resource
leaks for 'class::varname'. This can for instance be fixed by adding
proper cleanup in the destructor.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unsignedLessThanZero</key>
    <name>Checking if unsigned expression 'varname' is less than zero</name>
    <description>
      <![CDATA[
      <p>
The unsigned expression 'varname' will never be negative so it is
either pointless or an error to check if it is.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unsignedPositive</key>
    <name>Unsigned expression 'varname' can't be negative so it is unnecessary to test it</name>
    <description>
      <![CDATA[
      <p>
Unsigned expression 'varname' can't be negative so it is unnecessary
to test it.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedAllocatedMemory</key>
    <name>Variable 'varname' is allocated memory that is never used</name>
    <description>
      <![CDATA[
      <p>
Variable 'varname' is allocated memory that is never used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedFunction</key>
    <name>The function 'funcName' is never used</name>
    <description>
      <![CDATA[
      <p>
The function 'funcName' is never used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/561.html" target="_blank">CWE-561: Dead Code</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedPrivateFunction</key>
    <name>Unused private function: 'classname::funcname'</name>
    <description>
      <![CDATA[
      <p>
Unused private function: 'classname::funcname'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedScopedObject</key>
    <name>Instance of 'varname' object is destroyed immediately</name>
    <description>
      <![CDATA[
      <p>
Instance of 'varname' object is destroyed immediately.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedStructMember</key>
    <name>struct member 'structname::variable' is never used</name>
    <description>
      <![CDATA[
      <p>
struct member 'structname::variable' is never used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedVariable</key>
    <name>Unused variable: varname</name>
    <description>
      <![CDATA[
      <p>
Unused variable: varname
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>useAutoPointerArray</key>
    <name>Object pointed by an 'auto_ptr' is destroyed using operator 'delete'. You should not use 'auto_ptr' for pointers obtained with operator 'new[]'</name>
    <description>
      <![CDATA[
Object pointed by an 'auto_ptr' is destroyed using operator 'delete'. This means that you should only use 'auto_ptr' for pointers obtained with operator 'new'. This excludes arrays, which are allocated by operator 'new[]' and must be deallocated by operator 'delete[]'.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>useAutoPointerContainer</key>
    <name>You can randomly lose access to pointers if you store 'auto_ptr' pointers in an STL container</name>
    <description>
      <![CDATA[
An element of container must be able to be copied but 'auto_ptr' does not fulfill this requirement. You should consider to use 'shared_ptr' or 'unique_ptr'. It is suitable for use in containers, because they no longer copy their values, they move them.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>useAutoPointerCopy</key>
    <name>Copying 'auto_ptr' pointer to another does not create two equal objects since one has lost its ownership of the pointer</name>
    <description>
      <![CDATA[
'std::auto_ptr' has semantics of strict ownership, meaning that the 'auto_ptr' instance is the sole entity responsible for the object's lifetime. If an 'auto_ptr' is copied, the source looses the reference.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>useClosedFile</key>
    <name>Used file that is not opened</name>
    <description>
      <![CDATA[
      <p>
Used file that is not opened.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/910.html" target="_blank">CWE-910: Use of Expired File Descriptor</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>useInitializationList</key>
    <name>Variable 'variable' is assigned in constructor body. Consider performing initialization in initialization list</name>
    <description>
      <![CDATA[
      <p>
When an object of a class is created, the constructors of all member
variables are called consecutively in the order the variables are
declared, even if you don't explicitly write them to the
initialization list. You could avoid assigning 'variable' a value by
passing the value to the constructor in the initialization list.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uselessAssignmentArg</key>
    <name>Assignment of function parameter has no effect outside the function</name>
    <description>
      <![CDATA[
      <p>
Assignment of function parameter has no effect outside the function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>uselessAssignmentPtrArg</key>
    <name>Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?</name>
    <description>
      <![CDATA[
      <p>
Assignment of function parameter has no effect outside the function.
Did you forget dereferencing it?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uselessCallsCompare</key>
    <name>It is inefficient to call 'str.find(str)' as it always returns 0</name>
    <description>
      <![CDATA[
      <p>
'std::string::find()' returns zero when given itself as parameter
(str.find(str)). As it is currently the code is inefficient. It is
possible either the string searched ('str') or searched for ('str') is
wrong.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uselessCallsEmpty</key>
    <name>Ineffective call of function 'empty()'. Did you intend to call 'clear()' instead?</name>
    <description>
      <![CDATA[
      <p>
Ineffective call of function 'empty()'. Did you intend to call
'clear()' instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uselessCallsRemove</key>
    <name>Return value of std::remove() ignored. Elements remain in container</name>
    <description>
      <![CDATA[
      <p>
The return value of std::remove() is ignored. This function returns an
iterator to the end of the range containing those elements that should
be kept. Elements past new end remain valid but with unspecified
values. Use the erase method of the container to delete them.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uselessCallsSubstr</key>
    <name>Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead</name>
    <description>
      <![CDATA[
      <p>
Ineffective call of function 'substr' because it returns a copy of the
object. Use operator= instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uselessCallsSwap</key>
    <name>It is inefficient to swap a object with itself by calling 'str.swap(str)'</name>
    <description>
      <![CDATA[
      <p>
The 'swap()' function has no logical effect when given itself as
parameter (str.swap(str)). As it is currently the code is inefficient.
Is the object or the parameter wrong here?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>va_end_missing</key>
    <name>va_list 'vl' was opened but not closed by va_end()</name>
    <description>
      <![CDATA[
      <p>
va_list 'vl' was opened but not closed by va_end().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>va_list_usedBeforeStarted</key>
    <name>va_list 'vl' used before va_start() was called</name>
    <description>
      <![CDATA[
      <p>
va_list 'vl' used before va_start() was called.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>va_start_referencePassed</key>
    <name>Using reference 'arg1' as parameter for va_start() results in undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
Using reference 'arg1' as parameter for va_start() results in
undefined behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>va_start_subsequentCalls</key>
    <name>va_start() or va_copy() called subsequently on 'vl' without va_end() in between</name>
    <description>
      <![CDATA[
      <p>
va_start() or va_copy() called subsequently on 'vl' without va_end()
in between.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>va_start_wrongParameter</key>
    <name>'arg1' given to va_start() is not last named argument of the function. Did you intend to pass 'arg2'?</name>
    <description>
      <![CDATA[
      <p>
'arg1' given to va_start() is not last named argument of the function.
Did you intend to pass 'arg2'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/688.html" target="_blank">CWE-688: Function Call With Incorrect Variable or Reference as Argument</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>varFuncNullUB</key>
    <name>Passing NULL after the last typed argument to a variadic function leads to undefined behaviour</name>
    <description>
      <![CDATA[
      <p>
Passing NULL after the last typed argument to a variadic function
leads to undefined behaviour.
The C99 standard, in section
7.15.1.1, states that if the type used by va_arg() is not compatible
with the type of the actual next argument (as promoted according to
the default argument promotions), the behavior is undefined.
The
value of the NULL macro is an implementation-defined null pointer
constant (7.17), which can be any integer constant expression with the
value 0, or such an expression casted to (void*) (6.3.2.3). This
includes values like 0, 0L, or even 0LL.
In practice on common
architectures, this will cause real crashes if sizeof(int) !=
sizeof(void*), and NULL is defined to 0 or any other null pointer
constant that promotes to int.
To reproduce you might be able to
use this little code example on 64bit platforms. If the output
includes "ERROR", the sentinel had only 4 out of 8 bytes initialized
to zero and was not detected as the final argument to stop argument
processing via va_arg(). Changing the 0 to (void*)0 or 0L will make
the "ERROR" output go away.
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

void f(char *s, ...) {
    va_list ap;
va_start(ap,s);
    for (;;) {
        char *p =
va_arg(ap,char*);
        printf("%018p, %s\n", p, (long)p & 255 ?
p : "");
        if(!p) break;
    }
va_end(ap);
}
void g() {
    char *s2 = "x";
    char
*s3 = "ERROR";
    // changing 0 to 0L for the 7th argument
(which is intended to act as sentinel) makes the error go away on
x86_64
    f("first", s2, s2, s2, s2, s2, 0, s3,
(char*)0);
}
void h() {
    int i;
    volatile
unsigned char a[1000];
    for (i = 0; i&lt;sizeof(a); i++)
a[i] = -1;
}
int main() {
    h();
    g();
return 0;
}
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/475.html" target="_blank">CWE-475: Undefined Behavior for Input to API</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>variableHidingEnum</key>
    <name>variable 'name' hides enumerator with same name</name>
    <description>
      <![CDATA[
variable 'name' hides enumerator with same name
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>variableHidingTypedef</key>
    <name>The variable 'name' hides a typedef with the same name</name>
    <description>
      <![CDATA[
The variable 'name' hides a typedef with the same name.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>variableScope</key>
    <name>The scope of the variable 'varname' can be reduced</name>
    <description>
      <![CDATA[
      <p>
The scope of the variable 'varname' can be reduced. Warning: Be
careful when fixing this message, especially when there are inner
loops. Here is an example where cppcheck will write that the scope for
'i' can be reduced:
void f(int x)
{
    int i = 0;
    if
(x) {
        // it's safe to move 'int i = 0;' here
        for
(int n = 0; n < 10; ++n) {
            // it is possible but not
safe to move 'int i = 0;' here
            do_something(&amp;i);

}
    }
}
When you see this message it is always safe to
reduce the variable scope 1 level.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>virtualDestructor</key>
    <name>Class 'Base' which is inherited by class 'Derived' does not have a virtual destructor</name>
    <description>
      <![CDATA[
      <p>
Class 'Base' which is inherited by class 'Derived' does not have a
virtual destructor. If you destroy instances of the derived class by
deleting a pointer that points to the base class, only the destructor
of the base class is executed. Thus, dynamic memory that is managed by
the derived class could leak. This can be avoided by adding a virtual
destructor to the base class.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/404.html" target="_blank">CWE-404: Improper Resource Shutdown or Release</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>writeReadOnlyFile</key>
    <name>Write operation on a file that was opened only for reading</name>
    <description>
      <![CDATA[
      <p>
Write operation on a file that was opened only for reading.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>wrongPipeParameterSize</key>
    <name>Buffer 'varname' must have size of 2 integers if used as parameter of pipe()</name>
    <description>
      <![CDATA[
      <p>
The pipe()/pipe2() system command takes an argument, which is an array
of exactly two integers.
The variable 'varname' is an array of size
dimension, which does not match.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/686.html" target="_blank">CWE-686: Function Call With Incorrect Argument Type</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>wrongPrintfScanfArgNum</key>
    <name>printf format string requires 3 parameters but only 2 are given</name>
    <description>
      <![CDATA[
      <p>
printf format string requires 3 parameters but only 2 are given.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/685.html" target="_blank">CWE-685: Function Call With Incorrect Number of Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>wrongPrintfScanfParameterPositionError</key>
    <name>printf: referencing parameter 2 while 1 arguments given</name>
    <description>
      <![CDATA[
      <p>
printf: referencing parameter 2 while 1 arguments given
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/685.html" target="_blank">CWE-685: Function Call With Incorrect Number of Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>wrongmathcall</key>
    <name>Passing value '#' to #() leads to implementation-defined result</name>
    <description>
      <![CDATA[
      <p>
Passing value '#' to #() leads to implementation-defined result.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>zerodiv</key>
    <name>Division by zero</name>
    <description>
      <![CDATA[
      <p>
Division by zero.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/369.html" target="_blank">CWE-369: Divide By Zero</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>zerodivcond</key>
    <name>Either the condition is redundant or there is division by zero</name>
    <description>
      <![CDATA[
      <p>
Either the condition is redundant or there is division by zero.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/369.html" target="_blank">CWE-369: Divide By Zero</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>comparisonOfBoolWithInvalidComparator</key>
    <name>Comparison of a boolean value using relational operator (&lt;, &gt;, &lt;= or &gt;=)</name>
    <description>
      <![CDATA[
      The result of the expression 'expression' is of type 'bool'. Comparing 'bool' value using relational (<, >, <= or >=) operator could cause unexpected results.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>identicalConditionAfterEarlyExit</key>
    <name>Identical condition 'x', second condition is always false</name>
    <description>
      <![CDATA[
<p>
Identical condition 'x', second condition is always false
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidFree</key>
    <name>Mismatching address is freed. The address you get from malloc() must be freed without offset</name>
    <description>
      <![CDATA[
Mismatching address is freed. The address you get from malloc() must be freed without offset.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantBitwiseOperationInSwitch</key>
    <name>Redundant bitwise operation on 'varname' in 'switch' statement. 'break;' missing?</name>
    <description>
      <![CDATA[
Redundant bitwise operation on 'varname' in 'switch' statement. 'break;' missing?
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>shiftTooManyBitsSigned</key>
    <name>Shifting signed 32-bit value by 31 bits is implementation-defined behaviour</name>
    <description>
      <![CDATA[
<p>
Shifting signed 32-bit value by 31 bits is implementation-defined
behaviour
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlcstrthrow</key>
    <name>Dangerous usage of c_str(). The value returned by c_str() is invalid after throwing exception</name>
    <description>
      <![CDATA[
Dangerous usage of c_str(). The string is destroyed after the c_str() call so the thrown pointer is invalid.
]]>
    </description>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 1.6.9 ########### -->
  <rule>
    <key>duplicateExpressionTernary</key>
    <name>Same expression in both branches of ternary operator</name>
    <description>
      <![CDATA[
<p>
Finding the same expression in both branches of ternary operator is
suspicious as the same code is executed regardless of the condition.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>noExplicitConstructor</key>
    <name>Class 'classname' has a constructor with 1 argument that is not explicit</name>
    <description>
      <![CDATA[
<p>
Class 'classname' has a constructor with 1 argument that is not
explicit. Such constructors should in general be explicit for type
safety reasons. Using the explicit keyword in the constructor means
some mistakes when using the class can be avoided.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>noExplicitCopyMoveConstructor</key>
    <name>Abstract class has a copy/move constructor that is not explicit</name>
    <description>
      Abstract class &apos;classname&apos; has a copy/move constructor that is not explicit.
    </description>
  </rule>
  <rule>
    <key>operatorEqMissingReturnStatement</key>
    <name>No 'return' statement in non-void function causes undefined behavior</name>
    <description>
      <![CDATA[
<p>
No 'return' statement in non-void function causes undefined behavior.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>operatorEqShouldBeLeftUnimplemented</key>
    <name>'operator=' should either return reference to 'this' instance or be declared private and left unimplemented</name>
    <description>
      <![CDATA[
<p>
'operator=' should either return reference to 'this' instance or be
declared private and left unimplemented.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>redundantPointerOp</key>
    <name>Redundant pointer operation on 'varname' - it's already a pointer</name>
    <description>
      <![CDATA[
<p>
Redundant pointer operation on 'varname' - it's already a pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>throwInNoexceptFunction</key>
    <name>Exception thrown in function declared not to throw exceptions</name>
    <description>
      <![CDATA[
<p>
Exception thrown in function declared not to throw exceptions.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>useAutoPointerMalloc</key>
    <name>Object pointed by an 'auto_ptr' is destroyed using operator 'delete'</name>
    <description>
      <![CDATA[
<p>
Object pointed by an 'auto_ptr' is destroyed using operator 'delete'.
You should not use 'auto_ptr' for pointers obtained with function
'malloc'. This means that you should only use 'auto_ptr' for pointers
obtained with operator 'new'. This excludes use C library allocation
functions (for example 'malloc'), which must be deallocated by the
appropriate C library function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/762.html" target="_blank">CWE-762: Mismatched Memory Management Routines</a></p>
]]>
    </description>
    <tag>cwe</tag>
  </rule>
  <!-- ########### New in Cppcheck 1.7.0 ########### -->
  <rule>
    <key>negativeArraySize</key>
    <name>Declaration of array with negative size is undefined behaviour</name>
    <description>
      <![CDATA[<p>
Declaration of array with negative size is undefined behaviour
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cert</tag>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>badBitmaskCheck</key>
    <name>Result of operator '|' is always true if one operand is non-zero. Did you intend to use '&amp;'?</name>
    <description>
      <![CDATA[
<p>
Result of operator '|' is always true if one operand is non-zero. Did
you intend to use '&'?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>knownConditionTrueFalse</key>
    <name>Condition 'x' is always false</name>
    <description>
      <![CDATA[
      <p>
Condition 'x' is always false
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>nullPointerDefaultArg</key>
    <name>Possible null pointer dereference if the default parameter value is used: pointer</name>
    <description>
      <![CDATA[
<p>
Possible null pointer dereference if the default parameter value is
used: pointer
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/476.html" target="_blank">CWE-476: NULL Pointer Dereference</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nullPointerRedundantCheck</key>
    <name>Either the condition is redundant or there is possible null pointer dereference: pointer</name>
    <description>
      <![CDATA[
<p>
Either the condition is redundant or there is possible null pointer
dereference: pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/476.html" target="_blank">CWE-476: NULL Pointer Dereference</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>obsoleteFunctionsalloca</key>
    <name>Obsolete function &apos;alloca&apos; called</name>
    <description>
      Obsolete function &apos;alloca&apos; called. In C99 and later it is recommended to use a variable length array instead.
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>raceAfterInterlockedDecrement</key>
    <name>Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead</name>
    <description>
      <![CDATA[
<p>
Race condition: non-interlocked access after InterlockedDecrement().
Use InterlockedDecrement() return value instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/362.html" target="_blank">CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unusedLabel</key>
    <name>Label '' is not used</name>
    <description>
      <![CDATA[
<p>
Label '' is not used.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>stringLiteralWrite</key>
    <name>Modifying string literal directly or indirectly is undefined behaviour</name>
    <description>
      <![CDATA[
<p>
Modifying string literal directly or indirectly is undefined
behaviour.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>truncLongCastAssignment</key>
    <name>int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information</name>
    <description>
      <![CDATA[
<p>
int result is assigned to long variable. If the variable is long to
avoid loss of information, then there is loss of information. To avoid
loss of information you must cast a calculation operand to long, for
example 'l = a * b;' => 'l = (long)a * b;'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/197.html" target="_blank">CWE-197: Numeric Truncation Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>truncLongCastReturn</key>
    <name>int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information</name>
    <description>
      <![CDATA[
<p>
int result is returned as long value. If the return value is long to
avoid loss of information, then there is loss of information. To avoid
loss of information you must cast a calculation operand to long, for
example 'return a*b;' => 'return (long)a*b'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/197.html" target="_blank">CWE-197: Numeric Truncation Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <!-- ########### New in Cppcheck 1.7.2 ########### -->
  <rule>
    <key>assignBoolToFloat</key>
    <name>Boolean value assigned to floating point variable</name>
    <description>
      <![CDATA[
      <p>
Boolean value assigned to floating point variable.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/704.html" target="_blank">CWE-704: Incorrect Type Conversion or Cast</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>invalidTestForOverflow</key>
    <name>Invalid test for overflow 'x + c &lt; x'; signed integer overflow is undefined behavior. Some mainstream compilers remove such overflow tests when optimising the code and assume it's always false</name>
    <description>
      <![CDATA[
<p>
Invalid test for overflow 'x + c < x'; signed integer overflow is
undefined behavior. Some mainstream compilers remove such overflow
tests when optimising the code and assume it's always false.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/391.html" target="_blank">CWE-391: Unchecked Error Condition</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unknownEvaluationOrder</key>
    <name>Expression 'x = x++;' depends on order of evaluation of side effects</name>
    <description>
      <![CDATA[
<p>
Expression 'x = x++;' depends on order of evaluation of side effects
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/768.html" target="_blank">CWE-768: Incorrect Short Circuit Evaluation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 1.7.3 ########### -->
  <rule>
    <key>signedCharArrayIndex</key>
    <name>Signed 'char' type used as array index</name>
    <description>
      <![CDATA[
<p>
Signed 'char' type used as array index. If the value can be greater
than 127 there will be a buffer underflow because of sign extension.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/128.html" target="_blank">CWE-128: Wrap-around Error</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unknownSignCharArrayIndex</key>
    <name>'char' type used as array index</name>
    <description>
      <![CDATA[
<p>
'char' type used as array index. Values greater than 127 will be
treated depending on whether 'char' is signed or unsigned on target
platform.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unusedLabelSwitch</key>
    <name>Label '' is not used. Should this be a 'case' of the enclosing switch()?</name>
    <description>
      <![CDATA[
<p>
Label '' is not used. Should this be a 'case' of the enclosing
switch()?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 1.7.6 ########### -->
  <!-- this warnings is not reported by "cppcheck -errorlist" -->
  <rule>
    <key>leakUnsafeArgAlloc</key>
    <name>Unsafe allocation. If funcName() throws, memory could be leaked. Use make_shared&lt;int&gt;() instead</name>
    <description>
      <![CDATA[
<p>
Unsafe allocation. If funcName() throws, memory could be leaked. Use
make_shared&lt;int&gt;() instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/401.html" target="_blank">CWE-401: Missing Release of Memory after Effective Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>suspiciousCase</key>
    <name>Found suspicious case label in switch(). Operator '||' probably doesn't work as intended</name>
    <description>
      <![CDATA[
<p>
Using an operator like '||' in a case label is suspicious. Did you
intend to use a bitwise operator, multiple case labels or if/else
instead?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>multiplySizeof</key>
    <name>Multiplying sizeof() with sizeof() indicates a logic error</name>
    <description>
      <![CDATA[
      <p>
Multiplying sizeof() with sizeof() indicates a logic error.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>divideSizeof</key>
    <name>Division of result of sizeof() on pointer type</name>
    <description>
      <![CDATA[
<p>
Division of result of sizeof() on pointer type. sizeof() returns the
size of the pointer, not the size of the memory area it points to.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>reademptycontainer</key>
    <name>Reading from empty STL container 'var'</name>
    <description>
      <![CDATA[
      <p>
Reading from empty STL container 'var'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <!-- ########### New in Cppcheck 1.7.7 ########### -->
  <rule>
    <key>nullPointerArithmetic</key>
    <name>Pointer arithmetic with NULL pointer</name>
    <description>
      <![CDATA[
<p>
Pointer arithmetic with NULL pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>shiftNegativeLHS</key>
    <name>Shifting a negative value is technically undefined behaviour</name>
    <description>
      <![CDATA[
<p>
Shifting a negative value is technically undefined behaviour
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>accessMoved</key>
    <name>Access of moved variable 'v'</name>
    <description>
      <![CDATA[
<p>
Access of moved variable 'v'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/672.html" target="_blank">CWE-672: Operation on a Resource after Expiration or Release</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>accessForwarded</key>
    <name>Access of forwarded variable 'v'</name>
    <description>
      <![CDATA[
      <p>
Access of forwarded variable 'v'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/672.html" target="_blank">CWE-672: Operation on a Resource after Expiration or Release</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>floatConversionOverflow</key>
    <name>Undefined behaviour: float (1e+100) to integer conversion overflow</name>
    <description>
      <![CDATA[
<p>
Undefined behaviour: float (1e+100) to integer conversion overflow.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/190.html" target="_blank">CWE-190: Integer Overflow or Wraparound</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 1.7.8 ########### -->
  <rule>
    <key>funcArgNamesDifferent</key>
    <name>Function 'function' argument 2 names different: declaration 'A' definition 'B'</name>
    <description>
      <![CDATA[
<p>
Function 'function' argument 2 names different: declaration 'A'
definition 'B'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>funcArgOrderDifferent</key>
    <name>Function 'function' argument order different: declaration '' definition ''</name>
    <description>
      <![CDATA[
<p>
Function 'function' argument order different: declaration ''
definition ''
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/683.html" target="_blank">CWE-683: Function Call With Incorrect Order of Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>copyCtorAndEqOperator</key>
    <name>The class 'class' has 'operator=' but lack of 'copy constructor'</name>
    <description>
      <![CDATA[
The class 'class' has 'operator=' but lack of 'copy constructor'.
    ]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 1.8.2 ########### -->
  <rule>
    <key>unsafeClassDivZero</key>
    <name>Public interface of Class is not safe</name>
    <description>
      <![CDATA[
Public interface of Class is not safe. When calling Class::dostuff(), if parameter x is 0 that leads to division by zero.
    ]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>pointerAdditionResultNotNull</key>
    <name>Comparison is wrong. Result of 'ptr+1' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour</name>
    <description>
      <![CDATA[
Comparison is wrong. Result of 'ptr+1' can't be 0 unless there is pointer overflow, and pointer overflow is undefined behaviour.
    ]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>overlappingStrcmp</key>
    <name>The expression 'strcmp(x,"def") != 0' is suspicious. It overlaps 'strcmp(x,"abc") == 0'</name>
    <description>
      <![CDATA[
The expression 'strcmp(x,"def") != 0' is suspicious. It overlaps 'strcmp(x,"abc") == 0'.
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <!-- ########### keys matching the schema <some-function-id>Called are not listed by the simple cppcheck -errorlist          ########### -->
  <!-- ########### they become visible only if corresponding library was loaded, e.g. cppcheck -errorlist -library=posix.cfg   ########### -->
  <!-- ########### see generate_cppcheck_resources.sh for more details                                                         ########### -->
  <rule>
    <key>LocalAllocCalled</key>
    <name>Obsolete function 'LocalAlloc' called. It is recommended to use 'HeapAlloc' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'LocalAlloc' called. It is recommended to use
'HeapAlloc' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>RtlFillBytesCalled</key>
    <name>Obsolete function 'RtlFillBytes' called. It is recommended to use 'RtlFillMemory' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'RtlFillBytes' called. It is recommended to use
'RtlFillMemory' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>RtlZeroBytesCalled</key>
    <name>Obsolete function 'RtlZeroBytes' called. It is recommended to use 'RtlZeroMemory' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'RtlZeroBytes' called. It is recommended to use
'RtlZeroMemory' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>asctime_rCalled</key>
    <name>Obsolescent function 'asctime_r' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'asctime_r' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>autoVariablesAssignGlobalPointer</key>
    <name>Address of local array array is assigned to global pointer pointer and not reassigned before array goes out of scope</name>
    <description>
      <![CDATA[
<p>
Address of local array array is assigned to global pointer pointer and
not reassigned before array goes out of scope.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>bcmpCalled</key>
    <name>Obsolescent function 'bcmp' called. It is recommended to use 'memcmp' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bcmp' called. It is recommended to use 'memcmp'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>bcopyCalled</key>
    <name>Obsolescent function 'bcopy' called. It is recommended to use 'memcpy' or 'memmove' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bcopy' called. It is recommended to use 'memcpy'
or 'memmove' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>bsd_signalCalled</key>
    <name>Obsolescent function 'bsd_signal' called. It is recommended to use 'sigaction' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bsd_signal' called. It is recommended to use
'sigaction' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>bzeroCalled</key>
    <name>Obsolescent function 'bzero' called. It is recommended to use 'memset' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'bzero' called. It is recommended to use 'memset'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>cryptCalled</key>
    <name>Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'crypt' called. For threadsafe applications it
is recommended to use the reentrant replacement function 'crypt_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>ctermidCalled</key>
    <name>Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'ctermid' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'ctermid_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>ctime_rCalled</key>
    <name>Obsolescent function 'ctime_r' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'ctime_r' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>ecvtCalled</key>
    <name>Obsolescent function 'ecvt' called. It is recommended to use 'sprintf' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'ecvt' called. It is recommended to use 'sprintf'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>fcvtCalled</key>
    <name>Obsolescent function 'fcvt' called. It is recommended to use 'sprintf' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'fcvt' called. It is recommended to use 'sprintf'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>fgetgrentCalled</key>
    <name>Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'fgetgrent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'fgetgrent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>fgetpwentCalled</key>
    <name>Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'fgetpwent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'fgetpwent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>fgetspentCalled</key>
    <name>Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'fgetspent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'fgetspent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>gcvtCalled</key>
    <name>Obsolescent function 'gcvt' called. It is recommended to use 'sprintf' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'gcvt' called. It is recommended to use 'sprintf'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getcontextCalled</key>
    <name>Obsolescent function 'getcontext' called. Applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'getcontext' called. Applications are recommended
to be rewritten to use POSIX threads.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getgrentCalled</key>
    <name>Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getgrent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getgrent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getgrgidCalled</key>
    <name>Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getgrgid' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getgrgid_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getgrnamCalled</key>
    <name>Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getgrnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getgrnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>gethostbyaddrCalled</key>
    <name>Obsolescent function 'gethostbyaddr' called. It is recommended to use 'getnameinfo' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'gethostbyaddr' called. It is recommended to use
'getnameinfo' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>gethostbyname2Called</key>
    <name>Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'gethostbyname2' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'gethostbyname2_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>gethostentCalled</key>
    <name>Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'gethostent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'gethostent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getloginCalled</key>
    <name>Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getlogin' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getlogin_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getnetbyaddrCalled</key>
    <name>Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetbyaddr' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getnetbyaddr_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getnetbynameCalled</key>
    <name>Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetbyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getnetbyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getnetentCalled</key>
    <name>Non reentrant function 'getnetent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getnetent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getnetgrentCalled</key>
    <name>Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getnetgrent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getnetgrent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getprotobynameCalled</key>
    <name>Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getprotobyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getprotobyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getprotobynumberCalled</key>
    <name>Non reentrant function 'getprotobynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobynumber_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getprotobynumber' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getprotobynumber_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getprotoentCalled</key>
    <name>Non reentrant function 'getprotoent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotoent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getprotoent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getprotoent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getpwentCalled</key>
    <name>Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getpwent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getpwent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getpwnamCalled</key>
    <name>Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getpwnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getpwnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getpwuidCalled</key>
    <name>Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getpwuid' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getpwuid_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getrpcbynameCalled</key>
    <name>Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getrpcbyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getrpcbyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getrpcbynumberCalled</key>
    <name>Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getrpcbynumber' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getrpcbynumber_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getrpcentCalled</key>
    <name>Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getrpcent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getrpcent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getsCalled</key>
    <name>Obsolete function 'gets' called. It is recommended to use 'fgets' or 'gets_s' instead</name>
    <description>
      <![CDATA[
<p>
The obsolete function 'gets' is called. With 'gets' you'll get a
buffer overrun if the input data exceeds the size of the buffer. It is
recommended to use the functions 'fgets' or 'gets_s' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getservbynameCalled</key>
    <name>Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getservbyname' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getservbyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getservbyportCalled</key>
    <name>Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getservbyport' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getservbyport_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getserventCalled</key>
    <name>Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getservent' called. For threadsafe
applications it is recommended to use the reentrant replacement
function 'getservent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getspentCalled</key>
    <name>Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getspent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getspent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getspnamCalled</key>
    <name>Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'getspnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'getspnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>getwdCalled</key>
    <name>Obsolescent function 'getwd' called. It is recommended to use 'getcwd' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'getwd' called. It is recommended to use 'getcwd'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>indexCalled</key>
    <name>Obsolescent function 'index' called. It is recommended to use 'strchr' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'index' called. It is recommended to use 'strchr'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>lstrcatCalled</key>
    <name>Due to security concerns it is not recommended to use this function, see MSDN for details</name>
    <description>
      <![CDATA[
<p>
Due to security concerns it is not recommended to use this function,
see MSDN for details.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>makecontextCalled</key>
    <name>Obsolescent function 'makecontext' called. Applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'makecontext' called. Applications are
recommended to be rewritten to use POSIX threads.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>mktempCalled</key>
    <name>Obsolete function 'mktemp' called. It is recommended to use 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
<p>
The function 'mktemp' is considered to be dangerous due to race
conditions and some implementations generating only up to 26 different
filenames out of each template. This function has been removed in
POSIX.1-2008. Use 'mkstemp' or 'mkdtemp' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>pthread_attr_getstackaddrCalled</key>
    <name>Obsolescent function 'pthread_attr_getstackaddr' called. It is recommended to use 'pthread_attr_getstack' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'pthread_attr_getstackaddr' called. It is
recommended to use 'pthread_attr_getstack' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>pthread_attr_setstackaddrCalled</key>
    <name>Obsolescent function 'pthread_attr_setstackaddr' called. It is recommended to use 'pthread_attr_setstack' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'pthread_attr_setstackaddr' called. It is
recommended to use 'pthread_attr_setstack' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>rand_rCalled</key>
    <name>Obsolescent function 'rand_r' called. It is recommended to use 'rand' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'rand_r' called. It is recommended to use 'rand'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>readdirCalled</key>
    <name>Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'readdir' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'readdir_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>rindexCalled</key>
    <name>Obsolescent function 'rindex' called. It is recommended to use 'strrchr' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'rindex' called. It is recommended to use
'strrchr' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>scalbCalled</key>
    <name>Obsolescent function 'scalb' called. It is recommended to use 'scalbln', 'scalblnf', 'scalbln', 'scalbn', 'scalbnf' or 'scalbnl' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'scalb' called. It is recommended to use
'scalbln', 'scalblnf', 'scalbln', 'scalbn', 'scalbnf' or 'scalbnl'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>sgetspentCalled</key>
    <name>Non reentrant function 'sgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'sgetspent_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'sgetspent' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'sgetspent_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>sizeofFunctionCall</key>
    <name>Found function call inside sizeof()</name>
    <description>
      <![CDATA[
<p>
Found function call inside sizeof().
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>std::asctimeCalled</key>
    <name>Obsolete function 'std::asctime' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'std::asctime' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>std::strtokCalled</key>
    <name>Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'strtok' called. For threadsafe applications it
is recommended to use the reentrant replacement function 'strtok_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>strlwrCalled</key>
    <name>Obsolete function 'strlwr' called. It is recommended to use '_strlwr' or '_strlwr_s' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'strlwr' called. It is recommended to use '_strlwr'
or '_strlwr_s' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>struprCalled</key>
    <name>Obsolete function 'strupr' called. It is recommended to use '_strupr' or '_strupr_s' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'strupr' called. It is recommended to use '_strupr'
or '_strupr_s' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>swapcontextCalled</key>
    <name>Obsolescent function 'swapcontext' called. Applications are recommended to be rewritten to use POSIX threads</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'swapcontext' called. Applications are
recommended to be rewritten to use POSIX threads.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>tempnamCalled</key>
    <name>Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'tempnam' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'tempnam_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>tmpnam_rCalled</key>
    <name>Obsolescent function 'tmpnam_r' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'tmpnam_r' called. It is recommended to use
'tmpfile', 'mkstemp' or 'mkdtemp' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>ttynameCalled</key>
    <name>Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'ttyname' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'ttyname_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>ualarmCalled</key>
    <name>Obsolescent function 'ualarm' called. It is recommended to use 'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or 'timer_settime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'ualarm' called. It is recommended to use
'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime' or
'timer_settime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>usleepCalled</key>
    <name>Obsolescent function 'usleep' called. It is recommended to use 'nanosleep' or 'setitimer' instead</name>
    <description>
      <![CDATA[
<p>
The obsolescent function 'usleep' is called. POSIX.1-2001 declares
usleep() function obsolescent and POSIX.1-2008 removes it. It is
recommended that new applications use the 'nanosleep' or 'setitimer'
function.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>utimeCalled</key>
    <name>Obsolescent function 'utime' called. It is recommended to use 'utimensat' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'utime' called. It is recommended to use
'utimensat' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>vforkCalled</key>
    <name>Obsolescent function 'vfork' called. It is recommended to use 'fork' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'vfork' called. It is recommended to use 'fork'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wcswcsCalled</key>
    <name>Obsolescent function 'wcswcs' called. It is recommended to use 'wcsstr' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'wcswcs' called. It is recommended to use
'wcsstr' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxApp::MacOpenFileCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'wxApp::MacOpenFiles' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'wxApp::MacOpenFiles' method instead in
any new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxArtProvider::InsertCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'PushBack' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'PushBack' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxCalendarCtrl::EnableYearChangeCalled</key>
    <name>This function should be used instead of changing 'wxCAL_NO_YEAR_CHANGE' style bit directly. It allows or disallows the user to change the year interactively. Only in generic 'wxCalendarCtrl'</name>
    <description>
      <![CDATA[
<p>
This function should be used instead of changing
'wxCAL_NO_YEAR_CHANGE' style bit directly. It allows or disallows the
user to change the year interactively. Only in generic
'wxCalendarCtrl'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxComboCtrl::GetTextIndentCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'GetMargins()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'GetMargins()' method instead in any
new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxComboCtrl::HidePopupCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'Dismiss()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'Dismiss()' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxComboCtrl::SetTextIndentCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'SetMargins()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'SetMargins()' method instead in any
new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxComboCtrl::ShowPopupCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'Popup()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override 'Popup()' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxDataViewCustomRenderer::ActivateCalled</key>
    <name>This function is deprecated and kept mostly for backwards compatibility. Please override 'wxDataViewCustomRenderer::ActivateCell()' method instead in any new code</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and kept mostly for backwards
compatibility. Please override
'wxDataViewCustomRenderer::ActivateCell()' method instead in any new
code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxDebugContext::GetLevelCalled</key>
    <name>This function is deprecated and is replaced by 'wxLog' functionality</name>
    <description>
      <![CDATA[
<p>
This function is deprecated and is replaced by 'wxLog' functionality.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxDos2UnixFilenameCalled</key>
    <name>This function is deprecated. Construct a 'wxFileName' with 'wxPATH_DOS' and then use 'wxFileName::GetFullPath(wxPATH_UNIX)' instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. Construct a 'wxFileName' with
'wxPATH_DOS' and then use 'wxFileName::GetFullPath(wxPATH_UNIX)'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxFileNameFromPathCalled</key>
    <name>This function is deprecated. Please use 'wxFileName::SplitPath()' instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. Please use 'wxFileName::SplitPath()'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxGetWorkingDirectoryCalled</key>
    <name>Obsolete function 'wxGetWorkingDirectory' called. It is recommended to use 'wxGetCwd' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'wxGetWorkingDirectory' called. It is recommended to
use 'wxGetCwd' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxGrid::SetCellAlignmentCalled</key>
    <name>This function is deprecated. Please use 'wxGrid::SetCellAlignment(row, col, horiz, vert)' instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. Please use 'wxGrid::SetCellAlignment(row,
col, horiz, vert)' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxSizerItem::SetSizerCalled</key>
    <name>This function is deprecated. This function does not free the old sizer which may result in memory leaks, use 'wxSizerItem::AssignSizer' which does free it instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. This function does not free the old sizer
which may result in memory leaks, use 'wxSizerItem::AssignSizer' which
does free it instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxSizerItem::SetSpacerCalled</key>
    <name>This function is deprecated. This function does not free the old sizer which may result in memory leaks, use 'wxSizerItem::AssignSpacer' which does free it instead</name>
    <description>
      <![CDATA[
<p>
This function is deprecated. This function does not free the old sizer
which may result in memory leaks, use 'wxSizerItem::AssignSpacer'
which does free it instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxSizerItem::SetWindowCalled</key>
    <name>This function is deprecated</name>
    <description>
      <![CDATA[
<p>
This function is deprecated.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxString::IsNullCalled</key>
    <name>This is the same as 'wxString::IsEmpty' and is kept for wxWidgets 1.xx compatibility. You should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as 'wxString::IsEmpty' and is kept for wxWidgets 1.xx
compatibility. You should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxString::LengthCalled</key>
    <name>This is the same as 'wxString::Len' and is kept for wxWidgets 1.xx compatibility. You should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as 'wxString::Len' and is kept for wxWidgets 1.xx
compatibility. You should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxString::LowerCaseCalled</key>
    <name>This is the same as 'wxString::MakeLower' and is kept for wxWidgets 1.xx compatibility. You should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as 'wxString::MakeLower' and is kept for wxWidgets
1.xx compatibility. You should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>asctimeCalled</key>
    <name>Obsolete function 'asctime' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'asctime' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>gethostbynameCalled</key>
    <name>Obsolescent function 'gethostbyname' called. It is recommended to use 'getaddrinfo' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'gethostbyname' called. It is recommended to use
'getaddrinfo' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>localtimeCalled</key>
    <name>Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'</name>
    <description>
      <![CDATA[
<p>
Non reentrant function 'localtime' called. For threadsafe applications
it is recommended to use the reentrant replacement function
'localtime_r'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>strtokCalled</key>
    <name>Non reentrant function 'strtok' called</name>
    <description>
      <![CDATA[<p>
Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'.
</p><h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Functions</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>tmpnamCalled</key>
    <name>Obsolescent function 'tmpnam' called. It is recommended to use 'tmpfile', 'mkstemp' or 'mkdtemp' instead</name>
    <description>
      <![CDATA[
<p>
Obsolescent function 'tmpnam' called. It is recommended to use
'tmpfile', 'mkstemp' or 'mkdtemp' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unhandledExceptionSpecification</key>
    <name>Unhandled exception specification when calling function foo()</name>
    <description>
      <![CDATA[
<p>
Unhandled exception specification when calling function foo(). Either
use a try/catch around the function call, or add a exception
specification for funcname() also.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/703.html" target="_blank">CWE-703: Improper Check or Handling of Exceptional Conditions</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>purgedConfiguration</key>
    <name>The configuration '' was not checked because its code equals another one</name>
    <description>
      <![CDATA[
      The configuration '' was not checked because its code equals another one.
    ]]>
    </description>
    <severity>INFO</severity>
  </rule>
  <rule>
    <key>internalError</key>
    <name>Internal Cppcheck tool error</name>
    <description>
      <![CDATA[<p>
Internal Cppcheck tool error. Create an issue on the Cppcheck issue tracker.
</p><h2>References</h2>
<p><a href="http://trac.cppcheck.net/" target="_blank">Cppcheck development</a></p>
]]>
    </description>
    <severity>INFO</severity>
  </rule>
  <rule>
    <key>QString::vsprintfCalled</key>
    <name>Obsolete function 'QString::vsprintf' called. It is recommended to use 'QString::vasprintf', 'QString::arg' or 'QTextStream' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'QString::vsprintf' called. It is recommended to use
'QString::vasprintf', 'QString::arg' or 'QTextStream' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>asctime_sCalled</key>
    <name>Obsolete function 'asctime_s' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'asctime_s' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>duplicateValueTernary</key>
    <name>Same value in both branches of ternary operator</name>
    <description>
      <![CDATA[
<p>
Finding the same value in both branches of ternary operator is
suspicious as the same code is executed regardless of the condition.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>identicalInnerCondition</key>
    <name>Identical inner 'if' condition is always true</name>
    <description>
      <![CDATA[
<p>
Identical inner 'if' condition is always true (outer condition is 'x'
and inner condition is 'x').
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>missingOverride</key>
    <name>The function '' overrides a function in a base class but is not marked with a 'override' specifier</name>
    <description>
      <![CDATA[
      The function '' overrides a function in a base class but is not marked with a 'override' specifier.
    ]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>noDestructor</key>
    <name>Class 'class' does not have a destructor which is recommended since it has dynamic memory/resource allocation(s)</name>
    <description>
      <![CDATA[
<p>
Class 'class' does not have a destructor which is recommended since it
has dynamic memory/resource allocation(s).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>noOperatorEq</key>
    <name>Class 'class' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s)</name>
    <description>
      <![CDATA[
<p>
Class 'class' does not have a operator= which is recommended since it
has dynamic memory/resource allocation(s).
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>oppositeExpression</key>
    <name>Opposite expression on both sides of '&amp;&amp;'</name>
    <description>
      <![CDATA[
<p>
Finding the opposite expression on both sides of an operator is
suspicious and might indicate a cut and paste or logic error. Please
examine this code carefully to determine if it is correct.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>pureVirtualCall</key>
    <name>Call of pure virtual function 'f' in constructor</name>
    <description>
      <![CDATA[
      Call of pure virtual function 'f' in constructor. The call will fail during runtime.
    ]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>qInstallMsgHandlerCalled</key>
    <name>Obsolete function 'qInstallMsgHandler' called. It is recommended to use 'qInstallMessageHandler' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'qInstallMsgHandler' called. It is recommended to
use 'qInstallMessageHandler' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>qrandCalled</key>
    <name>Obsolete function 'qrand' called. It is recommended to use 'QRandomGenerator' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'qrand' called. It is recommended to use
'QRandomGenerator' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>qsrandCalled</key>
    <name>Obsolete function 'qsrand' called. It is recommended to use 'QRandomGenerator' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'qsrand' called. It is recommended to use
'QRandomGenerator' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>std::asctime_sCalled</key>
    <name>Obsolete function 'std::asctime_s' called. It is recommended to use 'strftime' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'std::asctime_s' called. It is recommended to use
'strftime' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>umaskCalled</key>
    <name>Obsolete function 'umask' called. It is recommended to use '_umask' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'umask' called. It is recommended to use '_umask'
instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
    ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>virtualCallInConstructor</key>
    <name>Virtual function 'f' is called from constructor '' at line 1. Dynamic binding is not used</name>
    <description>
      <![CDATA[
      Virtual function 'f' is called from constructor '' at line 1. Dynamic binding is not used.
    ]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>QString::sprintfCalled</key>
    <name>Obsolete function 'QString::sprintf' called. It is recommended to use 'QString::asprintf', 'QString::arg' or 'QTextStream' instead</name>
    <description>
      <![CDATA[
<p>
Obsolete function 'QString::sprintf' called. It is recommended to use
'QString::asprintf', 'QString::arg' or 'QTextStream' instead.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>containerOutOfBounds</key>
    <name>Out of bounds access in expression 'container[x]'</name>
    <description>
      <![CDATA[
<p>
Out of bounds access in expression 'container[x]'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>incorrectCharBooleanError</key>
    <name>Conversion of char literal 'x' to bool always evaluates to true</name>
    <description>
      <![CDATA[
<p>
Conversion of char literal 'x' to bool always evaluates to true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>mismatchingContainerExpression</key>
    <name>Iterators to containers from different expressions 'v1' and 'v2' are used together</name>
    <description>
      <![CDATA[
<p>
Iterators to containers from different expressions 'v1' and 'v2' are
used together.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>sameIteratorExpression</key>
    <name>Same iterators expression are used for algorithm</name>
    <description>
      <![CDATA[
<p>
Same iterators expression are used for algorithm.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>useStlAlgorithm</key>
    <name>Consider using  algorithm instead of a raw loop</name>
    <description>
      <![CDATA[
<p>
Consider using  algorithm instead of a raw loop.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>wxString::StripCalled</key>
    <name>This is the same as wxString::Trim() except that it doesn't change this string. This is a wxWidgets 1.xx compatibility function; you should not use it in new code</name>
    <description>
      <![CDATA[
<p>
This is the same as wxString::Trim() except that it doesn't change
this string. This is a wxWidgets 1.xx compatibility function; you
should not use it in new code.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>danglingLifetime</key>
    <name>Non-local variable 'x' will use object</name>
    <description>
      <![CDATA[
<p>
Non-local variable 'x' will use object.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>duplicateAssignExpression</key>
    <name>Same expression used in consecutive assignments of 'x' and 'x'</name>
    <description>
      <![CDATA[
<p>
Finding variables 'x' and 'x' that are assigned the same expression is
suspicious and might indicate a cut and paste or logic error. Please
examine this code carefully to determine if it is correct.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>invalidFunctionArgStr</key>
    <name>Invalid func_name() argument nr 1. A nul-terminated string is required</name>
    <description>
      <![CDATA[
<p>
Invalid func_name() argument nr 1. A nul-terminated string is
required.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/628.html" target="_blank">CWE-628: Function Call with Incorrectly Specified Arguments</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidLifetime</key>
    <name>Using object that is out of scope</name>
    <description>
      <![CDATA[
<p>
Using object that is out of scope.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>iterators1</key>
    <name>Same iterator is used with different containers 'container1' and 'container2'</name>
    <description>
      <![CDATA[
<p>
Same iterator is used with different containers 'container1' and
'container2'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>iterators3</key>
    <name>Same iterator is used with containers 'container' that are temporaries or defined in different scopes</name>
    <description>
      <![CDATA[
<p>
Same iterator is used with containers 'container' that are temporaries
or defined in different scopes.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>iteratorsCmp1</key>
    <name>Comparison of iterators from different containers</name>
    <description>
      <![CDATA[
<p>
Comparison of iterators from containers 'container1' and 'container2'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>iteratorsCmp2</key>
    <name>Comparison of iterators from containers 'container' that are defined in different scopes</name>
    <description>
      <![CDATA[
<p>
Comparison of iterators from containers 'container' that are defined
in different scopes.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnDanglingLifetime</key>
    <name>Returning object that will be invalid when returning</name>
    <description>
      <![CDATA[
<p>
Returning object that will be invalid when returning.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>returnNonBoolInBooleanFunction</key>
    <name>Non-boolean value returned from function returning bool</name>
    <description>
      <![CDATA[
Non-boolean value returned from function returning bool
]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>shadowFunction</key>
    <name>Local variable 'function' shadows outer function</name>
    <description>
      <![CDATA[
<p>
Local variable 'function' shadows outer function
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>shadowVar</key>
    <name>Local variable shadows outer variable</name>
    <description>
      <![CDATA[
<p>
Local variable shadows outer variable
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>constArgument</key>
    <name>Const argument</name>
    <description>
      <![CDATA[
<p>
Argument 'x' to function f is always 0
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>danglingReference</key>
    <name>Non-local reference variable 'x' to local variable 'y'</name>
    <description>
      <![CDATA[
<p>
Non-local reference variable 'x' to local variable 'y'
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>duplicateCondition</key>
    <name>The if condition is the same as the previous if condition</name>
    <description>
      <![CDATA[
<p>
The if condition is the same as the previous if condition
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>invalidScanfFormatWidth_smaller</key>
    <name>Width -1 given in format string (no. 99) is smaller than destination buffer '[0]'</name>
    <description>
      <![CDATA[
      Width -1 given in format string (no. 99) is smaller than destination buffer '[0]'.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>iterators2</key>
    <name>Same iterator is used with different containers 'container0' and 'container1'</name>
    <description>
      <![CDATA[
<p>
Same iterator is used with different containers 'container0' and
'container1'.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>nullPointerArithmeticRedundantCheck</key>
    <name>Either the condition is redundant or there is pointer arithmetic with NULL pointer</name>
    <description>
      <![CDATA[
<p>
Either the condition is redundant or there is pointer arithmetic with
NULL pointer.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/682.html" target="_blank">CWE-682: Incorrect Calculation</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>wxBitmap::SetDepthCalled</key>
    <name>This function is deprecated since version 3.1.2, dimensions and depth can only be set at construction time</name>
    <description>
      <![CDATA[
<p>
This function is deprecated since version 3.1.2, dimensions and depth
can only be set at construction time.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/477.html" target="_blank">CWE-477: Use of Obsolete Function</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>comparePointers</key>
    <name>Comparing pointers that point to different objects</name>
    <description>
      <![CDATA[
<p>
Comparing pointers that point to different objects
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/570.html" target="_blank">CWE-570: Expression is Always False</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>duplicateConditionalAssign</key>
    <name>Duplicate expression for the condition and assignment</name>
    <description>
      <![CDATA[
<p>
Duplicate expression for the condition and assignment.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>negativeContainerIndex</key>
    <name>Array index -1 is out of bounds</name>
    <description>
      <![CDATA[
<p>
Array index -1 is out of bounds.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/786.html" target="_blank">CWE-786: Access of Memory Location Before Start of Buffer</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>objectIndex</key>
    <name>The address of local variable '' is accessed at non-zero index</name>
    <description>
      <![CDATA[
<p>
The address of local variable '' is accessed at non-zero index.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>stlFindInsert</key>
    <name>Searching before insertion is not necessary</name>
    <description>
      <![CDATA[
<p>
Searching before insertion is not necessary.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitMemberVarPrivate</key>
    <name>Member variable 'classname::varnamepriv' is not initialized in the constructor</name>
    <description>
      <![CDATA[
<p>
Member variable 'classname::varnamepriv' is not initialized in the
constructor.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 1.9.0 ########### -->
  <rule>
    <key>constVariable</key>
    <name>Variable 'x' can be declared with const</name>
    <description>
      <![CDATA[
<p>
Variable 'x' can be declared with const
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>constParameter</key>
    <name>Parameter 'x' can be declared with const</name>
    <description>
      <![CDATA[
<p>
Parameter 'x' can be declared with const
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>danglingTemporaryLifetime</key>
    <name>Using object that is a temporary</name>
    <description>
      <![CDATA[
<p>
Using object that is a temporary.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>invalidContainer</key>
    <name>Using object that may be invalid</name>
    <description>
      <![CDATA[
<p>
Using object that may be invalid.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>redundantInitialization</key>
    <name>Redundant initialization for 'var'. The initialized value is overwritten before it is read</name>
    <description>
      <![CDATA[
<p>
Redundant initialization for 'var'. The initialized value is
overwritten before it is read.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/563.html" target="_blank">CWE-563: Assignment to Variable without Use</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>shadowArgument</key>
    <name>Local variable 'argument' shadows outer argument</name>
    <description>
      <![CDATA[
<p>
Local variable 'argument' shadows outer argument
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>shadowVariable</key>
    <name>Local variable 'variable' shadows outer variable</name>
    <description>
      <![CDATA[
<p>
Local variable 'variable' shadows outer variable
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unsafeClassRefMember</key>
    <name>Unsafe class: The const reference member 'UnsafeClass::var' is initialized by a const reference constructor argument. You need to be careful about lifetime issues</name>
    <description>
      <![CDATA[
Unsafe class checking: The const reference member 'UnsafeClass::var' is initialized by a const reference constructor argument. You need to be careful about lifetime issues. If you pass a local variable or temporary value in this constructor argument, be extra careful. If the argument is always some global object that is never destroyed then this is safe usage. However it would be defensive to make the member 'UnsafeClass::var' a non-reference variable or a smart pointer.
]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 2.1.0 ########### -->
  <rule>
    <key>invalidContainerLoop</key>
    <name>Calling 'erase' while iterating the container is invalid</name>
    <description>
      <![CDATA[
      <p>
Calling 'erase' while iterating the container is invalid.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
      ]]>
      <![CDATA[]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>knownArgument</key>
    <name>Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has</name>
    <description>
      <![CDATA[
      Argument 'x-x' to function 'func' is always 0. It does not matter what value 'x' has.
]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>mismatchingContainerIterator</key>
    <name>Iterator 'it' from different container 'v1' are used together</name>
    <description>
      <![CDATA[
      <p>
Iterator 'it' from different container 'v1' are used together.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
      ]]>
      <![CDATA[]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>moduloofone</key>
    <name>Modulo of one is always equal to zero</name>
    <description>
      <![CDATA[
      Modulo of one is always equal to zero
      ]]>
      <![CDATA[]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>thisUseAfterFree</key>
    <name>Using member 'x' when 'this' might be invalid</name>
    <description>
      <![CDATA[
      Using member 'x' when 'this' might be invalid
      ]]>
      <![CDATA[]]>
    </description>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 2.4.1 ########### -->
  <rule>
    <key>danglingTempReference</key>
    <name>Using reference to dangling temporary</name>
    <description>
      <![CDATA[
      <p>
Using reference to dangling temporary.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/562.html" target="_blank">CWE-562: Return of Stack Variable Address</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <rule>
    <key>globalLockGuard</key>
    <name>Lock guard is defined globally. Lock guards are intended to be local. A global lock guard could lead to a deadlock since it won't unlock until the end of the program</name>
    <description>
      <![CDATA[
      <p>
Lock guard is defined globally. Lock guards are intended to be local.
A global lock guard could lead to a deadlock since it won't unlock
until the end of the program.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/833.html" target="_blank">CWE-833: Deadlock</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>knownArgumentHiddenVariableExpression</key>
    <name>Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'</name>
    <description>
      <![CDATA[
      Argument 'x*0' to function 'func' is always 0. Constant literal calculation disable/hide variable expression 'x'.
      ]]>
    </description>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>knownEmptyContainer</key>
    <name>Iterating over container 'var' that is always empty</name>
    <description>
      <![CDATA[
      <p>
Iterating over container 'var' that is always empty.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>localMutex</key>
    <name>The lock is ineffective because the mutex is locked at the same scope as the mutex itself</name>
    <description>
      <![CDATA[
      <p>
The lock is ineffective because the mutex is locked at the same scope
as the mutex itself.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/667.html" target="_blank">CWE-667: Improper Locking</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitDerivedMemberVar</key>
    <name>Member variable 'classname::varname' is not initialized in the constructor. Maybe it should be initialized directly in the class classname?</name>
    <description>
      <![CDATA[
      <p>
Member variable 'classname::varname' is not initialized in the
constructor. Maybe it should be initialized directly in the class
classname?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>uninitDerivedMemberVarPrivate</key>
    <name>Member variable 'classname::varnamepriv' is not initialized in the constructor. Maybe it should be initialized directly in the class classname?</name>
    <description>
      <![CDATA[
      <p>
Member variable 'classname::varnamepriv' is not initialized in the
constructor. Maybe it should be initialized directly in the class
classname?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <rule>
    <key>unusedLabelConfiguration</key>
    <name>Label '' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor</name>
    <description>
      <![CDATA[
      <p>
Label '' is not used. There is #if in function body so the label might
be used in code that is removed by the preprocessor.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>unusedLabelSwitchConfiguration</key>
    <name>Label '' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. Should this be a 'case' of the enclosing switch()?</name>
    <description>
      <![CDATA[
      <p>
Label '' is not used. There is #if in function body so the label might
be used in code that is removed by the preprocessor. Should this be a
'case' of the enclosing switch()?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 2.5.0 ########### -->
  <rule>
    <key>assignmentInCondition</key>
    <name>Suspicious assignment in condition. Condition 'x=y' is always true</name>
    <description><![CDATA[
      <p>
Suspicious assignment in condition. Condition 'x=y' is always true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/571.html" target="_blank">CWE-571: Expression is Always True</a></p>
      ]]></description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
  </rule>
  <rule>
    <key>rethrowNoCurrentException</key>
    <name>Rethrowing current exception with 'throw;', it seems there is no current exception to rethrow</name>
    <description><![CDATA[
      <p>
Rethrowing current exception with 'throw;', it seems there is no
current exception to rethrow. If there is no current exception this
calls std::terminate(). More:
https://isocpp.org/wiki/faq/exceptions#throw-without-an-object
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/480.html" target="_blank">CWE-480: Use of Incorrect Operator</a></p>
      ]]></description>
    <tag>cwe</tag>
    <type>BUG</type>
  </rule>
  <!-- ########### New in Cppcheck 2.6.0 ########### -->
  <rule>
    <key>compareValueOutOfTypeRangeError</key>
    <name>Comparing expression of type 'unsigned char' against value 256</name>
    <description>
      <![CDATA[
      <p>
Comparing expression of type 'unsigned char' against value 256.
Condition is always true.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]>
      <![CDATA[]]>
      </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    </rule>
  <rule>
    <key>incompatibleFileOpen</key>
    <name>The file 'tmp' is opened for read and write access at the same time on different streams</name>
    <description>
      <![CDATA[
      <p>
The file 'tmp' is opened for read and write access at the same time on
different streams
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/664.html" target="_blank">CWE-664: Improper Control of a Resource Through its Lifetime</a></p>
      ]]>
      <![CDATA[]]>
      </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
    </rule>
  <rule>
    <key>missingReturn</key>
    <name>Found a exit path from function with non-void return type that has missing return statement</name>
    <description>
      <![CDATA[
      <p>
Found a exit path from function with non-void return type that has
missing return statement
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</a></p>
      ]]>
      <![CDATA[]]>
      </description>
    <tag>cwe</tag>
    <type>BUG</type>
    </rule>
  <rule>
    <key>overlappingWriteFunction</key>
    <name>Overlapping read/write in () is undefined behavior</name>
    <description>
      <![CDATA[
      Overlapping read/write in () is undefined behavior
      ]]>
      <![CDATA[]]>
      </description>
    <type>BUG</type>
    </rule>
  <rule>
    <key>overlappingWriteUnion</key>
    <name>Overlapping read/write of union is undefined behavior</name>
    <description>
      <![CDATA[
      Overlapping read/write of union is undefined behavior
      ]]>
      <![CDATA[]]>
      </description>
    <type>BUG</type>
    </rule>
  <rule>
    <key>returnStdMoveLocal</key>
    <name>Using std::move for returning object by-value from function will affect copy elision optimization</name>
    <description>
      <![CDATA[
      Using std::move for returning object by-value from function will affect copy elision optimization. More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local
      ]]>
      <![CDATA[]]>
      </description>
    <severity>MINOR</severity>
    <type>BUG</type>
    </rule>
  <!-- ########### New in Cppcheck 2.7.0 ########### -->
  <rule>
    <key>missingMemberCopy</key>
    <name>Member variable 'classname::varnamepriv' is not assigned in the copy constructor</name>
    <description><![CDATA[
      <p>
Member variable 'classname::varnamepriv' is not assigned in the move
constructor. Should it be moved?
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/398.html" target="_blank">CWE-398: 7PK - Code Quality</a></p>
      ]]></description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
    </rule>
  <!-- ########### New in Cppcheck 2.9.0 ########### -->
  <rule>
    <key>constParameterCallback</key>
    <name>Parameter 'x' can be declared with const, however it seems that 'f' is a callback function</name>
    <description><![CDATA[
      Parameter 'x' can be declared with const, however it seems that 'f' is a callback function.
      ]]></description>
    <severity>MINOR</severity>
    </rule>
  <!-- ########### New in Cppcheck 2.13.0 ########### -->
  <rule>
    <key>constParameterPointer</key>
    <name>Parameter 'x' can be declared with const</name>
    <description>
      <![CDATA[
      Parameter 'x' can be declared with const
      ]]>
    </description>
    <severity>MINOR</severity>
    </rule>
  <rule>
    <key>constParameterReference</key>
    <name>Parameter 'x' can be declared with const</name>
    <description>
      <![CDATA[
      Parameter 'x' can be declared with const
      ]]>
    </description>
    <severity>MINOR</severity>
    </rule>
  <rule>
    <key>constVariablePointer</key>
    <name>Variable 'x' can be declared with const</name>
    <description>
      <![CDATA[
      Variable 'x' can be declared with const
      ]]>
    </description>
    <severity>MINOR</severity>
    </rule>
  <rule>
    <key>constVariableReference</key>
    <name>Variable 'x' can be declared with const</name>
    <description>
      <![CDATA[
      Variable 'x' can be declared with const
      ]]>
    </description>
    <severity>MINOR</severity>
    </rule>
  <rule>
    <key>knownPointerToBool</key>
    <name>Pointer expression 'p' converted to bool is always true</name>
    <description>
      <![CDATA[
      Pointer expression 'p' converted to bool is always true.
      ]]>
    </description>
    <severity>MINOR</severity>
    </rule>
  <rule>
    <key>pointerOutOfBoundsCond</key>
    <name>Pointer arithmetic overflow</name>
    <description>
      <![CDATA[
      <p>
Pointer arithmetic overflow.
</p>
<h2>References</h2>
<p><a href="https://cwe.mitre.org/data/definitions/758.html" target="_blank">CWE-758</a></p>
      ]]>
    </description>
    <tag>cwe</tag>
    <severity>MINOR</severity>
    <type>BUG</type>
    </rule>
  <rule>
    <key>useStandardLibrary</key>
    <name>Consider using memcpy instead of loop</name>
    <description>
      <![CDATA[
      Consider using memcpy instead of loop.
      ]]>
    </description>
    <severity>MINOR</severity>
    </rule>
  <!-- ########### Internal Cppcheck errors (not in errorlist) ########### -->
  <rule>
    <key>internalAstError</key>
    <name>Internal Error: AST</name>
    <description>
      Syntax Error: AST broken or maximum AST depth exceeded.
    </description>
    <internalKey>internalAstError</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
   <rule>
    <key>syntaxError</key>
    <name>Internal Error: Syntax error</name>
    <description>
      Cppcheck cannot tokenize the code correctly: unsupported syntax or invalid code.
    </description>
    <internalKey>syntaxError</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
   <rule>
    <key>"unknownMacro</key>
    <name>Internal Error: Unkown macro</name>
    <description>
      There is an unknown macro here somewhere. Configuration is required. If 'token' is a macro then please configure it.
    </description>
    <internalKey>"unknownMacro</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
  <rule>
    <key>cppcheckError</key>
    <name>Internal Error</name>
    <description>
      Analysis failed. If the code is valid then please report this failure.
    </description>
    <internalKey>cppcheckError</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
  <rule>
    <key>cppcheckLimit</key>
    <name>Internal Error: Internal limit</name>
    <description>
      Internal limit: CheckLeakAutoVar::checkScope() Maximum recursive count of 1000 reached.
    </description>
    <internalKey>cppcheckLimit</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
  <rule>
    <key>instantiationError</key>
    <name>Internal Error: Instantiation error</name>
    <description>
      Instantiation error: Divide by zero in template instantiation.
    </description>
    <internalKey>instantiationError</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
  <rule>
    <key>unmatchedSuppression</key>
    <name>Internal Error: Unmatched suppression</name>
    <description>
      Unmatched suppression: unusedFunction.
    </description>
    <internalKey>unmatchedSuppression</internalKey>
    <severity>INFO</severity>
    <type>BUG</type>
    </rule>
  <!-- ########### Misra Rules ########### -->
  <rule>
    <key>misra-c2012-1.1</key>
    <name>misra-c2012-1.1: Violations of the standard C (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Violations of the standard C syntax and constraints]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-1.2</key>
    <name>misra-c2012-1.2: Language extensions (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) Language extensions should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-1.3</key>
    <name>misra-c2012-1.3: Unspecified behaviour (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) There shall be no occurrence of undefined or critical unspecified behaviour]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-2.1</key>
    <name>misra-c2012-2.1: Unreachable code (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A project shall not contain unreachable code]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-2.2</key>
    <name>misra-c2012-2.2: Dead code (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) There shall be no dead code]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-2.3</key>
    <name>misra-c2012-2.3: Unused type declarations (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A project should not contain unused ty pe declarations]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-2.4</key>
    <name>misra-c2012-2.4: Unused tag declarations (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A project should not contain unused tag declarations ]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-2.5</key>
    <name>misra-c2012-2.5: Unused macro declarations (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A project should not contain unused macro declarations]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-2.6</key>
    <name>misra-c2012-2.6: Unused label declarations (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A function should not contain unused label declarations]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-2.7</key>
    <name>misra-c2012-2.7: Unused parameters in functions (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) There should be no unused parameters in functions]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-3.1</key>
    <name>misra-c2012-3.1: /* or // used within a comment (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The character sequences /* an d // shall not be used within a comment]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-3.2</key>
    <name>misra-c2012-3.2: Line-splicing in // comment (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Line-splicing shall not be used in // comments]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-4.1</key>
    <name>misra-c2012-4.1: Escape sequences not terminated (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Octal and hexadecimal escape sequences shall be terminated]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-4.2</key>
    <name>misra-c2012-4.2: Trigraphs (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) Trigraphs should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-5.1</key>
    <name>misra-c2012-5.1: Indistinct external identifiers (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) External identifiers shall be distinct]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.2</key>
    <name>misra-c2012-5.2: Indistinct identifiers in same scope (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Identifiers declared in the same scope and name space shall be distinct]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.3</key>
    <name>misra-c2012-5.3: Identifier hiding other identifier (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) An identifier declared in an inner scope shall not hide an identifier declared in an outer scope]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.4</key>
    <name>misra-c2012-5.4: Indistinct macro identifier (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Macro identifiers shall be distinct]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.5</key>
    <name>misra-c2012-5.5: Identifiers indistinct from macro names (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Identifiers shall be distinct from macro names]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.6</key>
    <name>misra-c2012-5.6: A typedef identifier not unique (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A typedef name shall be a unique identifier]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.7</key>
    <name>misra-c2012-5.7: Tag name identifier not unique (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A tag name shall be a unique identifier]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.8</key>
    <name>misra-c2012-5.8: Identifiers with external linkage not unique (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Identifiers that define objects or functions with external linkage shall be unique]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-5.9</key>
    <name>misra-c2012-5.9: Identifiers with internal linkage not unique (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Identifiers that define objects or functions with internal linkage should be unique]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-6.1</key>
    <name>misra-c2012-6.1: Bit-fields have not appropriate type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Bit-fields shall only be declared with an appropriate type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-6.2</key>
    <name>misra-c2012-6.2: Single-bit is signed type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) Single-bit named bit fields shall not be of a signed type]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-7.1</key>
    <name>misra-c2012-7.1: Octal constants (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Octal constants shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-7.2</key>
    <name>misra-c2012-7.2: Unsigned constant integer required a 'U' or 'u' (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A “u” or “U” suffix shall be applied to all integer constants that are represented in an unsigned type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-7.3</key>
    <name>misra-c2012-7.3: 'l' used in a literal suffix (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The lowercase character “l” shall not be used in a literal suffix ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-7.4</key>
    <name>misra-c2012-7.4: String literal assigned to wrong object (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A string literal shall not be assigned to an object unless the object’s type is “pointer to const-qualifi ed char” ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.1</key>
    <name>misra-c2012-8.1: Types not explicitly specified (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Types shall be explicitly specified]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.2</key>
    <name>misra-c2012-8.2: Function prototype missing or incomplete (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Function types shall be in prototype form with named parameters]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.3</key>
    <name>misra-c2012-8.3: Different declaration of object function (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required)  All declarations of an object or function shall use the same names and type qualifiers]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.4</key>
    <name>misra-c2012-8.4: Non compatible declaration with external linkage (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A compatible declaration shall be visible when an object or function with external linkage is defined]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.5</key>
    <name>misra-c2012-8.5: An external element declared in several files (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) An external object or function shall be declared once in one and only one file]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.6</key>
    <name>misra-c2012-8.6: Symbol is redeclared or redefined (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) An identifier with external linkage shall have exactly one external definition]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.7</key>
    <name>misra-c2012-8.7: Functions or objects defined with external linkage and is referenced in only one translation unit (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) Functions and objects should not be defined with external linkage if they are referenced in only one translation unit]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-8.8</key>
    <name>misra-c2012-8.8: Storage class of symbol assumed static (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.9</key>
    <name>misra-c2012-8.9: Object define outside of block for single function usage (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) An object should be defined at block scope if its identifier only appears in a single function]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-8.10</key>
    <name>misra-c2012-8.10: Inline function defined without a storage-class specifier (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) An inline function shall be declared with the static storage class]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.11</key>
    <name>misra-c2012-8.11: Externale array without explicit size (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) When an array with external linkage is declared, its size should be explicitly specified]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-8.12</key>
    <name>misra-c2012-8.12: Element of enum whithout unique value (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-8.13</key>
    <name>misra-c2012-8.13: Pointer parameter could be declared as pointing to const (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A pointer should point to a const-qualified type whenever possible]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-8.14</key>
    <name>misra-c2012-8.14: Restrict type used (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The restrict type qualifier shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-9.1</key>
    <name>misra-c2012-9.1: Symbol read before been set (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) The value of an object with automatic storage duration shall not be read before it has been set]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-9.2</key>
    <name>misra-c2012-9.2: Not initialized in braces (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The initializer for an aggregate or union shall be enclosed in braces]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-9.3</key>
    <name>misra-c2012-9.3: Init of array not complete (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Arrays shall not be partially initialized]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-9.4</key>
    <name>misra-c2012-9.4: Element initialized more than once (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) An element of an object shall not be initialized more than once]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-9.5</key>
    <name>misra-c2012-9.5: Size of the array not specified explicitly (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.1</key>
    <name>misra-c2012-10.1: Inapropriate essential type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Operands shall not be of an inappropriate essential type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.2</key>
    <name>misra-c2012-10.2: Inapropriate ussage of character type in operation (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.3</key>
    <name>misra-c2012-10.3: Assignation of a narrower essential type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.4</key>
    <name>misra-c2012-10.4: Operation with different type category (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.5</key>
    <name>misra-c2012-10.5: Cast to an inappropriate type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The value of an expression should not be cast to an inappropriate essential type]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-10.6</key>
    <name>misra-c2012-10.6: Assignation to object with wider essential type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The value of a composite expression shall not be assigned to an object with wider essential type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.7</key>
    <name>misra-c2012-10.7: Implicit conversion in arithmetic conversion (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-10.8</key>
    <name>misra-c2012-10.8: Type conversion of composit expression (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The value of a composite expression shall not be cast to a different essential type category or a wider essential type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.1</key>
    <name>misra-c2012-11.1: Convertion between pointer to function and other type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Conversions shall not be performed between a pointer to a function and any other type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.2</key>
    <name>misra-c2012-11.2: Conversion between incomplete pointer type and other type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Conversions shall not be performed between a pointer to an incomplete type and any other type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.3</key>
    <name>misra-c2012-11.3: Cast between 2 pointers with different type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A cast shall not be performed between a pointer to object type and a pointer to a different object type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.4</key>
    <name>misra-c2012-11.4: Conversion between pointer to object and pointer to integer (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A conversion should not be performed between a pointer to object and an integer type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.5</key>
    <name>misra-c2012-11.5: Conversion between pointer to void and pointer to object (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A conversion should not be performed from pointer to void into pointer to object ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.6</key>
    <name>misra-c2012-11.6: Conversion between pointer to void and arithmetic type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A cast shall not be performed between pointer to void and an arithmetic type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.7</key>
    <name>misra-c2012-11.7: Conversion between pointer to object and non-integer arithmetic type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A cast shall not be performed between pointer to object and a non-integer arithmetic type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.8</key>
    <name>misra-c2012-11.8: Pointer remove qualification to object (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A cast shall not remove any const or volatile qualification from the type pointed to by a pointer]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-11.9</key>
    <name>misra-c2012-11.9: Macro NULL used inappropriately (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The macro NULL shall be the only permitted form of integer null pointer constant]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-12.1</key>
    <name>misra-c2012-12.1: Precedence of expression non explicit (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The precedence of operators within expressions should be made explicit]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-12.2</key>
    <name>misra-c2012-12.2: The shift value is at least the precision of the essential type of the left hand side (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-12.3</key>
    <name>misra-c2012-12.3: Usage of coma operator (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The comma operator should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-12.4</key>
    <name>misra-c2012-12.4: Overflow in computing constant for operation (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) Evaluation of constant expressions should not lead to unsigned integer wrap-around]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-12.5</key>
    <name>misra-c2012-12.5: The parameter of the sizeof call is invalid (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) The sizeof operator shall not have an operand which is a function parameter declared as "array of type"]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-13.1</key>
    <name>misra-c2012-13.1: Initializer list with persistent side effect (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Initializer lists shall not contain persistent side effects ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-13.2</key>
    <name>misra-c2012-13.2: Different value of expression and persistent side effect (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-13.3</key>
    <name>misra-c2012-13.3: Unexpected side effect for (++) or (--) operation (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-13.4</key>
    <name>misra-c2012-13.4: Utilisation of assignment operator result (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The result of an assignment operator should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-13.5</key>
    <name>misra-c2012-13.5: Side effects on right hand of logical operator (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-13.6</key>
    <name>misra-c2012-13.6: Sizeof used on expression with side effect (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) The operand of the sizeof operator shall not contain any expression which has potential side effects]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-14.1</key>
    <name>misra-c2012-14.1: Use of floating type in a loop (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A loop counter shall not have essentially floating type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-14.2</key>
    <name>misra-c2012-14.2: For loop not correct (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A for loop shall be well-formed]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-14.3</key>
    <name>misra-c2012-14.3: Always evaluate to same value (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Controlling expressions shall not be invariant]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-14.4</key>
    <name>misra-c2012-14.4: Usage of non boolean control expression in if statement (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-15.1</key>
    <name>misra-c2012-15.1: Usage of Goto (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The goto statement should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-15.2</key>
    <name>misra-c2012-15.2: Goto jump outside of autorized position (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The goto statement shall jump to a label declared later in the same function ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-15.3</key>
    <name>misra-c2012-15.3: Label declared outside of goto block or enclosing block (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-15.4</key>
    <name>misra-c2012-15.4: More than one goto or break to terminate operation (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) There should be no more than one break or goto statement used to terminate any iteration statement]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-15.5</key>
    <name>misra-c2012-15.5: More than one end point to exit function (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory)  A function should have a single point of exit at the end]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-15.6</key>
    <name>misra-c2012-15.6: Sub-statement should be a compound statement (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The body of an iteration-statement or a selection-statement shall be acompound-statement]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-15.7</key>
    <name>misra-c2012-15.7: Else statment missing (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) All if ... else if constructs shall be terminated with an else statement]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.1</key>
    <name>misra-c2012-16.1: Switch statement not well formed (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) All switch statements shall be well-formed]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.2</key>
    <name>misra-c2012-16.2:  Most closely-enclosing compound statement is not the body of a switch statement (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.3</key>
    <name>misra-c2012-16.3: Break missing to terminate case (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) An unconditional break statement shall terminate every switch-clause]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.4</key>
    <name>misra-c2012-16.4: Default missing in the switch-case (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Every switch statement shall have a default label]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.5</key>
    <name>misra-c2012-16.5: Default not in first or salt label (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A default label shall appear as either the first or the last switch label of a switch statement]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.6</key>
    <name>misra-c2012-16.6: Switch statment does not have enough case (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Every switch statement shall have at least two switch-clauses]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-16.7</key>
    <name>misra-c2012-16.7: Usage of boolean type for switch statment (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A switch-expression shall not have essentially Boolean type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.1</key>
    <name>misra-c2012-17.1: Usage of stdarg.h is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The features of &lt;stdarg.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.2</key>
    <name>misra-c2012-17.2: Function calling itself (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Functions shall not call themselves, either directly or indirectly]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.3</key>
    <name>misra-c2012-17.3: Function declared implicitly (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) A function shall not be declared implicitly]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.4</key>
    <name>misra-c2012-17.4: Function should return a value (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) All exit paths from a function with non-void return type shall have an explicit return statement with an expression]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.5</key>
    <name>misra-c2012-17.5: Array has wrong size in function argument (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-17.6</key>
    <name>misra-c2012-17.6: Usage of static parameter of an array between [] (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) The declaration of an array parameter shall not contain the static keyword between the [ ]]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.7</key>
    <name>misra-c2012-17.7: Velue returned by function not used (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The value returned by a function having non-void return type shall be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-17.8</key>
    <name>misra-c2012-17.8: Modification of function parameter (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) A function parameter should not be modified ]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-18.1</key>
    <name>misra-c2012-18.1: Likely creation of out-of-bounds pointer (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-18.2</key>
    <name>misra-c2012-18.2: Substraction between different array with pointers (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Subtraction between pointers shall only be applied to pointers that address elements of the same array]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-18.3</key>
    <name>misra-c2012-18.3: Relational or subtract operator applied to pointers (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The relational operators &gt;, &gt;=, &lt; and &lt;= shall not be applied to objects of pointer type except where they point into the same object]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-18.4</key>
    <name>misra-c2012-18.4: Increment or subtract operator applied tp pointer (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The +, -, += and -= operators should not be applied to an expression of pointer type]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-18.5</key>
    <name>misra-c2012-18.5: More than 2 level of pointer (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) Declarations should contain no more than two levels of pointer nesting]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-18.6</key>
    <name>misra-c2012-18.6: Address of object with automatic storage affected to non persistant object (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-18.7</key>
    <name>misra-c2012-18.7: Usage of flexible array (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Flexible array members shall not be declared]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-18.8</key>
    <name>misra-c2012-18.8: Variable-length length arrya (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Variable-length array types shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-19.1</key>
    <name>misra-c2012-19.1: Assignation or copy to an overlapping object (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) An object shall not be assigned or copied to an overlapping object]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-19.2</key>
    <name>misra-c2012-19.2: Usage of Union Keyword (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The union keyword should not be used ]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-20.1</key>
    <name>misra-c2012-20.1: #include misplaced (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) #include directives should only be preceded by preprocessor directives or comments]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-20.2</key>
    <name>misra-c2012-20.2: Wrong character used in header file name (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The ',' or \ characters and the /* or // character sequences shall not occur in a header file name]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.3</key>
    <name>misra-c2012-20.3: #include followed by wrong sequence (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The #include directive shall be followed by either a &lt;filename&gt; or "filename" sequence]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.4</key>
    <name>misra-c2012-20.4: Macro name defined with a keyword (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A macro shall not be defined with the same name as a keyword]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.5</key>
    <name>misra-c2012-20.5: Usage of #undef (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) #undef should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-20.6</key>
    <name>misra-c2012-20.6: Apparent preprocessor directive in invocation of macro (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Tokens that look like a preprocessing directive shall not occur within a macro argument]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.7</key>
    <name>misra-c2012-20.7: Unparenthesized parameter in macro (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.8</key>
    <name>misra-c2012-20.8: Conditional of #if does not evaluate to 0 or 1 (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.9</key>
    <name>misra-c2012-20.9: Undefined preprocessor variable (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.10</key>
    <name>misra-c2012-20.10: #or ## processor operator used (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The # and ## preprocessor operators should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-20.11</key>
    <name>misra-c2012-20.11: Stringize operator followed by macro parameter followed by pasting operator (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A macro parameter immediately following a # operator shall not immediately be followed by a ## operator]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.12</key>
    <name>misra-c2012-20.12: Macro operator usedas an operand to # or ## and is subject to replacement (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.13</key>
    <name>misra-c2012-20.13: Not a valid preprocessing directive (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A line whose first token is # shall be a valid preprocessing directive]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-20.14</key>
    <name>misra-c2012-20.14: #else, #elif or #endif not in same file than #if, #ifdef or #ifndef (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.1</key>
    <name>misra-c2012-21.1: Illegal macro name with # usage (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) #define and #undef shall not be used on a reserved identifier or reserved macro name]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.2</key>
    <name>misra-c2012-21.2: Illegal macro name using reserved identifier (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) A reserved identifier or macro name shall not be declared]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.3</key>
    <name>misra-c2012-21.3: Usage of memory allocation and deallocation from stdlib.h is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.4</key>
    <name>misra-c2012-21.4: Usage of setjmp.h is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The standard header file &lt;setjmp.h&gt; shall not be used ]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.5</key>
    <name>misra-c2012-21.5: Usage of signal.h is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The standard header file &lt;signal.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.6</key>
    <name>misra-c2012-21.6: Usage of input/output functions (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The Standard Library input/output functions shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.7</key>
    <name>misra-c2012-21.7: Usage of atol, atol and atoll is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The atof, atoi, atol and atoll functions of &lt;stdlib.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.8</key>
    <name>misra-c2012-21.8: Usage of abort, exit, getenv and system is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The library functions abort, exit, getenv and system of &lt;stdlib.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.9</key>
    <name>misra-c2012-21.9: Usage of bsearch and qsort is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The library functions bsearch and qsort of &lt;stdlib.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.10</key>
    <name>misra-c2012-21.10: Usage of time and date function forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The Standard Library time and date functions shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.11</key>
    <name>misra-c2012-21.11: Usage of tgmath.h is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The standard header file &lt;tgmath.h&gt; shall not be used]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.12</key>
    <name>misra-c2012-21.12: Usage of exception handling from fenv.h is forbidden (MISRA C 2012)</name>
    <description>
      <![CDATA[(Advisory) The exception handling features of &lt;fenv.h&gt; should not be used]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-21.13</key>
    <name>misra-c2012-21.13: Value passed to ctype.h function has an invalid type (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) Any value passed to a function in &lt;ctype.h&gt; shall be representable as an unsigned char or be the value EOF]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-21.15</key>
    <name>misra-c2012-21.15: Different pointer types in memcpy, memmove or memcmp function parameters (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types]]>
    </description>
    <tag>misra-c2012</tag>
    </rule>
  <rule>
    <key>misra-c2012-21.16</key>
    <name>misra-c2012-21.16: Invalid pointer types in memcmp function parameters (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.17</key>
    <name>misra-c2012-21.17: Read or write access beyond the bounds of an object passed as a parameter to function in string.h (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) Use of the string handling functions from &lt;string.h&gt; shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-21.18</key>
    <name>misra-c2012-21.18: Size_t argument passed to string.h functions must be valid (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) The size_t argument passed to any function in &lt;string.h&gt; shall have an appropriate value]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-22.1</key>
    <name>misra-c2012-22.1: Custodial pointer has not been freed or returned (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) All resources obtained dynamically by means of Standard Library functions shall be explicitly released]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-22.2</key>
    <name>misra-c2012-22.2: Block of memory freed in bad conditions (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) A block of memory shall only be freed if it was allocated by means of a Standard Library function]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-22.3</key>
    <name>misra-c2012-22.3: Read and write function made in same time (MISRA C 2012)</name>
    <description>
      <![CDATA[(Required) The same file shall not be open for read and write access at the same time on different streams]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>CRITICAL</severity>
    </rule>
  <rule>
    <key>misra-c2012-22.4</key>
    <name>misra-c2012-22.4: Try to write on read only stream (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) There shall be no attempt to write to a stream which has been opened as read-only]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-22.5</key>
    <name>misra-c2012-22.5: Pointer to file dereferenced (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) A pointer to a FILE object shall not be dereferenced]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
  <rule>
    <key>misra-c2012-22.6</key>
    <name>misra-c2012-22.6: Value to pointer to file used after been closed (MISRA C 2012)</name>
    <description>
      <![CDATA[(Mandatory) The value of a pointer to a FILE shall not be used after the associated stream has been closed]]>
    </description>
    <tag>misra-c2012</tag>
    <severity>BLOCKER</severity>
    </rule>
</rules>
