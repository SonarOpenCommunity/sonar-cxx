<?xml version="1.0" encoding="UTF-8"?>
<rules>
  <rule>
    <key>=CustomRuleTemplate</key>
    <cardinality>MULTIPLE</cardinality>
    <name>Rule template for GCC custom rules</name>
    <description>
      <![CDATA[
<p>
Follow these steps to make your custom rules available in SonarQube:
</p>
<ol>
  <ol>
    <li>Create a new rule in SonarQube by "copying" this rule template and specify the <code>CheckId</code> of your custom rule, a title, a description, and a default severity.</li>
    <li>Enable the newly created rule in your quality profile</li>
  </ol>
  <li>Relaunch an analysis on your projects, et voilà, your custom rules are executed!</li>
</ol>]]>
      </description>
    </rule>
  <rule>
    <key>unknown</key>
    <name>Unknown GCC rule</name>
    <description>
      <![CDATA[
<p>
By activating this rule, unknown rules in the reports are not discarded but mapped to this rule. This helps to identify unknown rules, e.g. from newer versions of a tool.
</p>
]]>
      </description>
    <severity>INFO</severity>
    </rule>
  <rule>
    <key>default</key>
    <name>Default compiler warnings</name>
    <description>Default compiler warnings.</description>
    </rule>
  <rule>
    <key>-WNSObject-attribute</key>
    <name>Warn if the NSObject attribute is applied to a non-typedef</name>
    <description>
      <![CDATA[Warn if the NSObject attribute is applied to a non-typedef]]>
      </description>
    </rule>
  <rule>
    <key>-Wabi</key>
    <name>Warn about things that will change when compiling with an ABI-compliant compiler</name>
    <description>
      <![CDATA[
<p>Warn about code affected by ABI changes.  This includes code that may
not be compatible with the vendor-neutral C++ ABI as well as the psABI
for the particular target.
</p>
<p>Since G++ now defaults to updating the ABI with each major release,
normally <samp>-Wabi</samp> warns only about C++ ABI compatibility
problems if there is a check added later in a release series for an
ABI issue discovered since the initial release.  <samp>-Wabi</samp> warns
about more things if an older ABI version is selected (with
<samp>-fabi-version=<var>n</var></samp>).
</p>
<p><samp>-Wabi</samp> can also be used with an explicit version number to
warn about C++ ABI compatibility with a particular <samp>-fabi-version</samp>
level, e.g. <samp>-Wabi=2</samp> to warn about changes relative to
<samp>-fabi-version=2</samp>.
</p>
<p>If an explicit version number is provided and
<samp>-fabi-compat-version</samp> is not specified, the version number
from this option is used for compatibility aliases.  If no explicit
version number is provided with this option, but
<samp>-fabi-compat-version</samp> is specified, that version number is
used for C++ ABI warnings.
</p>
<p>Although an effort has been made to warn about
all such cases, there are probably some cases that are not warned about,
even though G++ is generating incompatible code.  There may also be
cases where warnings are emitted even though the code that is generated
is compatible.
</p>
<p>You should rewrite your code to avoid these warnings if you are
concerned about the fact that code generated by G++ may not be binary
compatible with code generated by other compilers.
</p>
<p>Known incompatibilities in <samp>-fabi-version=2</samp> (which was the
default from GCC 3.4 to 4.9) include:
</p>
<ul>
<li>A template with a non-type template parameter of reference type was
mangled incorrectly:
<div>
<pre>extern int N;
template &lt;int &amp;&gt; struct S {};
void n (S&lt;N&gt;) {2}
</pre></div>
<p>This was fixed in <samp>-fabi-version=3</samp>.
</p>
</li><li>SIMD vector types declared using <code>__attribute ((vector_size))</code> were
mangled in a non-standard way that does not allow for overloading of
functions taking vectors of different sizes.

<p>The mangling was changed in <samp>-fabi-version=4</samp>.
</p>
</li><li><code>__attribute ((const))</code> and <code>noreturn</code> were mangled as type
qualifiers, and <code>decltype</code> of a plain declaration was folded away.

<p>These mangling issues were fixed in <samp>-fabi-version=5</samp>.
</p>
</li><li>Scoped enumerators passed as arguments to a variadic function are
promoted like unscoped enumerators, causing <code>va_arg</code> to complain.
On most targets this does not actually affect the parameter passing
ABI, as there is no way to pass an argument smaller than <code>int</code>.

<p>Also, the ABI changed the mangling of template argument packs,
<code>const_cast</code>, <code>static_cast</code>, prefix increment/decrement, and
a class scope function used as a template argument.
</p>
<p>These issues were corrected in <samp>-fabi-version=6</samp>.
</p>
</li><li>Lambdas in default argument scope were mangled incorrectly, and the
ABI changed the mangling of <code>nullptr_t</code>.

<p>These issues were corrected in <samp>-fabi-version=7</samp>.
</p>
</li><li>When mangling a function type with function-cv-qualifiers, the
un-qualified function type was incorrectly treated as a substitution
candidate.

<p>This was fixed in <samp>-fabi-version=8</samp>, the default for GCC 5.1.
</p>
</li><li><code>decltype(nullptr)</code> incorrectly had an alignment of 1, leading to
unaligned accesses.  Note that this did not affect the ABI of a
function with a <code>nullptr_t</code> parameter, as parameters have a
minimum alignment.

<p>This was fixed in <samp>-fabi-version=9</samp>, the default for GCC 5.2.
</p>
</li><li>Target-specific attributes that affect the identity of a type, such as
ia32 calling conventions on a function type (stdcall, regparm, etc.),
did not affect the mangled name, leading to name collisions when
function pointers were used as template arguments.

<p>This was fixed in <samp>-fabi-version=10</samp>, the default for GCC 6.1.
</p>
</li></ul>
<p>This option also enables warnings about psABI-related changes.
The known psABI changes at this point include:
</p>
<ul>
<li>For SysV/x86-64, unions with <code>long double</code> members are
passed in memory as specified in psABI.  Prior to GCC 4.4, this was not
the case.  For example:

<div>
<pre>union U {
  long double ld;
  int i;
};
</pre></div>
<p><code>union U</code> is now always passed in memory.
</p>
</li></ul>]]>
      </description>
    </rule>
  <rule>
    <key>-Wabi-tag</key>
    <name>Warn if a subobject has an abi_tag attribute that the complete object type does not have</name>
    <description>
      <![CDATA[<p>Warn when a type with an ABI tag is used in a context that does not
have that ABI tag.  See <a href="C_002b_002b-Attributes.html">C++-Specific Variable, Function, and Type Attributes</a> for more information
about ABI tags.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wabsolute-value</key>
    <name>Warn on suspicious calls of standard functions computing absolute values</name>
    <description>
      <![CDATA[<p>Warn for calls to standard functions that compute the absolute value
of an argument when a more appropriate standard function is available.
For example, calling <code>abs(3.14)</code> triggers the warning because the
appropriate function to call to compute the absolute value of a double
argument is <code>fabs</code>.  The option also triggers warnings when the
argument in a call to such a function has an unsigned type.  This
warning can be suppressed with an explicit type cast and it is also
enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Waddress</key>
    <name>Warn about suspicious uses of memory addresses</name>
    <description>
      <![CDATA[<p>Warn about suspicious uses of address expressions. These include comparing
the address of a function or a declared object to the null pointer constant
such as in
</p><div>
<pre>void f (void);
void g (void)
{
  if (!f)   // warning: expression evaluates to false
    abort ();
}
</pre></div>
<p>comparisons of a pointer to a string literal, such as in
</p><div>
<pre>void f (const char *x)
{
  if (x == "abc")   // warning: expression evaluates to false
    puts ("equal");
}
</pre></div>
<p>and tests of the results of pointer addition or subtraction for equality
to null, such as in
</p><div>
<pre>void f (const int *p, int i)
{
  return p + i == NULL;
}
</pre></div>
<p>Such uses typically indicate a programmer error: the address of most
functions and objects necessarily evaluates to true (the exception are
weak symbols), so their use in a conditional might indicate missing
parentheses in a function call or a missing dereference in an array
expression.  The subset of the warning for object pointers can be
suppressed by casting the pointer operand to an integer type such
as <code>intptr_t</code> or <code>uintptr_t</code>.
Comparisons against string literals result in unspecified behavior
and are not portable, and suggest the intent was to call <code>strcmp</code>.
The warning is suppressed if the suspicious expression is the result
of macro expansion.
<samp>-Waddress</samp> warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Waddress-of-packed-member</key>
    <name>Warn when the address of packed member of struct or union is taken</name>
    <description>
      <![CDATA[<p>Warn when the address of packed member of struct or union is taken,
which usually results in an unaligned pointer value.  This is
enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Waggregate-return</key>
    <name>Warn about returning structures, unions or arrays</name>
    <description>
      <![CDATA[<p>Warn if any functions that return structures or unions are defined or
called.  (In languages where you can return an array, this also elicits
a warning.)
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Waggressive-loop-optimizations</key>
    <name>Warn if a loop with constant number of iterations triggers undefined behavior</name>
    <description>
      <![CDATA[<p>Warn if in a loop with constant number of iterations the compiler detects
undefined behavior in some statement during one or more of the iterations.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Waligned-new</key>
    <name>Warn about 'new' of type with extended alignment without -faligned-new</name>
    <description>
      <![CDATA[<p>Warn about a new-expression of a type that requires greater alignment
than the <code>alignof(std::max_align_t)</code> but uses an allocation
function without an explicit alignment parameter. This option is
enabled by <samp>-Wall</samp>.
</p>
<p>Normally this only warns about global allocation functions, but
<samp>-Waligned-new=all</samp> also warns about class member allocation
functions.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Walloc-size</key>
    <name>Warn when allocating insufficient storage for the target type of the assigned pointer</name>
    <description>
      <![CDATA[<p>Warn about calls to allocation functions decorated with attribute
<code>alloc_size</code> that specify insufficient size for the target type of
the pointer the result is assigned to, including those to the built-in
forms of the functions <code>aligned_alloc</code>, <code>alloca</code>,
<code>calloc</code>, <code>malloc</code>, and <code>realloc</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Walloc-size-larger-than</key>
    <name>Warn for calls to allocation functions that attempt to allocate objects larger than the specified number of bytes</name>
    <description>
      <![CDATA[<p>Warn about calls to functions decorated with attribute <code>alloc_size</code>
that attempt to allocate objects larger than the specified number of bytes,
or where the result of the size computation in an integer type with infinite
precision would exceed the value of ‘<samp>PTRDIFF_MAX</samp>’ on the target.
<samp>-Walloc-size-larger-than=</samp>‘<samp>PTRDIFF_MAX</samp>’ is enabled by default.
Warnings controlled by the option can be disabled either by specifying
<var>byte-size</var> of ‘<samp>SIZE_MAX</samp>’ or more or by
<samp>-Wno-alloc-size-larger-than</samp>.
See <a href="Function-Attributes.html">Declaring Attributes of Functions</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Walloc-zero</key>
    <name>Warn for calls to allocation functions that specify zero bytes</name>
    <description>
      <![CDATA[<p>Warn about calls to allocation functions decorated with attribute
<code>alloc_size</code> that specify zero bytes, including those to the built-in
forms of the functions <code>aligned_alloc</code>, <code>alloca</code>, <code>calloc</code>,
<code>malloc</code>, and <code>realloc</code>.  Because the behavior of these functions
when called with a zero size differs among implementations (and in the case
of <code>realloc</code> has been deprecated) relying on it may result in subtle
portability bugs and should be avoided.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Walloca</key>
    <name>Warn on any use of alloca</name>
    <description>
      <![CDATA[<p>This option warns on all uses of <code>alloca</code> in the source.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Walloca-larger-than</key>
    <name>Warn on unbounded uses of alloca, and on bounded uses of alloca whose bound can be larger than &lt;number&gt; bytes</name>
    <description>
      <![CDATA[<p>This option warns on calls to <code>alloca</code> with an integer argument whose
value is either zero, or that is not bounded by a controlling predicate
that limits its value to at most <var>byte-size</var>.  It also warns for calls
to <code>alloca</code> where the bound value is unknown.  Arguments of non-integer
types are considered unbounded even if they appear to be constrained to
the expected range.
</p>
<p>For example, a bounded case of <code>alloca</code> could be:
</p>
<div>
<pre>void func (size_t n)
{
  void *p;
  if (n &lt;= 1000)
    p = alloca (n);
  else
    p = malloc (n);
  f (p);
}
</pre></div>
<p>In the above example, passing <code>-Walloca-larger-than=1000</code> would not
issue a warning because the call to <code>alloca</code> is known to be at most
1000 bytes.  However, if <code>-Walloca-larger-than=500</code> were passed,
the compiler would emit a warning.
</p>
<p>Unbounded uses, on the other hand, are uses of <code>alloca</code> with no
controlling predicate constraining its integer argument.  For example:
</p>
<div>
<pre>void func ()
{
  void *p = alloca (n);
  f (p);
}
</pre></div>
<p>If <code>-Walloca-larger-than=500</code> were passed, the above would trigger
a warning, but this time because of the lack of bounds checking.
</p>
<p>Note, that even seemingly correct code involving signed integers could
cause a warning:
</p>
<div>
<pre>void func (signed int n)
{
  if (n &lt; 500)
    {
      p = alloca (n);
      f (p);
    }
}
</pre></div>
<p>In the above example, <var>n</var> could be negative, causing a larger than
expected argument to be implicitly cast into the <code>alloca</code> call.
</p>
<p>This option also warns when <code>alloca</code> is used in a loop.
</p>
<p><samp>-Walloca-larger-than=</samp>‘<samp>PTRDIFF_MAX</samp>’ is enabled by default
but is usually only effective  when <samp>-ftree-vrp</samp> is active (default
for <samp>-O2</samp> and above).
</p>
<p>See also <samp>-Wvla-larger-than=</samp>‘<samp>byte-size</samp>’.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-allocation-size</key>
    <name>Warn about code paths in which a pointer to a buffer is assigned to an incompatible type</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it;
to disable it, use <samp>-Wno-analyzer-allocation-size</samp>.
</p>
<p>This diagnostic warns for paths through the code in which a pointer to
a buffer is assigned to point at a buffer with a size that is not a
multiple of <code>sizeof (*pointer)</code>.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/131.html">CWE-131: Incorrect Calculation of Buffer Size</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-deref-before-check</key>
    <name>Warn about code paths in which a pointer is checked for NULL after it has already been dereferenced</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-deref-before-check</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a pointer
is checked for <code>NULL</code> *after* it has already been
dereferenced, suggesting that the pointer could have been NULL.
Such cases suggest that the check for NULL is either redundant,
or that it needs to be moved to before the pointer is dereferenced.
</p>
<p>This diagnostic also considers values passed to a function argument
marked with <code>__attribute__((nonnull))</code> as requiring a non-NULL
value, and thus will complain if such values are checked for <code>NULL</code>
after returning from such a function call.
</p>
<p>This diagnostic is unlikely to be reported when any level of optimization
is enabled, as GCC’s optimization logic will typically consider such
checks for NULL as being redundant, and optimize them away before the
analyzer "sees" them.  Hence optimization should be disabled when
attempting to trigger this diagnostic.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-double-fclose</key>
    <name>Warn about code paths in which a stdio FILE can be closed more than once</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-double-fclose</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a <code>FILE *</code>
can have <code>fclose</code> called on it more than once.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/1341.html">CWE-1341: Multiple Releases of Same Resource or Handle</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-double-free</key>
    <name>Warn about code paths in which a pointer can be freed more than once</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-double-free</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a pointer
can have a deallocator called on it more than once, either <code>free</code>,
or a deallocator referenced by attribute <code>malloc</code>.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/415.html">CWE-415: Double Free</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-exposure-through-output-file</key>
    <name>Warn about code paths in which sensitive data is written to a file</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-exposure-through-output-file</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
security-sensitive value is written to an output file
(such as writing a password to a log file).
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/532.html">CWE-532: Information Exposure Through Log Files</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-exposure-through-uninit-copy</key>
    <name>Warn about code paths in which sensitive data is copied across a security boundary</name>
    <description>
      <![CDATA[<p>This warning requires both <samp>-fanalyzer</samp> and the use of a plugin
to specify a function that copies across a “trust boundary”.  Use
<samp>-Wno-analyzer-exposure-through-uninit-copy</samp> to disable it.
</p>
<p>This diagnostic warns for “infoleaks” - paths through the code in which
uninitialized values are copied across a security boundary
(such as code within an OS kernel that copies a partially-initialized
struct on the stack to user space).
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/200.html">CWE-200: Exposure of Sensitive Information to an Unauthorized Actor</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-access-mode-mismatch</key>
    <name>Warn about code paths in which read on a write-only file descriptor is attempted, or vice versa</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-access-mode-mismatch</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which a
<code>read</code> on a write-only file descriptor is attempted, or vice versa.
</p>
<p>This diagnostic also warns for code paths in a which a function with attribute
<code>fd_arg_read (N)</code> is called with a file descriptor opened with
<code>O_WRONLY</code> at referenced argument <code>N</code> or a function with attribute
<code>fd_arg_write (N)</code> is called with a file descriptor opened with
<code>O_RDONLY</code> at referenced argument <var>N</var>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-double-close</key>
    <name>Warn about code paths in which a file descriptor can be closed more than once</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-double-close</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which a
file descriptor can be closed more than once.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/1341.html">CWE-1341: Multiple Releases of Same Resource or Handle</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-leak</key>
    <name>Warn about code paths in which a file descriptor is not closed</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-leak</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which an
open file descriptor is leaked.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/775.html">CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-phase-mismatch</key>
    <name>Warn about code paths in which an operation is attempted in the wrong phase of a file descriptor's lifetime</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-phase-mismatch</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which an operation is
attempted in the wrong phase of a file descriptor’s lifetime.
For example, it will warn on attempts to call <code>accept</code> on a stream
socket that has not yet had <code>listen</code> successfully called on it.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/666.html">CWE-666: Operation on Resource in Wrong Phase of Lifetime</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-type-mismatch</key>
    <name>Warn about code paths in which an operation is attempted on the wrong type of file descriptor</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-type-mismatch</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which an
operation is attempted on the wrong type of file descriptor.
For example, it will warn on attempts to use socket operations
on a file descriptor obtained via <code>open</code>, or when attempting
to use a stream socket operation on a datagram socket.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-use-after-close</key>
    <name>Warn about code paths in which a read or write is performed on a closed file descriptor</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-use-after-close</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which a
read or write is called on a closed file descriptor.
</p>
<p>This diagnostic also warns for paths through code in which
a function with attribute <code>fd_arg (N)</code> or <code>fd_arg_read (N)</code>
or <code>fd_arg_write (N)</code> is called with a closed file descriptor at
referenced argument <code>N</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-fd-use-without-check</key>
    <name>Warn about code paths in which a file descriptor is used without being checked for validity</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-fd-use-without-check</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through code in which a
file descriptor is used without being checked for validity.
</p>
<p>This diagnostic also warns for paths through code in which
a function with attribute <code>fd_arg (N)</code> or <code>fd_arg_read (N)</code>
or <code>fd_arg_write (N)</code> is called with a file descriptor, at referenced
argument <code>N</code>, without being checked for validity.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-file-leak</key>
    <name>Warn about code paths in which a stdio FILE is not closed</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-file-leak</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
<code>&lt;stdio.h&gt;</code> <code>FILE *</code> stream object is leaked.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/775.html">CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-free-of-non-heap</key>
    <name>Warn about code paths in which a non-heap pointer is freed</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-free-of-non-heap</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which <code>free</code>
is called on a non-heap pointer (e.g. an on-stack buffer, or a global).
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/590.html">CWE-590: Free of Memory not on the Heap</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-imprecise-fp-arithmetic</key>
    <name>Warn about code paths in which floating-point arithmetic is used in locations where precise computation is needed</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-imprecise-fp-arithmetic</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which floating-point
arithmetic is used in locations where precise computation is needed.  This
diagnostic only warns on use of floating-point operands inside the
calculation of an allocation size at the moment.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-infinite-loop</key>
    <name>Warn about code paths which appear to lead to an infinite loop</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-infinite-loop</samp> to disable it.
</p>
<p>This diagnostics warns for paths through the code which appear to
lead to an infinite loop.
</p>
<p>Specifically, the analyzer will issue this warning when it "sees" a loop
in which:
</p><ul>
<li>no externally-visible work could be being done within the loop
</li><li>there is no way to escape from the loop
</li><li>the analyzer is sufficiently confident about the program state
throughout the loop to know that the above are true
</li></ul>
<p>One way for this warning to be emitted is when there is an execution
path through a loop for which taking the path on one iteration implies
that the same path will be taken on all subsequent iterations.
</p>
<p>For example, consider:
</p>
<div>
<pre>  while (1)
    {
      char opcode = *cpu_state.pc;
      switch (opcode)
       {
       case OPCODE_FOO:
         handle_opcode_foo (&amp;cpu_state);
         break;
       case OPCODE_BAR:
         handle_opcode_bar (&amp;cpu_state);
         break;
       }
    }
</pre></div>
<p>The analyzer will complain for the above case because if <code>opcode</code>
ever matches none of the cases, the <code>switch</code> will follow the
implicit <code>default</code> case, making the body of the loop be a “no-op”
with <code>cpu_state.pc</code> unchanged, and thus using the same value of
<code>opcode</code> on all subseqent iterations, leading to an infinite loop.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/835.html">CWE-835: Loop with Unreachable Exit Condition (’Infinite Loop’)</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-infinite-recursion</key>
    <name>Warn about code paths which appear to lead to infinite recursion</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-infinite-recursion</samp> to disable it.
</p>
<p>This diagnostics warns for paths through the code which appear to
lead to infinite recursion.
</p>
<p>Specifically, when the analyzer "sees" a recursive call, it will compare
the state of memory at the entry to the new frame with that at the entry
to the previous frame of that function on the stack.  The warning is
issued if nothing in memory appears to be changing; any changes observed
to parameters or globals are assumed to lead to termination of the
recursion and thus suppress the warning.
</p>
<p>This diagnostic is likely to miss cases of infinite recursion that
are convered to iteration by the optimizer before the analyzer "sees"
them.  Hence optimization should be disabled when attempting to trigger
this diagnostic.
</p>
<p>Compare with <samp>-Winfinite-recursion</samp>, which provides a similar
diagnostic, but is implemented in a different way.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/674.html">CWE-674: Uncontrolled Recursion</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-jump-through-null</key>
    <name>Warn about code paths in which a NULL function pointer is called</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-jump-through-null</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a <code>NULL</code>
function pointer is called.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-malloc-leak</key>
    <name>Warn about code paths in which a heap-allocated pointer leaks</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-malloc-leak</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
pointer allocated via an allocator is leaked: either <code>malloc</code>,
or a function marked with attribute <code>malloc</code>.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/401.html">CWE-401: Missing Release of Memory after Effective Lifetime</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-mismatching-deallocation</key>
    <name>Warn about code paths in which the wrong deallocation function is called</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-mismatching-deallocation</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which the
wrong deallocation function is called on a pointer value, based on
which function was used to allocate the pointer value.  The diagnostic
will warn about mismatches between <code>free</code>, scalar <code>delete</code>
and vector <code>delete[]</code>, and those marked as allocator/deallocator
pairs using attribute <code>malloc</code>.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/762.html">CWE-762: Mismatched Memory Management Routines</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-null-argument</key>
    <name>Warn about code paths in which NULL is passed to a must-not-be-NULL function argument</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-null-argument</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
value known to be NULL is passed to a function argument marked
with <code>__attribute__((nonnull))</code> as requiring a non-NULL
value.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/476.html">CWE-476: NULL Pointer Dereference</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-null-dereference</key>
    <name>Warn about code paths in which a NULL pointer is dereferenced</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-null-dereference</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
value known to be NULL is dereferenced.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/476.html">CWE-476: NULL Pointer Dereference</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-out-of-bounds</key>
    <name>Warn about code paths in which a write or read to a buffer is out-of-bounds</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-out-of-bounds</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a buffer is
definitely read or written out-of-bounds.  The diagnostic applies for
cases where the analyzer is able to determine a constant offset and for
accesses past the end of a buffer, also a constant capacity.  Further,
the diagnostic does limited checking for accesses past the end when the
offset as well as the capacity is symbolic.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/119.html">CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer</a>.
</p>
<p>For cases where the analyzer is able, it will emit a text art diagram
visualizing the spatial relationship between the memory region that the
analyzer predicts would be accessed, versus the range of memory that is
valid to access: whether they overlap, are touching, are close or far
apart; which one is before or after in memory, the relative sizes
involved, the direction of the access (read vs write), and, in some
cases, the values of data involved.  This diagram can be suppressed
using <samp>-fdiagnostics-text-art-charset=none</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-overlapping-buffers</key>
    <name>Warn about code paths in which undefined behavior would occur due to overlapping buffers</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-overlapping-buffers</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which overlapping
buffers are passed to an API for which the behavior on such buffers
is undefined.
</p>
<p>Specifically, the diagnostic occurs on calls to the following functions
</p><ul>
<li><code>memcpy</code>
</li><li><code>strcat</code>
</li><li><code>strcpy</code>
</li></ul>
<p>for cases where the buffers are known to overlap.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-possible-null-argument</key>
    <name>Warn about code paths in which a possibly-NULL value is passed to a must-not-be-NULL function argument</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-possible-null-argument</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
possibly-NULL value is passed to a function argument marked
with <code>__attribute__((nonnull))</code> as requiring a non-NULL
value.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/690.html">CWE-690: Unchecked Return Value to NULL Pointer Dereference</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-possible-null-dereference</key>
    <name>Warn about code paths in which a possibly-NULL pointer is dereferenced</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-possible-null-dereference</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
possibly-NULL value is dereferenced.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/690.html">CWE-690: Unchecked Return Value to NULL Pointer Dereference</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-putenv-of-auto-var</key>
    <name>Warn about code paths in which an on-stack buffer is passed to putenv</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-putenv-of-auto-var</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
call to <code>putenv</code> is passed a pointer to an automatic variable
or an on-stack buffer.
</p>
<p>See <a href="https://wiki.sei.cmu.edu/confluence/x/6NYxBQ">POS34-C. Do not call putenv() with a pointer to an automatic variable as the argument</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-shift-count-negative</key>
    <name>Warn about code paths in which a shift with negative count is attempted</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-shift-count-negative</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
shift is attempted with a negative count.  It is analogous to
the <samp>-Wshift-count-negative</samp> diagnostic implemented in
the C/C++ front ends, but is implemented based on analyzing
interprocedural paths, rather than merely parsing the syntax tree.
However, the analyzer does not prioritize detection of such paths, so
false negatives are more likely relative to other warnings.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-shift-count-overflow</key>
    <name>Warn about code paths in which a shift with count &gt;= width of type is attempted</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-shift-count-overflow</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
shift is attempted with a count greater than or equal to the
precision of the operand’s type.  It is analogous to
the <samp>-Wshift-count-overflow</samp> diagnostic implemented in
the C/C++ front ends, but is implemented based on analyzing
interprocedural paths, rather than merely parsing the syntax tree.
However, the analyzer does not prioritize detection of such paths, so
false negatives are more likely relative to other warnings.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-stale-setjmp-buffer</key>
    <name>Warn about code paths in which a longjmp rewinds to a jmp_buf saved in a stack frame that has returned</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-stale-setjmp-buffer</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which
<code>longjmp</code> is called to rewind to a <code>jmp_buf</code> relating
to a <code>setjmp</code> call in a function that has returned.
</p>
<p>When <code>setjmp</code> is called on a <code>jmp_buf</code> to record a rewind
location, it records the stack frame.  The stack frame becomes invalid
when the function containing the <code>setjmp</code> call returns.  Attempting
to rewind to it via <code>longjmp</code> would reference a stack frame that
no longer exists, and likely lead to a crash (or worse).
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-symbol-too-complex</key>
    <name>Warn if expressions are too complicated for the analyzer to fully track</name>
    <description>
      <![CDATA[<p>If <samp>-fanalyzer</samp> is enabled, the analyzer uses various heuristics
to attempt to track the state of memory, but these can be defeated by
sufficiently complicated code.
</p>
<p>By default, the analysis silently stops tracking values of expressions
if they exceed the threshold defined by
<samp>--param analyzer-max-svalue-depth=<var>value</var></samp>, and falls back
to an imprecise representation for such expressions.
The <samp>-Wanalyzer-symbol-too-complex</samp> option warns if this occurs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-tainted-allocation-size</key>
    <name>Warn about code paths in which an unsanitized value is used as an allocation size</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp> which enables it;
use <samp>-Wno-analyzer-tainted-allocation-size</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a value
that could be under an attacker’s control is used as the size
of an allocation without being sanitized, so that an attacker could
inject an excessively large allocation and potentially cause a denial
of service attack.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/789.html">CWE-789: Memory Allocation with Excessive Size Value</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-tainted-array-index</key>
    <name>Warn about code paths in which an unsanitized value is used as an array index</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp> which enables it;
use <samp>-Wno-analyzer-tainted-array-index</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a value
that could be under an attacker’s control is used as the index
of an array access without being sanitized, so that an attacker
could inject an out-of-bounds access.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/129.html">CWE-129: Improper Validation of Array Index</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-tainted-assertion</key>
    <name>Warn about code paths in which an 'assert()' is made involving an unsanitized value</name>
    <description>
      <![CDATA[
<p>This warning requires <samp>-fanalyzer</samp> which enables it;
use <samp>-Wno-analyzer-tainted-assertion</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a value
that could be under an attacker’s control is used as part of a
condition without being first sanitized, and that condition guards a
call to a function marked with attribute <code>noreturn</code>
(such as the function <code>__builtin_unreachable</code>).  Such functions
typically indicate abnormal termination of the program, such as for
assertion failure handlers.  For example:
</p>
<div>
<pre>assert (some_tainted_value &lt; SOME_LIMIT);
</pre></div>
<p>In such cases:
</p>
<ul>
<li>when assertion-checking is enabled: an attacker could trigger
a denial of service by injecting an assertion failure

</li><li>when assertion-checking is disabled, such as by defining <code>NDEBUG</code>,
an attacker could inject data that subverts the process, since it
presumably violates a precondition that is being assumed by the code.

</li></ul>
<p>Note that when assertion-checking is disabled, the assertions are
typically removed by the preprocessor before the analyzer has a chance
to "see" them, so this diagnostic can only generate warnings on builds
in which assertion-checking is enabled.
</p>
<p>For the purpose of this warning, any function marked with attribute
<code>noreturn</code> is considered as a possible assertion failure
handler, including <code>__builtin_unreachable</code>.  Note that these functions
are sometimes removed by the optimizer before the analyzer "sees" them.
Hence optimization should be disabled when attempting to trigger this
diagnostic.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/617.html">CWE-617: Reachable Assertion</a>.
</p>
<p>The warning can also report problematic constructions such as
</p>
<div>
<pre>switch (some_tainted_value) {
case 0:
  /* [...etc; various valid cases omitted...] */
  break;

default:
  __builtin_unreachable (); /* BUG: attacker can trigger this  */
}
</pre></div>
<p>despite the above not being an assertion failure, strictly speaking.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-tainted-divisor</key>
    <name>Warn about code paths in which an unsanitized value is used as a divisor</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp> which enables it;
use <samp>-Wno-analyzer-tainted-divisor</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a value
that could be under an attacker’s control is used as the divisor
in a division or modulus operation without being sanitized, so that
an attacker could inject a division-by-zero.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/369.html">CWE-369: Divide By Zero</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-tainted-offset</key>
    <name>Warn about code paths in which an unsanitized value is used as a pointer offset</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp> which enables it;
use <samp>-Wno-analyzer-tainted-offset</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a value
that could be under an attacker’s control is used as a pointer offset
without being sanitized, so that an attacker could inject an out-of-bounds
access.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/823.html">CWE-823: Use of Out-of-range Pointer Offset</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-tainted-size</key>
    <name>Warn about code paths in which an unsanitized value is used as a size</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp> which enables it;
use <samp>-Wno-analyzer-tainted-size</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a value
that could be under an attacker’s control is used as the size of
an operation such as <code>memset</code> without being sanitized, so that an
attacker could inject an out-of-bounds access.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/129.html">CWE-129: Improper Validation of Array Index</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-too-complex</key>
    <name>Warn if the code is too complicated for the analyzer to fully explore</name>
    <description>
      <![CDATA[<p>If <samp>-fanalyzer</samp> is enabled, the analyzer uses various heuristics
to attempt to explore the control flow and data flow in the program,
but these can be defeated by sufficiently complicated code.
</p>
<p>By default, the analysis silently stops if the code is too
complicated for the analyzer to fully explore and it reaches an internal
limit.  The <samp>-Wanalyzer-too-complex</samp> option warns if this occurs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-undefined-behavior-strtok</key>
    <name>Warn about code paths in which a call is made to strtok with undefined behavior</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-undefined-behavior-strtok</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
call is made to <code>strtok</code> with undefined behavior.
</p>
<p>Specifically, passing NULL as the first parameter for the initial
call to <code>strtok</code> within a process has undefined behavior.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-unsafe-call-within-signal-handler</key>
    <name>Warn about code paths in which an async-signal-unsafe function is called from a signal handler</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-unsafe-call-within-signal-handler</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
function known to be async-signal-unsafe (such as <code>fprintf</code>) is
called from a signal handler.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/479.html">CWE-479: Signal Handler Use of a Non-reentrant Function</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-use-after-free</key>
    <name>Warn about code paths in which a freed value is used</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-use-after-free</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a
pointer is used after a deallocator is called on it: either <code>free</code>,
or a deallocator referenced by attribute <code>malloc</code>.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/416.html">CWE-416: Use After Free</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-use-of-pointer-in-stale-stack-frame</key>
    <name>Warn about code paths in which a pointer to a stale stack frame is used</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-use-of-pointer-in-stale-stack-frame</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which a pointer
is dereferenced that points to a variable in a stale stack frame.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-use-of-uninitialized-value</key>
    <name>Warn about code paths in which an uninitialized value is used</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-use-of-uninitialized-value</samp> to disable it.
</p>
<p>This diagnostic warns for paths through the code in which an uninitialized
value is used.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/457.html">CWE-457: Use of Uninitialized Variable</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-va-arg-type-mismatch</key>
    <name>Warn about code paths in which va_arg uses the wrong type</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-va-arg-type-mismatch</samp>
to disable it.
</p>
<p>This diagnostic warns for interprocedural paths through the code for which
the analyzer detects an attempt to use <code>va_arg</code> to extract a value
passed to a variadic call, but uses a type that does not match that of
the expression passed to the call.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/686.html">CWE-686: Function Call With Incorrect Argument Type</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-va-list-exhausted</key>
    <name>Warn about code paths in which va_arg is used too many times on a va_list</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-va-list-exhausted</samp>
to disable it.
</p>
<p>This diagnostic warns for interprocedural paths through the code for which
the analyzer detects an attempt to use <code>va_arg</code> to access the next
value passed to a variadic call, but all of the values in the
<code>va_list</code> have already been consumed.
</p>
<p>See <a href="https://cwe.mitre.org/data/definitions/685.html">CWE-685: Function Call With Incorrect Number of Arguments</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-va-list-leak</key>
    <name>Warn about code paths in which va_start or va_copy is used without a corresponding va_end</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-va-list-leak</samp>
to disable it.
</p>
<p>This diagnostic warns for interprocedural paths through the code for which
the analyzer detects that <code>va_start</code> or <code>va_copy</code> has been called
on a <code>va_list</code> without a corresponding call to <code>va_end</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-va-list-use-after-va-end</key>
    <name>Warn about code paths in which a va_list is used after va_end</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-va-list-use-after-va-end</samp>
to disable it.
</p>
<p>This diagnostic warns for interprocedural paths through the code for which
the analyzer detects an attempt to use a <code>va_list</code>  after
<code>va_end</code> has been called on it.
<code>va_list</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-write-to-const</key>
    <name>Warn about code paths which attempt to write to a const object</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-write-to-const</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which the analyzer
detects an attempt to write through a pointer to a <code>const</code> object.
However, the analyzer does not prioritize detection of such paths, so
false negatives are more likely relative to other warnings.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wanalyzer-write-to-string-literal</key>
    <name>Warn about code paths which attempt to write to a string literal</name>
    <description>
      <![CDATA[<p>This warning requires <samp>-fanalyzer</samp>, which enables it; use
<samp>-Wno-analyzer-write-to-string-literal</samp>
to disable it.
</p>
<p>This diagnostic warns for paths through the code in which the analyzer
detects an attempt to write through a pointer to a string literal.
However, the analyzer does not prioritize detection of such paths, so
false negatives are more likely relative to other warnings.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Warith-conversion</key>
    <name>Warn if conversion of the result of arithmetic might change the value even though converting the operands cannot</name>
    <description>
      <![CDATA[<p>Do warn about implicit conversions from arithmetic operations even
when conversion of the operands to the same type cannot change their
values.  This affects warnings from <samp>-Wconversion</samp>,
<samp>-Wfloat-conversion</samp>, and <samp>-Wsign-conversion</samp>.
</p>
<div>
<div><pre>void f (char c, int i)
{
  c = c + i; // warns with <samp>-Wconversion</samp>
  c = c + 1; // only warns with <samp>-Warith-conversion</samp>
}
</pre></div></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Warray-bounds</key>
    <name>Warn if an array is accessed out of bounds</name>
    <description>
      <![CDATA[<p>Warn about out of bounds subscripts or offsets into arrays.  This warning
is enabled by <samp>-Wall</samp>.  It is more effective when <samp>-ftree-vrp</samp>
is active (the default for <samp>-O2</samp> and above) but a subset of instances
are issued even without optimization.
</p>
<p>By default, the trailing array of a structure will be treated as a flexible
array member by <samp>-Warray-bounds</samp> or <samp>-Warray-bounds=<var>n</var></samp>
if it is declared as either a flexible array member per C99 standard onwards
(‘<samp>[]</samp>’), a GCC zero-length array extension (‘<samp>[0]</samp>’), or an one-element
array (‘<samp>[1]</samp>’). As a result, out of bounds subscripts or offsets into
zero-length arrays or one-element arrays are not warned by default.
</p>
<p>You can add the option <samp>-fstrict-flex-arrays</samp> or
<samp>-fstrict-flex-arrays=<var>level</var></samp> to control how this
option treat trailing array of a structure as a flexible array member:
</p>
<p>when <var>level</var>&lt;=1, no change to the default behavior.
</p>
<p>when <var>level</var>=2, additional warnings will be issued for out of bounds
subscripts or offsets into one-element arrays;
</p>
<p>when <var>level</var>=3, in addition to <var>level</var>=2, additional warnings will be
issued for out of bounds subscripts or offsets into zero-length arrays.
</p>
<dl>
<dt><code>-Warray-bounds=1</code></dt>
<dd><p>This is the default warning level of <samp>-Warray-bounds</samp> and is enabled
by <samp>-Wall</samp>; higher levels are not, and must be explicitly requested.
</p>
</dd>
<dt><code>-Warray-bounds=2</code></dt>
<dd><p>This warning level also warns about the intermediate results of pointer
arithmetic that may yield out of bounds values. This warning level may
give a larger number of false positives and is deactivated by default.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Warray-compare</key>
    <name>Warn about comparisons between two operands of array type</name>
    <description>
      <![CDATA[<p>Warn about equality and relational comparisons between two operands of array
type.  This comparison was deprecated in C++20.  For example:
</p>
<div>
<pre>int arr1[5];
int arr2[5];
bool same = arr1 == arr2;
</pre></div>
<p><samp>-Warray-compare</samp> is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Warray-parameter</key>
    <name>Warn about mismatched declarations of array parameters and unsafe accesses to them</name>
    <description>
      <![CDATA[<p>Warn about redeclarations of functions involving parameters of array or
pointer types of inconsistent kinds or forms, and enable the detection
of out-of-bounds accesses to such parameters by warnings such as
<samp>-Warray-bounds</samp>.
</p>
<p>If the first function declaration uses the array form for a parameter
declaration, the bound specified
in the array is assumed to be the minimum number of elements expected to
be provided in calls to the function and the maximum number of elements
accessed by it.  Failing to provide arguments of sufficient size or accessing
more than the maximum number of elements may be diagnosed by warnings such
as <samp>-Warray-bounds</samp> or <samp>-Wstringop-overflow</samp>.
At level 1, the warning diagnoses inconsistencies
involving array parameters declared using the <code>T[static N]</code> form.
</p>
<p>For example, the warning triggers for the second declaration of <code>f</code>
because the first one with the keyword <code>static</code> specifies that
the array argument must have at least four elements, while the second
allows an array of any size to be passed to <code>f</code>.
</p>
<div>
<pre>void f (int[static 4]);
void f (int[]);           // warning (inconsistent array form)

void g (void)
{
  int *p = (int *)malloc (1 * sizeof (int));
  f (p);                  // warning (array too small)
  …
}
</pre></div>
<p>At level 2 the warning also triggers for redeclarations involving any other
inconsistency in array or pointer argument forms denoting array sizes.
Pointers and arrays of unspecified bound are considered equivalent and do
not trigger a warning.
</p>
<div>
<pre>void g (int*);
void g (int[]);     // no warning
void g (int[8]);    // warning (inconsistent array bound)
</pre></div>
<p><samp>-Warray-parameter=2</samp> is included in <samp>-Wall</samp>.  The
<samp>-Wvla-parameter</samp> option triggers warnings for similar inconsistencies
involving Variable Length Array arguments.
</p>
<p>The short form of the option <samp>-Warray-parameter</samp> is equivalent to
<samp>-Warray-parameter=2</samp>.  The negative form <samp>-Wno-array-parameter</samp>
is equivalent to <samp>-Warray-parameter=0</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wassign-intercept</key>
    <name>Warn whenever an Objective-C assignment is being intercepted by the garbage collector</name>
    <description>
      <![CDATA[<p>Warn whenever an Objective-C assignment is being intercepted by the
garbage collector.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wattribute-alias</key>
    <name>Warn about type safety and similar errors and mismatches in declarations with alias attributes</name>
    <description>
      <![CDATA[<p>Warn about declarations using the <code>alias</code> and similar attributes whose
target is incompatible with the type of the alias.
See <a href="Function-Attributes.html">Declaring Attributes of Functions</a>.
</p>
<dl>
<dt><code>-Wattribute-alias=1</code></dt>
<dd><p>The default warning level of the <samp>-Wattribute-alias</samp> option diagnoses
incompatibilities between the type of the alias declaration and that of its
target.  Such incompatibilities are typically indicative of bugs.
</p>
</dd>
<dt><code>-Wattribute-alias=2</code></dt>
<dd>
<p>At this level <samp>-Wattribute-alias</samp> also diagnoses cases where
the attributes of the alias declaration are more restrictive than the
attributes applied to its target.  These mismatches can potentially
result in incorrect code generation.  In other cases they may be
benign and could be resolved simply by adding the missing attribute to
the target.  For comparison, see the <samp>-Wmissing-attributes</samp>
option, which controls diagnostics when the alias declaration is less
restrictive than the target, rather than more restrictive.
</p>
<p>Attributes considered include <code>alloc_align</code>, <code>alloc_size</code>,
<code>cold</code>, <code>const</code>, <code>hot</code>, <code>leaf</code>, <code>malloc</code>,
<code>nonnull</code>, <code>noreturn</code>, <code>nothrow</code>, <code>pure</code>,
<code>returns_nonnull</code>, and <code>returns_twice</code>.
</p></dd>
</dl>
<p><samp>-Wattribute-alias</samp> is equivalent to <samp>-Wattribute-alias=1</samp>.
This is the default.  You can disable these warnings with either
<samp>-Wno-attribute-alias</samp> or <samp>-Wattribute-alias=0</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wattribute-warning</key>
    <name>Warn about uses of __attribute__((warning)) declarations</name>
    <description>
      <![CDATA[<p>Warn about usage of functions (see <a href="Function-Attributes.html">Declaring Attributes of Functions</a>)
declared with <code>warning</code> attribute.  By default, this warning is
enabled.  <samp>-Wno-attribute-warning</samp> can be used to disable the
warning or <samp>-Wno-error=attribute-warning</samp> can be used to
disable the error when compiled with <samp>-Werror</samp> flag.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wattributes</key>
    <name>Warn about inappropriate attribute usage</name>
    <description>
      <![CDATA[<p>Warn if an unexpected <code>__attribute__</code> is used, such as
unrecognized attributes, function attributes applied to variables,
etc.  This does not stop errors for incorrect use of supported
attributes.
</p>
<p>Warnings about ill-formed uses of standard attributes are upgraded to
errors by <samp>-pedantic-errors</samp>.
</p>
<p>Additionally, using <samp>-Wno-attributes=</samp>, it is possible to suppress
warnings about unknown scoped attributes (in C++11 and C23).  For example,
<samp>-Wno-attributes=vendor::attr</samp> disables warning about the following
declaration:
</p>
<div>
<pre>[[vendor::attr]] void f();
</pre></div>
<p>It is also possible to disable warning about all attributes in a namespace
using <samp>-Wno-attributes=vendor::</samp> which prevents warning about both
of these declarations:
</p>
<div>
<pre>[[vendor::safe]] void f();
[[vendor::unsafe]] void f2();
</pre></div>
<p>Note that <samp>-Wno-attributes=</samp> does not imply <samp>-Wno-attributes</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wbad-function-cast</key>
    <name>Warn about casting functions to incompatible types</name>
    <description>
      <![CDATA[<p>Warn when a function call is cast to a non-matching type.
For example, warn if a call to a function returning an integer type 
is cast to a pointer type.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wbidi-chars</key>
    <name>-Wbidi-chars=[none|unpaired|any|ucn] Warn about UTF-8 bidirectional control characters</name>
    <description>
      <![CDATA[<p>Warn about possibly misleading UTF-8 bidirectional control characters in
comments, string literals, character constants, and identifiers.  Such
characters can change left-to-right writing direction into right-to-left
(and vice versa), which can cause confusion between the logical order and
visual order.  This may be dangerous; for instance, it may seem that a piece
of code is not commented out, whereas it in fact is.
</p>
<p>There are three levels of warning supported by GCC.  The default is
<samp>-Wbidi-chars=unpaired</samp>, which warns about improperly terminated
bidi contexts.  <samp>-Wbidi-chars=none</samp> turns the warning off.
<samp>-Wbidi-chars=any</samp> warns about any use of bidirectional control
characters.
</p>
<p>By default, this warning does not warn about UCNs.  It is, however, possible
to turn on such checking by using <samp>-Wbidi-chars=unpaired,ucn</samp> or
<samp>-Wbidi-chars=any,ucn</samp>.  Using <samp>-Wbidi-chars=ucn</samp> is valid,
and is equivalent to <samp>-Wbidi-chars=unpaired,ucn</samp>, if no previous
<samp>-Wbidi-chars=any</samp> was specified.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wbool-compare</key>
    <name>Warn about boolean expression compared with an integer value different from true/false</name>
    <description>
      <![CDATA[<p>Warn about boolean expression compared with an integer value different from
<code>true</code>/<code>false</code>.  For instance, the following comparison is
always false:
</p><div>
<pre>int n = 5;
…
if ((n &gt; 1) == 2) { … }
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wbool-operation</key>
    <name>Warn about certain operations on boolean expressions</name>
    <description>
      <![CDATA[<p>Warn about suspicious operations on expressions of a boolean type.  For
instance, bitwise negation of a boolean is very likely a bug in the program.
For C, this warning also warns about incrementing or decrementing a boolean,
which rarely makes sense.  (In C++, decrementing a boolean is always invalid.
Incrementing a boolean is invalid in C++17, and deprecated otherwise.)
</p>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wbuiltin-declaration-mismatch</key>
    <name>Warn when a built-in function is declared with the wrong signature</name>
    <description>
      <![CDATA[<p>Warn if a built-in function is declared with an incompatible signature
or as a non-function, or when a built-in function declared with a type
that does not include a prototype is called with arguments whose promoted
types do not match those expected by the function.  When <samp>-Wextra</samp>
is specified, also warn when a built-in function that takes arguments is
declared without a prototype.  The <samp>-Wbuiltin-declaration-mismatch</samp>
warning is enabled by default.  To avoid the warning include the appropriate
header to bring the prototypes of built-in functions into scope.
</p>
<p>For example, the call to <code>memset</code> below is diagnosed by the warning
because the function expects a value of type <code>size_t</code> as its argument
but the type of <code>32</code> is <code>int</code>.  With <samp>-Wextra</samp>,
the declaration of the function is diagnosed as well.
</p><div>
<pre>extern void* memset ();
void f (void *d)
{
  memset (d, '\0', 32);
}
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wbuiltin-macro-redefined</key>
    <name>Warn when a built-in preprocessor macro is undefined or redefined</name>
    <description>
      <![CDATA[<p>Warn if certain built-in macros are redefined.  This suppresses
warnings for redefinition of <code>__TIMESTAMP__</code>, <code>__TIME__</code>,
<code>__DATE__</code>, <code>__FILE__</code>, and <code>__BASE_FILE__</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++-compat</key>
    <name>Warn about C constructs that are not in the common subset of C and C++</name>
    <description>
      <![CDATA[<p>Warn about ISO C constructs that are outside of the common subset of
ISO C and ISO C++, e.g. request for implicit conversion from
<code>void *</code> to a pointer to non-<code>void</code> type.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++11-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011</name>
    <description>
      <![CDATA[<p>Warn about C++ constructs whose meaning differs between ISO C++ 1998
and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords
in ISO C++ 2011.  This warning turns on <samp>-Wnarrowing</samp> and is
enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++11-extensions</key>
    <name>Warn about C++11 constructs in code compiled with an older standard</name>
    <description>
      <![CDATA[<p>Warn about C++11 constructs in code being compiled using
an older C++ standard.  Even without this option, some C++11 constructs
will only be diagnosed if <samp>-Wpedantic</samp> is used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++14-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014</name>
    <description>
      <![CDATA[<p>Warn about C++ constructs whose meaning differs between ISO C++ 2011
and ISO C++ 2014.  This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++14-extensions</key>
    <name>Warn about C++14 constructs in code compiled with an older standard</name>
    <description>
      <![CDATA[<p>Warn about C++14 constructs in code being compiled using
an older C++ standard.  Even without this option, some C++14 constructs
will only be diagnosed if <samp>-Wpedantic</samp> is used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++17-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017</name>
    <description>
      <![CDATA[<p>Warn about C++ constructs whose meaning differs between ISO C++ 2014
and ISO C++ 2017.  This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++17-extensions</key>
    <name>Warn about C++17 constructs in code compiled with an older standard</name>
    <description>
      <![CDATA[<p>Warn about C++17 constructs in code being compiled using
an older C++ standard.  Even without this option, some C++17 constructs
will only be diagnosed if <samp>-Wpedantic</samp> is used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++20-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 2017 and ISO C++ 2020</name>
    <description>
      <![CDATA[<p>Warn about C++ constructs whose meaning differs between ISO C++ 2017
and ISO C++ 2020.  This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++20-extensions</key>
    <name>Warn about C++20 constructs in code compiled with an older standard</name>
    <description>
      <![CDATA[<p>Warn about C++20 constructs in code being compiled using
an older C++ standard.  Even without this option, some C++20 constructs
will only be diagnosed if <samp>-Wpedantic</samp> is used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++23-extensions</key>
    <name>Warn about C++23 constructs in code compiled with an older standard</name>
    <description>
      <![CDATA[<p>Warn about C++23 constructs in code being compiled using
an older C++ standard.  Even without this option, some C++23 constructs
will only be diagnosed if <samp>-Wpedantic</samp> is used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc++26-extensions</key>
    <name>Warn about C++26 constructs in code compiled with an older standard</name>
    <description>
      <![CDATA[<p>Warn about C++26 constructs in code being compiled using
an older C++ standard.  Even without this option, some C++26 constructs
will only be diagnosed if <samp>-Wpedantic</samp> is used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc11-c23-compat</key>
    <name>Warn about features not present in ISO C11, but present in ISO C23</name>
    <description>
      <![CDATA[<p>Warn about features not present in ISO C11, but present in ISO C23.
For instance, warn about omitting the string in <code>_Static_assert</code>,
use of ‘<samp>[[]]</samp>’ syntax for attributes, use of decimal
floating-point types, and so on.  This option is independent of the
standards mode.  Warnings are disabled in the expression that follows
<code>__extension__</code>.  The name <samp>-Wc11-c2x-compat</samp> is
deprecated.
</p>
<p>When not compiling in C23 mode, these warnings are upgraded to errors
by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc90-c99-compat</key>
    <name>Warn about features not present in ISO C90, but present in ISO C99</name>
    <description>
      <![CDATA[<p>Warn about features not present in ISO C90, but present in ISO C99.
For instance, warn about use of variable length arrays, <code>long long</code>
type, <code>bool</code> type, compound literals, designated initializers, and so
on.  This option is independent of the standards mode.  Warnings are disabled
in the expression that follows <code>__extension__</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wc99-c11-compat</key>
    <name>Warn about features not present in ISO C99, but present in ISO C11</name>
    <description>
      <![CDATA[<p>Warn about features not present in ISO C99, but present in ISO C11.
For instance, warn about use of anonymous structures and unions,
<code>_Atomic</code> type qualifier, <code>_Thread_local</code> storage-class specifier,
<code>_Alignas</code> specifier, <code>Alignof</code> operator, <code>_Generic</code> keyword,
and so on.  This option is independent of the standards mode.  Warnings are
disabled in the expression that follows <code>__extension__</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcalloc-transposed-args</key>
    <name>Warn about suspicious calls to calloc-like functions where sizeof expression is the earlier size argument and not the latter</name>
    <description>
      <![CDATA[<p>Warn about calls to allocation functions decorated with attribute
<code>alloc_size</code> with two arguments, which use <code>sizeof</code> operator
as the earlier size argument and don’t use it as the later size argument.
This is a coding style warning.  The first argument to <code>calloc</code> is
documented to be number of elements in array, while the second argument
is size of each element, so <code>calloc (<var>n</var>, sizeof (int))</code> is preferred
over <code>calloc (sizeof (int), <var>n</var>)</code>.  If <code>sizeof</code> in the earlier
argument and not the latter is intentional, the warning can be suppressed
by using <code>calloc (sizeof (struct <var>S</var>) + 0, n)</code> or
<code>calloc (1 * sizeof (struct <var>S</var>), 4)</code> or using <code>sizeof</code> in the
later argument as well.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcannot-profile</key>
    <name>Warn when profiling instrumentation was requested, but could not be applied to a certain function</name>
    <description>
      <![CDATA[Warn when profiling instrumentation was requested, but could not be applied to a certain function]]>
      </description>
    </rule>
  <rule>
    <key>-Wcast-align</key>
    <name>Warn about pointer casts which increase alignment</name>
    <description>
      <![CDATA[<p>Warn whenever a pointer is cast such that the required alignment of the
target is increased.  For example, warn if a <code>char *</code> is cast to
an <code>int *</code> on machines where integers can only be accessed at
two- or four-byte boundaries.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcast-function-type</key>
    <name>Warn about casts between incompatible function types</name>
    <description>
      <![CDATA[<p>Warn when a function pointer is cast to an incompatible function pointer.
In a cast involving function types with a variable argument list only
the types of initial arguments that are provided are considered.
Any parameter of pointer-type matches any other pointer-type.  Any benign
differences in integral types are ignored, like <code>int</code> vs. <code>long</code>
on ILP32 targets.  Likewise type qualifiers are ignored.  The function
type <code>void (*) (void)</code> is special and matches everything, which can
be used to suppress this warning.
In a cast involving pointer to member types this warning warns whenever
the type cast is changing the pointer to member type.
This warning is enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcast-qual</key>
    <name>Warn about casts which discard qualifiers</name>
    <description>
      <![CDATA[<p>Warn whenever a pointer is cast so as to remove a type qualifier from
the target type.  For example, warn if a <code>const char *</code> is cast
to an ordinary <code>char *</code>.
</p>
<p>Also warn when making a cast that introduces a type qualifier in an
unsafe way.  For example, casting <code>char **</code> to <code>const char **</code>
is unsafe, as in this example:
</p>
<div>
<pre>  /* p is char ** value.  */
  const char **q = (const char **) p;
  /* Assignment of readonly string to const char * is OK.  */
  *q = "string";
  /* Now char** pointer points to read-only memory.  */
  **p = 'b';
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcast-user-defined</key>
    <name>Warn about a cast to reference type that does not use a related user-defined conversion function</name>
    <description>
      <![CDATA[<p>Warn when a cast to reference type does not involve a user-defined
conversion that the programmer might expect to be called.
</p>
<div>
<pre>struct A { operator const int&amp;(); } a;
auto r = (int&amp;)a; // warning
</pre></div>
<p>This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcatch-value</key>
    <name>Warn about catch handlers of non-reference type</name>
    <description>
      <![CDATA[<p>Warn about catch handlers that do not catch via reference.
With <samp>-Wcatch-value=1</samp> (or <samp>-Wcatch-value</samp> for short)
warn about polymorphic class types that are caught by value.
With <samp>-Wcatch-value=2</samp> warn about all class types that are caught
by value. With <samp>-Wcatch-value=3</samp> warn about all types that are
not caught by reference. <samp>-Wcatch-value</samp> is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wchanges-meaning</key>
    <name>Complain about a name being declared as a class member after a previous use of the same name</name>
    <description>
      <![CDATA[<p>C++ requires that unqualified uses of a name within a class have the
same meaning in the complete scope of the class, so declaring the name
after using it is ill-formed:
</p><div>
<pre>struct A;
struct B1 { A a; typedef A A; }; // warning, 'A' changes meaning
struct B2 { A a; struct A { }; }; // error, 'A' changes meaning
</pre></div>
<p>By default, the B1 case is only a warning because the two declarations
have the same type, while the B2 case is an error.  Both diagnostics
can be disabled with <samp>-Wno-changes-meaning</samp>.  Alternately, the
error case can be reduced to a warning with
<samp>-Wno-error=changes-meaning</samp> or <samp>-fpermissive</samp>.
</p>
<p>Both diagnostics are also suppressed by <samp>-fms-extensions</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wchar-subscripts</key>
    <name>Warn about subscripts whose type is "char"</name>
    <description>
      <![CDATA[<p>Warn if an array subscript has type <code>char</code>.  This is a common cause
of error, as programmers often forget that this type is signed on some
machines.
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wchkp</key>
    <name>Removed in GCC 9</name>
    <description>
      <![CDATA[Removed in GCC 9]]>
      </description>
    </rule>
  <rule>
    <key>-Wclass-conversion</key>
    <name>Warn when a conversion function will never be called due to the type it converts to</name>
    <description>
      <![CDATA[<p>Warn when a conversion function converts an
object to the same type, to a base class of that type, or to void; such
a conversion function will never be called.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wclass-memaccess</key>
    <name>Warn for unsafe raw memory writes to objects of class types</name>
    <description>
      <![CDATA[<p>Warn when the destination of a call to a raw memory function such as
<code>memset</code> or <code>memcpy</code> is an object of class type, and when writing
into such an object might bypass the class non-trivial or deleted constructor
or copy assignment, violate const-correctness or encapsulation, or corrupt
virtual table pointers.  Modifying the representation of such objects may
violate invariants maintained by member functions of the class.  For example,
the call to <code>memset</code> below is undefined because it modifies a non-trivial
class object and is, therefore, diagnosed.  The safe way to either initialize
or clear the storage of objects of such types is by using the appropriate
constructor or assignment operator, if one is available.
</p><div>
<pre>std::string str = "abc";
memset (&amp;str, 0, sizeof str);
</pre></div>
<p>The <samp>-Wclass-memaccess</samp> option is enabled by <samp>-Wall</samp>.
Explicitly casting the pointer to the class object to <code>void *</code> or
to a type that can be safely accessed by the raw memory function suppresses
the warning.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wclobbered</key>
    <name>Warn about variables that might be changed by "longjmp" or "vfork"</name>
    <description>
      <![CDATA[<p>Warn for variables that might be changed by <code>longjmp</code> or
<code>vfork</code>.  This warning is also enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcomma-subscript</key>
    <name>Warn about uses of a comma operator within a subscripting expression</name>
    <description>
      <![CDATA[<p>Warn about uses of a comma expression within a subscripting expression.
This usage was deprecated in C++20 and is going to be removed in C++23.
However, a comma expression wrapped in <code>( )</code> is not deprecated.  Example:
</p>
<div>
<div><pre>void f(int *a, int b, int c) {
    a[b,c];     // deprecated in C++20, invalid in C++23
    a[(b,c)];   // OK
}
</pre></div></div>
<p>In C++23 it is valid to have comma separated expressions in a subscript
when an overloaded subscript operator is found and supports the right
number and types of arguments.  G++ will accept the formerly valid syntax
for code that is not valid in C++23 but used to be valid but deprecated
in C++20 with a pedantic warning that can be disabled with
<samp>-Wno-comma-subscript</samp>.
</p>
<p>Enabled by default with <samp>-std=c++20</samp> unless <samp>-Wno-deprecated</samp>,
and with <samp>-std=c++23</samp> regardless of <samp>-Wno-deprecated</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp> in
C++23 mode or later.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcomment</key>
    <name>Warn about possibly nested block comments, and C++ comments spanning more than one physical line</name>
    <description>
      <![CDATA[<p>Warn whenever a comment-start sequence ‘<samp>/*</samp>’ appears in a ‘<samp>/*</samp>’
comment, or whenever a backslash-newline appears in a ‘<samp>//</samp>’ comment.
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcompare-distinct-pointer-types</key>
    <name>Warn if pointers of distinct types are compared without a cast</name>
    <description>
      <![CDATA[<p>Warn if pointers of distinct types are compared without a cast.  This
warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcomplain-wrong-lang</key>
    <name>Complain when a command-line option is valid, but not applicable to the current front end</name>
    <description>
      <![CDATA[<p>By default, language front ends complain when a command-line option is
valid, but not applicable to that front end.
This may be disabled with <samp>-Wno-complain-wrong-lang</samp>,
which is mostly useful when invoking a single compiler driver for
multiple source files written in different languages, for example:
</p>
<div>
<pre>$ g++ -fno-rtti a.cc b.f90
</pre></div>
<p>The driver <samp>g++</samp> invokes the C++ front end to compile <samp>a.cc</samp>
and the Fortran front end to compile <samp>b.f90</samp>.
The latter front end diagnoses
‘<samp>f951: Warning: command-line option '-fno-rtti' is valid for C++/D/ObjC++ but not for Fortran</samp>’,
which may be disabled with <samp>-Wno-complain-wrong-lang</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wconditionally-supported</key>
    <name>Warn for conditionally-supported constructs</name>
    <description>
      <![CDATA[<p>Warn for conditionally-supported (C++11 [intro.defs]) constructs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wconversion</key>
    <name>Warn for implicit type conversions that may change a value</name>
    <description>
      <![CDATA[<p>Warn for implicit conversions that may alter a value. This includes
conversions between real and integer, like <code>abs (x)</code> when
<code>x</code> is <code>double</code>; conversions between signed and unsigned,
like <code>unsigned ui = -1</code>; and conversions to smaller types, like
<code>sqrtf (M_PI)</code>. Do not warn for explicit casts like <code>abs
((int) x)</code> and <code>ui = (unsigned) -1</code>, or if the value is not
changed by the conversion like in <code>abs (2.0)</code>.  Warnings about
conversions between signed and unsigned integers can be disabled by
using <samp>-Wno-sign-conversion</samp>.
</p>
<p>For C++, also warn for confusing overload resolution for user-defined
conversions; and conversions that never use a type conversion
operator: conversions to <code>void</code>, the same type, a base class or a
reference to them. Warnings about conversions between signed and
unsigned integers are disabled by default in C++ unless
<samp>-Wsign-conversion</samp> is explicitly enabled.
</p>
<p>Warnings about conversion from arithmetic on a small type back to that
type are only given with <samp>-Warith-conversion</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wconversion-null</key>
    <name>Warn for converting NULL from/to a non-pointer type</name>
    <description>
      <![CDATA[<p>Warn for conversions between <code>NULL</code> and non-pointer
types. <samp>-Wconversion-null</samp> is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcoverage-invalid-line-number</key>
    <name>Warn in case a function ends earlier than it begins due to an invalid linenum macros</name>
    <description>
      <![CDATA[<p>Warn in case a function ends earlier than it begins due
to an invalid linenum macros.  The warning is emitted only
with <samp>--coverage</samp> enabled.
</p>
<p>By default, this warning is enabled and is treated as an
error.  <samp>-Wno-coverage-invalid-line-number</samp> can be used to disable the
warning or <samp>-Wno-error=coverage-invalid-line-number</samp> can be used to
disable the error.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcoverage-mismatch</key>
    <name>Warn in case profiles in -fprofile-use do not match</name>
    <description>
      <![CDATA[<p>Warn if feedback profiles do not match when using the
<samp>-fprofile-use</samp> option.
If a source file is changed between compiling with <samp>-fprofile-generate</samp>
and with <samp>-fprofile-use</samp>, the files with the profile feedback can fail
to match the source file and GCC cannot use the profile feedback
information.  By default, this warning is enabled and is treated as an
error.  <samp>-Wno-coverage-mismatch</samp> can be used to disable the
warning or <samp>-Wno-error=coverage-mismatch</samp> can be used to
disable the error.  Disabling the error for this warning can result in
poorly optimized code and is useful only in the
case of very minor changes such as bug fixes to an existing code-base.
Completely disabling the warning is not recommended.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcoverage-too-many-conditions</key>
    <name>Warn when a conditional has too many terms and condition coverage profiling gives up instrumenting the expression</name>
    <description>
      <![CDATA[<p>Warn if <samp>-fcondition-coverage</samp> is used and an expression have too many
terms and GCC gives up coverage.  Coverage is given up when there are more
terms in the conditional than there are bits in a <code>gcov_type_unsigned</code>.
This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wcpp</key>
    <name>Warn when a #warning directive is encountered</name>
    <description>
      <![CDATA[<p>Suppress warning messages emitted by <code>#warning</code> directives.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wctad-maybe-unsupported</key>
    <name>Warn when performing class template argument deduction on a type with no deduction guides</name>
    <description>
      <![CDATA[<p>Warn when performing class template argument deduction (CTAD) on a type with
no explicitly written deduction guides.  This warning will point out cases
where CTAD succeeded only because the compiler synthesized the implicit
deduction guides, which might not be what the programmer intended.  Certain
style guides allow CTAD only on types that specifically "opt-in"; i.e., on
types that are designed to support CTAD.  This warning can be suppressed with
the following pattern:
</p>
<div>
<pre>struct allow_ctad_t; // any name works
template &lt;typename T&gt; struct S {
  S(T) { }
};
// Guide with incomplete parameter type will never be considered.
S(allow_ctad_t) -&gt; S&lt;void&gt;;
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wctor-dtor-privacy</key>
    <name>Warn when all constructors and destructors are private</name>
    <description>
      <![CDATA[<p>Warn when a class seems unusable because all the constructors or
destructors in that class are private, and it has neither friends nor
public static member functions.  Also warn if there are no non-private
methods, and there’s at least one private member function that isn’t
a constructor or destructor.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdangling-else</key>
    <name>Warn about dangling else</name>
    <description>
      <![CDATA[<p>Warn about constructions where there may be confusion to which
<code>if</code> statement an <code>else</code> branch belongs.  Here is an example of
such a case:
</p>
<div>
<div><pre>{
  if (a)
    if (b)
      foo ();
  else
    bar ();
}
</pre></div></div>
<p>In C/C++, every <code>else</code> branch belongs to the innermost possible
<code>if</code> statement, which in this example is <code>if (b)</code>.  This is
often not what the programmer expected, as illustrated in the above
example by indentation the programmer chose.  When there is the
potential for this confusion, GCC issues a warning when this flag
is specified.  To eliminate the warning, add explicit braces around
the innermost <code>if</code> statement so there is no way the <code>else</code>
can belong to the enclosing <code>if</code>.  The resulting code
looks like this:
</p>
<div>
<div><pre>{
  if (a)
    {
      if (b)
        foo ();
      else
        bar ();
    }
}
</pre></div></div>
<p>This warning is enabled by <samp>-Wparentheses</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdangling-pointer</key>
    <name>Warn for uses of pointers to auto variables whose lifetime has ended</name>
    <description>
      <![CDATA[<p>Warn about uses of pointers (or C++ references) to objects with automatic
storage duration after their lifetime has ended.  This includes local
variables declared in nested blocks, compound literals and other unnamed
temporary objects.  In addition, warn about storing the address of such
objects in escaped pointers.  The warning is enabled at all optimization
levels but may yield different results with optimization than without.
</p>
<dl>
<dt><code>-Wdangling-pointer=1</code></dt>
<dd><p>At level 1, the warning diagnoses only unconditional uses of dangling pointers.
</p>
</dd>
<dt><code>-Wdangling-pointer=2</code></dt>
<dd><p>At level 2, in addition to unconditional uses the warning also diagnoses
conditional uses of dangling pointers.
</p></dd>
</dl>
<p>The short form <samp>-Wdangling-pointer</samp> is equivalent to
<samp>-Wdangling-pointer=2</samp>, while <samp>-Wno-dangling-pointer</samp> and
<samp>-Wdangling-pointer=0</samp> have the same effect of disabling the warnings.
<samp>-Wdangling-pointer=2</samp> is included in <samp>-Wall</samp>.
</p>
<p>This example triggers the warning at level 1; the address of the unnamed
temporary is unconditionally referenced outside of its scope.
</p>
<div>
<pre>char f (char c1, char c2, char c3)
{
  char *p;
  {
    p = (char[]) { c1, c2, c3 };
  }
  // warning: using dangling pointer 'p' to an unnamed temporary
  return *p;
}
</pre></div>
<p>In the following function the store of the address of the local variable
<code>x</code> in the escaped pointer <code>*p</code> triggers the warning at
level 1.
</p>
<div>
<pre>void g (int **p)
{
  int x = 7;
  // warning: storing the address of local variable 'x' in '*p'
  *p = &amp;x;
}
</pre></div>
<p>In this example, the array <var>a</var> is out of
scope when the pointer <var>s</var> is used.  Since the code that sets <code>s</code>
is conditional, the warning triggers at level 2.
</p>
<div>
<pre>extern void frob (const char *);
void h (char *s)
{
  if (!s)
    {
      char a[12] = "tmpname";
      s = a;
    }
  // warning: dangling pointer 's' to 'a' may be used
  frob (s);
}
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdangling-reference</key>
    <name>Warn when a reference is bound to a temporary whose lifetime has ended</name>
    <description>
      <![CDATA[<p>Warn when a reference is bound to a temporary whose lifetime has ended.
For example:
</p>
<div>
<pre>int n = 1;
const int&amp; r = std::max(n - 1, n + 1); // r is dangling
</pre></div>
<p>In the example above, two temporaries are created, one for each
argument, and a reference to one of the temporaries is returned.
However, both temporaries are destroyed at the end of the full
expression, so the reference <code>r</code> is dangling.  This warning
also detects dangling references in member initializer lists:
</p>
<div>
<pre>const int&amp; f(const int&amp; i) { return i; }
struct S {
  const int &amp;r; // r is dangling
  S() : r(f(10)) { }
};
</pre></div>
<p>Member functions are checked as well, but only their object argument:
</p>
<div>
<pre>struct S {
   const S&amp; self () { return *this; }
};
const S&amp; s = S().self(); // s is dangling
</pre></div>
<p>Certain functions are safe in this respect, for example <code>std::use_facet</code>:
they take and return a reference, but they don’t return one of its arguments,
which can fool the warning.  Such functions can be excluded from the warning
by wrapping them in a <code>#pragma</code>:
</p>
<div>
<pre>#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdangling-reference"
const T&amp; foo (const T&amp;) { … }
#pragma GCC diagnostic pop
</pre></div>
<p>The <code>#pragma</code> can also surround the class; in that case, the warning
will be disabled for all the member functions.
</p>
<p><samp>-Wdangling-reference</samp> also warns about code like
</p>
<div>
<pre>auto p = std::minmax(1, 2);
</pre></div>
<p>where <code>std::minmax</code> returns <code>std::pair&lt;const int&amp;, const int&amp;&gt;</code>, and
both references dangle after the end of the full expression that contains
the call to <code>std::minmax</code>.
</p>
<p>The warning does not warn for <code>std::span</code>-like classes.  We consider
classes of the form:
</p>
<div>
<pre>template&lt;typename T&gt;
struct Span {
  T* data_;
  std::size len_;
};
</pre></div>
<p>as <code>std::span</code>-like; that is, the class is a non-union class
that has a pointer data member and a trivial destructor.
</p>
<p>The warning can be disabled by using the <code>gnu::no_dangling</code> attribute
(see <a href="C_002b_002b-Attributes.html">C++-Specific Variable, Function, and Type Attributes</a>).
</p>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdate-time</key>
    <name>Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage</name>
    <description>
      <![CDATA[<p>Warn when macros <code>__TIME__</code>, <code>__DATE__</code> or <code>__TIMESTAMP__</code>
are encountered as they might prevent bit-wise-identical reproducible
compilations.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeclaration-after-statement</key>
    <name>Warn when a declaration is found after a statement</name>
    <description>
      <![CDATA[<p>Warn when a declaration is found after a statement in a block.  This
construct, known from C++, was introduced with ISO C99 and is by default
allowed in GCC.  It is not supported by ISO C90.  See <a href="Mixed-Labels-and-Declarations.html">Mixed Declarations, Labels and Code</a>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeclaration-missing-parameter-type</key>
    <name>Warn for missing parameter types in function declarations</name>
    <description>
      <![CDATA[<p>Warn if a function declaration contains a parameter name without
a type.  Such function declarations do not provide a function prototype
and prevent most type checking in function calls.
</p>
<p>This warning is enabled by default.  In C99 and later dialects of C, it
is treated as an error.  The error can be downgraded to a warning using
<samp>-fpermissive</samp> (along with certain other errors), or for this
error alone, with <samp>-Wno-error=declaration-missing-parameter-type</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdelete-incomplete</key>
    <name>Warn when deleting a pointer to incomplete type</name>
    <description>
      <![CDATA[<p>Warn when deleting a pointer to incomplete type, which may cause
undefined behavior at runtime.  This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdelete-non-virtual-dtor</key>
    <name>Warn about deleting polymorphic objects with non-virtual destructors</name>
    <description>
      <![CDATA[<p>Warn when <code>delete</code> is used to destroy an instance of a class that
has virtual functions and non-virtual destructor. It is unsafe to delete
an instance of a derived class through a pointer to a base class if the
base class does not have a virtual destructor.  This warning is enabled
by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeprecated</key>
    <name>Warn if a deprecated compiler feature, class, method, or field is used</name>
    <description>
      <![CDATA[<p>Warn about usage of deprecated features.  See <a href="Deprecated-Features.html">Deprecated Features</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeprecated-copy</key>
    <name>Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation</name>
    <description>
      <![CDATA[<p>Warn that the implicit declaration of a copy constructor or copy
assignment operator is deprecated if the class has a user-provided
copy constructor or copy assignment operator, in C++11 and up.  This
warning is enabled by <samp>-Wextra</samp>.  With
<samp>-Wdeprecated-copy-dtor</samp>, also deprecate if the class has a
user-provided destructor.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeprecated-copy-dtor</key>
    <name>Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation or destructor</name>
    <description>
      <![CDATA[Mark implicitly-declared copy operations as deprecated if the class has a user-provided copy operation or destructor]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeprecated-declarations</key>
    <name>Warn about uses of __attribute__((deprecated)) declarations</name>
    <description>
      <![CDATA[<p>Warn about uses of functions (see <a href="Function-Attributes.html">Declaring Attributes of Functions</a>),
variables (see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>), and types (see <a href="Type-Attributes.html">Specifying Attributes of Types</a>) marked as deprecated by using the <code>deprecated</code>
attribute.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeprecated-enum-enum-conversion</key>
    <name>Warn about deprecated arithmetic conversions on operands of enumeration types</name>
    <description>
      <![CDATA[<p>Disable the warning about the case when the usual arithmetic conversions
are applied on operands where one is of enumeration type and the other is
of a different enumeration type.  This conversion was deprecated in C++20.
For example:
</p>
<div>
<pre>enum E1 { e };
enum E2 { f };
int k = f - e;
</pre></div>
<p><samp>-Wdeprecated-enum-enum-conversion</samp> is enabled by default with
<samp>-std=c++20</samp>.  In pre-C++20 dialects, this warning can be enabled
by <samp>-Wenum-conversion</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdeprecated-enum-float-conversion</key>
    <name>Warn about deprecated arithmetic conversions on operands where one is of enumeration type and the other is of a floating-point type</name>
    <description>
      <![CDATA[<p>Disable the warning about the case when the usual arithmetic conversions
are applied on operands where one is of enumeration type and the other is
of a floating-point type.  This conversion was deprecated in C++20.  For
example:
</p>
<div>
<pre>enum E1 { e };
enum E2 { f };
bool b = e &lt;= 3.7;
</pre></div>
<p><samp>-Wdeprecated-enum-float-conversion</samp> is enabled by default with
<samp>-std=c++20</samp>.  In pre-C++20 dialects, this warning can be enabled
by <samp>-Wenum-conversion</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdesignated-init</key>
    <name>Warn about positional initialization of structs requiring designated initializers</name>
    <description>
      <![CDATA[<p>Suppress warnings when a positional initializer is used to initialize
a structure that has been marked with the <code>designated_init</code>
attribute.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdisabled-optimization</key>
    <name>Warn when an optimization pass is disabled</name>
    <description>
      <![CDATA[<p>Warn if a requested optimization pass is disabled.  This warning does
not generally indicate that there is anything wrong with your code; it
merely indicates that GCC’s optimizers are unable to handle the code
effectively.  Often, the problem is that your code is too big or too
complex; GCC refuses to optimize programs when the optimization
itself is likely to take inordinate amounts of time.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdiscarded-array-qualifiers</key>
    <name>Warn if qualifiers on arrays which are pointer targets are discarded</name>
    <description>
      <![CDATA[<p>Warn if type qualifiers on arrays which are pointer targets
are being discarded.  Typically, the compiler warns if a
<code>const int (*)[]</code> variable is passed to a function that
takes a <code>int (*)[]</code> parameter.  This option can be used to
suppress such a warning.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdiscarded-qualifiers</key>
    <name>Warn if type qualifiers on pointers are discarded</name>
    <description>
      <![CDATA[<p>Warn if type qualifiers on pointers are being discarded.
Typically, the compiler warns if a <code>const char *</code> variable is
passed to a function that takes a <code>char *</code> parameter.  This option
can be used to suppress such a warning.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdiv-by-zero</key>
    <name>Warn about compile-time integer division by zero</name>
    <description>
      <![CDATA[<p>Warn about compile-time integer division by zero.  Floating-point
division by zero is not warned about, as it can be a legitimate way of
obtaining infinities and NaNs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wdouble-promotion</key>
    <name>Warn about implicit conversions from "float" to "double"</name>
    <description>
      <![CDATA[<p>Give a warning when a value of type <code>float</code> is implicitly
promoted to <code>double</code>.  CPUs with a 32-bit “single-precision”
floating-point unit implement <code>float</code> in hardware, but emulate
<code>double</code> in software.  On such a machine, doing computations
using <code>double</code> values is much more expensive because of the
overhead required for software emulation.
</p>
<p>It is easy to accidentally do computations with <code>double</code> because
floating-point literals are implicitly of type <code>double</code>.  For
example, in:
</p><div>
<div><pre>float area(float radius)
{
   return 3.14159 * radius * radius;
}
</pre></div></div>
<p>the compiler performs the entire computation with <code>double</code>
because the floating-point literal is a <code>double</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wduplicate-decl-specifier</key>
    <name>Warn when a declaration has duplicate const, volatile, restrict or _Atomic specifier</name>
    <description>
      <![CDATA[<p>Warn if a declaration has duplicate <code>const</code>, <code>volatile</code>,
<code>restrict</code> or <code>_Atomic</code> specifier.  This warning is enabled by
<samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wduplicated-branches</key>
    <name>Warn about duplicated branches in if-else statements</name>
    <description>
      <![CDATA[<p>Warn when an if-else has identical branches.  This warning detects cases like
</p><div>
<pre>if (p != NULL)
  return 0;
else
  return 0;
</pre></div>
<p>It doesn’t warn when both branches contain just a null statement.  This warning
also warn for conditional operators:
</p><div>
<pre>  int i = x ? *p : *p;
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wduplicated-cond</key>
    <name>Warn about duplicated conditions in an if-else-if chain</name>
    <description>
      <![CDATA[<p>Warn about duplicated conditions in an if-else-if chain.  For instance,
warn for the following code:
</p><div>
<pre>if (p-&gt;q != NULL) { … }
else if (p-&gt;q != NULL) { … }
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Weffc++</key>
    <name>Warn about violations of Effective C++ style rules</name>
    <description>
      <![CDATA[<p>Warn about violations of the following style guidelines from Scott Meyers’
<cite>Effective C++</cite> series of books:
</p>
<ul>
<li>Define a copy constructor and an assignment operator for classes
with dynamically-allocated memory.

</li><li>Prefer initialization to assignment in constructors.

</li><li>Have <code>operator=</code> return a reference to <code>*this</code>.

</li><li>Don’t try to return a reference when you must return an object.

</li><li>Distinguish between prefix and postfix forms of increment and
decrement operators.

</li><li>Never overload <code>&amp;&amp;</code>, <code>||</code>, or <code>,</code>.

</li></ul>
<p>This option also enables <samp>-Wnon-virtual-dtor</samp>, which is also
one of the effective C++ recommendations.  However, the check is
extended to warn about the lack of virtual destructor in accessible
non-polymorphic bases classes too.
</p>
<p>When selecting this option, be aware that the standard library
headers do not obey all of these guidelines; use ‘<samp>grep -v</samp>’
to filter out those warnings.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Welaborated-enum-base</key>
    <name>Warn if an additional enum-base is used in an elaborated-type-specifier</name>
    <description>
      <![CDATA[<p>For C++11 and above, warn if an (invalid) additional enum-base is used
in an elaborated-type-specifier.  That is, if an enum with given
underlying type and no enumerator list is used in a declaration other
than just a standalone declaration of the enum.  Enabled by default.  This
warning is upgraded to an error with -pedantic-errors.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wempty-body</key>
    <name>Warn about an empty body in an if or else statement</name>
    <description>
      <![CDATA[<p>Warn if an empty body occurs in an <code>if</code>, <code>else</code> or <code>do
while</code> statement.  This warning is also enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wendif-labels</key>
    <name>Warn about stray tokens after #else and #endif</name>
    <description>
      <![CDATA[<p>Warn whenever an <code>#else</code> or an <code>#endif</code> are followed by text.
This sometimes happens in older programs with code of the form
</p>
<div>
<pre>#if FOO
…
#else FOO
…
#endif FOO
</pre></div>
<p>The second and third <code>FOO</code> should be in comments.
This warning is on by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wenum-compare</key>
    <name>Warn about comparison of different enum types</name>
    <description>
      <![CDATA[<p>Warn about a comparison between values of different enumerated types.
In C++ enumerated type mismatches in conditional expressions are also
diagnosed and the warning is enabled by default.  In C this warning is 
enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wenum-conversion</key>
    <name>Warn about implicit conversion of enum types</name>
    <description>
      <![CDATA[<p>Warn when a value of enumerated type is implicitly converted to a 
different enumerated type.  This warning is enabled by <samp>-Wextra</samp>
in C.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wenum-int-mismatch</key>
    <name>Warn about enum/integer type mismatches</name>
    <description>
      <![CDATA[<p>Warn about mismatches between an enumerated type and an integer type in
declarations.  For example:
</p>
<div>
<pre>enum E { l = -1, z = 0, g = 1 };
int foo(void);
enum E foo(void);
</pre></div>
<p>In C, an enumerated type is compatible with <code>char</code>, a signed
integer type, or an unsigned integer type.  However, since the choice
of the underlying type of an enumerated type is implementation-defined,
such mismatches may cause portability issues.  In C++, such mismatches
are an error.  In C, this warning is enabled by <samp>-Wall</samp> and
<samp>-Wc++-compat</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wexceptions</key>
    <name>Warn when an exception handler is shadowed by another handler</name>
    <description>
      <![CDATA[<p>Disable the warning about the case when an exception handler is shadowed by
another handler, which can point out a wrong ordering of exception handlers.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wexpansion-to-defined</key>
    <name>Warn if "defined" is used outside #if</name>
    <description>
      <![CDATA[<p>Warn whenever ‘<samp>defined</samp>’ is encountered in the expansion of a macro
(including the case where the macro is expanded by an ‘<samp>#if</samp>’ directive).
Such usage is not portable.
This warning is also enabled by <samp>-Wpedantic</samp> and <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wextra</key>
    <name>Print extra (possibly unwanted) warnings</name>
    <description>
      <![CDATA[<p>The option <samp>-Wextra</samp> also prints warning messages for the
following cases:
</p>
<ul>
<li>A pointer is compared against integer zero with <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>.

</li><li>(C++ only) An enumerator and a non-enumerator both appear in a
conditional expression.

</li><li>(C++ only) Ambiguous virtual bases.

</li><li>(C++ only) Subscripting an array that has been declared <code>register</code>.

</li><li>(C++ only) Taking the address of a variable that has been declared
<code>register</code>.

</li><li>(C++ only) A base class is not initialized in the copy constructor
of a derived class.

</li></ul>]]>
      </description>
    </rule>
  <rule>
    <key>-Wextra-semi</key>
    <name>Warn about semicolon after in-class function definition</name>
    <description>
      <![CDATA[<p>Warn about redundant semicolons after in-class function definitions.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wflex-array-member-not-at-end</key>
    <name>Warn when a structure containing a C99 flexible array member as the last field is not at the end of another structure</name>
    <description>
      <![CDATA[<p>Warn when a structure containing a C99 flexible array member as the last
field is not at the end of another structure.
This warning warns e.g. about
</p>
<div>
<pre>struct flex  { int length; char data[]; };
struct mid_flex { int m; struct flex flex_data; int n; };
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wfloat-conversion</key>
    <name>Warn for implicit type conversions that cause loss of floating point precision</name>
    <description>
      <![CDATA[<p>Warn for implicit conversions that reduce the precision of a real value.
This includes conversions from real to integer, and from higher precision
real to lower precision real values.  This option is also enabled by
<samp>-Wconversion</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wfloat-equal</key>
    <name>Warn if testing floating point numbers for equality</name>
    <description>
      <![CDATA[<p>Warn if floating-point values are used in equality comparisons.
</p>
<p>The idea behind this is that sometimes it is convenient (for the
programmer) to consider floating-point values as approximations to
infinitely precise real numbers.  If you are doing this, then you need
to compute (by analyzing the code, or in some other way) the maximum or
likely maximum error that the computation introduces, and allow for it
when performing comparisons (and when producing output, but that’s a
different problem).  In particular, instead of testing for equality, you
should check to see whether the two values have ranges that overlap; and
this is done with the relational operators, so equality comparisons are
probably mistaken.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat</key>
    <name>Warn about printf/scanf/strftime/strfmon format string anomalies</name>
    <description>
      <![CDATA[<p>Check calls to <code>printf</code> and <code>scanf</code>, etc., to make sure that
the arguments supplied have types appropriate to the format string
specified, and that the conversions specified in the format string make
sense.  This includes standard functions, and others specified by format
attributes (see <a href="Function-Attributes.html">Declaring Attributes of Functions</a>), in the <code>printf</code>,
<code>scanf</code>, <code>strftime</code> and <code>strfmon</code> (an X/Open extension,
not in the C standard) families (or other target-specific families).
Which functions are checked without format attributes having been
specified depends on the standard version selected, and such checks of
functions without the attribute specified are disabled by
<samp>-ffreestanding</samp> or <samp>-fno-builtin</samp>.
</p>
<p>The formats are checked against the format features supported by GNU
libc version 2.2.  These include all ISO C90 and C99 features, as well
as features from the Single Unix Specification and some BSD and GNU
extensions.  Other library implementations may not support all these
features; GCC does not support warning about features that go beyond a
particular library’s limitations.  However, if <samp>-Wpedantic</samp> is used
with <samp>-Wformat</samp>, warnings are given about format features not
in the selected standard version (but not for <code>strfmon</code> formats,
since those are not in any version of the C standard).  See <a href="C-Dialect-Options.html">Options Controlling C Dialect</a>.
</p>
<dl>
<dt><a id="index-Wformat_003d1"></a>
<a id="index-Wformat-1"></a><span><code>-Wformat=1</code><a href="#index-Wformat-1"> ¶</a></span></dt>
<dt><code>-Wformat</code></dt>
<dd><p>Option <samp>-Wformat</samp> is equivalent to <samp>-Wformat=1</samp>, and
<samp>-Wno-format</samp> is equivalent to <samp>-Wformat=0</samp>.  Since
<samp>-Wformat</samp> also checks for null format arguments for several
functions, <samp>-Wformat</samp> also implies <samp>-Wnonnull</samp>.  Some
aspects of this level of format checking can be disabled by the
options: <samp>-Wno-format-contains-nul</samp>,
<samp>-Wno-format-extra-args</samp>, and <samp>-Wno-format-zero-length</samp>.
<samp>-Wformat</samp> is enabled by <samp>-Wall</samp>.
</p>
</dd>
<dt><a id="index-Wformat_003d2"></a><span><code>-Wformat=2</code><a href="#index-Wformat_003d2"> ¶</a></span></dt>
<dd><p>Enable <samp>-Wformat</samp> plus additional format checks.  Currently
equivalent to <samp>-Wformat -Wformat-nonliteral -Wformat-security
-Wformat-y2k</samp>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-contains-nul</key>
    <name>Warn about format strings that contain NUL bytes</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, do not warn about format strings that
contain NUL bytes.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-diag</key>
    <name>Warn about GCC format strings with strings unsuitable for diagnostics</name>
    <description>
      <![CDATA[Warn about GCC format strings with strings unsuitable for diagnostics]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-extra-args</key>
    <name>Warn if passing too many arguments to a function for its format string</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, do not warn about excess arguments to a
<code>printf</code> or <code>scanf</code> format function.  The C standard specifies
that such arguments are ignored.
</p>
<p>Where the unused arguments lie between used arguments that are
specified with ‘<samp>$</samp>’ operand number specifications, normally
warnings are still given, since the implementation could not know what
type to pass to <code>va_arg</code> to skip the unused arguments.  However,
in the case of <code>scanf</code> formats, this option suppresses the
warning if the unused arguments are all pointers, since the Single
Unix Specification says that such unused arguments are allowed.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-nonliteral</key>
    <name>Warn about format strings that are not literals</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, also warn if the format string is not a
string literal and so cannot be checked, unless the format function
takes its format arguments as a <code>va_list</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-overflow</key>
    <name>Warn about function calls with format strings that write past the end of the destination region</name>
    <description>
      <![CDATA[<p>Warn about calls to formatted input/output functions such as <code>sprintf</code>
and <code>vsprintf</code> that might overflow the destination buffer.  When the
exact number of bytes written by a format directive cannot be determined
at compile-time it is estimated based on heuristics that depend on the
<var>level</var> argument and on optimization.  While enabling optimization
will in most cases improve the accuracy of the warning, it may also
result in false positives.
</p>
<dl>
<dt><a id="index-Wno-format-overflow-1"></a>
<a id="index-Wformat-overflow-1"></a><span><code>-Wformat-overflow</code><a href="#index-Wformat-overflow-1"> ¶</a></span></dt>
<dt><code>-Wformat-overflow=1</code></dt>
<dd><p>Level <var>1</var> of <samp>-Wformat-overflow</samp> enabled by <samp>-Wformat</samp>
employs a conservative approach that warns only about calls that most
likely overflow the buffer.  At this level, numeric arguments to format
directives with unknown values are assumed to have the value of one, and
strings of unknown length to be empty.  Numeric arguments that are known
to be bounded to a subrange of their type, or string arguments whose output
is bounded either by their directive’s precision or by a finite set of
string literals, are assumed to take on the value within the range that
results in the most bytes on output.  For example, the call to <code>sprintf</code>
below is diagnosed because even with both <var>a</var> and <var>b</var> equal to zero,
the terminating NUL character (<code>'\0'</code>) appended by the function
to the destination buffer will be written past its end.  Increasing
the size of the buffer by a single byte is sufficient to avoid the
warning, though it may not be sufficient to avoid the overflow.
</p>
<div>
<pre>void f (int a, int b)
{
  char buf [13];
  sprintf (buf, "a = %i, b = %i\n", a, b);
}
</pre></div>
</dd>
<dt><code>-Wformat-overflow=2</code></dt>
<dd><p>Level <var>2</var> warns also about calls that might overflow the destination
buffer given an argument of sufficient length or magnitude.  At level
<var>2</var>, unknown numeric arguments are assumed to have the minimum
representable value for signed types with a precision greater than 1, and
the maximum representable value otherwise.  Unknown string arguments whose
length cannot be assumed to be bounded either by the directive’s precision,
or by a finite set of string literals they may evaluate to, or the character
array they may point to, are assumed to be 1 character long.
</p>
<p>At level <var>2</var>, the call in the example above is again diagnosed, but
this time because with <var>a</var> equal to a 32-bit <code>INT_MIN</code> the first
<code>%i</code> directive will write some of its digits beyond the end of
the destination buffer.  To make the call safe regardless of the values
of the two variables, the size of the destination buffer must be increased
to at least 34 bytes.  GCC includes the minimum size of the buffer in
an informational note following the warning.
</p>
<p>An alternative to increasing the size of the destination buffer is to
constrain the range of formatted values.  The maximum length of string
arguments can be bounded by specifying the precision in the format
directive.  When numeric arguments of format directives can be assumed
to be bounded by less than the precision of their type, choosing
an appropriate length modifier to the format specifier will reduce
the required buffer size.  For example, if <var>a</var> and <var>b</var> in the
example above can be assumed to be within the precision of
the <code>short int</code> type then using either the <code>%hi</code> format
directive or casting the argument to <code>short</code> reduces the maximum
required size of the buffer to 24 bytes.
</p>
<div>
<pre>void f (int a, int b)
{
  char buf [23];
  sprintf (buf, "a = %hi, b = %i\n", a, (short)b);
}
</pre></div>
</dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-security</key>
    <name>Warn about possible security problems with format functions</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, also warn about uses of format
functions that represent possible security problems.  At present, this
warns about calls to <code>printf</code> and <code>scanf</code> functions where the
format string is not a string literal and there are no format arguments,
as in <code>printf (foo);</code>.  This may be a security hole if the format
string came from untrusted input and contains ‘<samp>%n</samp>’.  (This is
currently a subset of what <samp>-Wformat-nonliteral</samp> warns about, but
in future warnings may be added to <samp>-Wformat-security</samp> that are not
included in <samp>-Wformat-nonliteral</samp>.)
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-signedness</key>
    <name>Warn about sign differences with format functions</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, also warn if the format string
requires an unsigned argument and the argument is signed and vice versa.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-truncation</key>
    <name>Warn about calls to snprintf and similar functions that truncate output</name>
    <description>
      <![CDATA[<p>Warn about calls to formatted input/output functions such as <code>snprintf</code>
and <code>vsnprintf</code> that might result in output truncation.  When the exact
number of bytes written by a format directive cannot be determined at
compile-time it is estimated based on heuristics that depend on
the <var>level</var> argument and on optimization.  While enabling optimization
will in most cases improve the accuracy of the warning, it may also result
in false positives.  Except as noted otherwise, the option uses the same
logic <samp>-Wformat-overflow</samp>.
</p>
<dl>
<dt><a id="index-Wno-format-truncation-1"></a>
<a id="index-Wformat-truncation-1"></a><span><code>-Wformat-truncation</code><a href="#index-Wformat-truncation-1"> ¶</a></span></dt>
<dt><code>-Wformat-truncation=1</code></dt>
<dd><p>Level <var>1</var> of <samp>-Wformat-truncation</samp> enabled by <samp>-Wformat</samp>
employs a conservative approach that warns only about calls to bounded
functions whose return value is unused and that will most likely result
in output truncation.
</p>
</dd>
<dt><code>-Wformat-truncation=2</code></dt>
<dd><p>Level <var>2</var> warns also about calls to bounded functions whose return
value is used and that might result in truncation given an argument of
sufficient length or magnitude.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-y2k</key>
    <name>Warn about strftime formats yielding 2-digit years</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, also warn about <code>strftime</code>
formats that may yield only a two-digit year.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wformat-zero-length</key>
    <name>Warn about zero-length formats</name>
    <description>
      <![CDATA[<p>If <samp>-Wformat</samp> is specified, do not warn about zero-length formats.
The C standard specifies that zero-length formats are allowed.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wframe-address</key>
    <name>Warn when __builtin_frame_address or __builtin_return_address is used unsafely</name>
    <description>
      <![CDATA[<p>Warn when the ‘<samp>__builtin_frame_address</samp>’ or ‘<samp>__builtin_return_address</samp>’
is called with an argument greater than 0.  Such calls may return indeterminate
values or crash the program.  The warning is included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wframe-larger-than</key>
    <name>Warn if a function's stack frame requires in excess of &lt;byte-size&gt;</name>
    <description>
      <![CDATA[<p>Warn if the size of a function frame exceeds <var>byte-size</var>.
The computation done to determine the stack frame size is approximate
and not conservative.
The actual requirements may be somewhat greater than <var>byte-size</var>
even if you do not get a warning.  In addition, any space allocated
via <code>alloca</code>, variable-length arrays, or related constructs
is not included by the compiler when determining
whether or not to issue a warning.
<samp>-Wframe-larger-than=</samp>‘<samp>PTRDIFF_MAX</samp>’ is enabled by default.
Warnings controlled by the option can be disabled either by specifying
<var>byte-size</var> of ‘<samp>SIZE_MAX</samp>’ or more or by
<samp>-Wno-frame-larger-than</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wfree-nonheap-object</key>
    <name>Warn when attempting to free a non-heap object</name>
    <description>
      <![CDATA[<p>Warn when attempting to deallocate an object that was either not allocated
on the heap, or by using a pointer that was not returned from a prior call
to the corresponding allocation function.  For example, because the call
to <code>stpcpy</code> returns a pointer to the terminating nul character and
not to the beginning of the object, the call to <code>free</code> below is
diagnosed.
</p>
<div>
<pre>void f (char *p)
{
  p = stpcpy (p, "abc");
  // ...
  free (p);   // warning
}
</pre></div>
<p><samp>-Wfree-nonheap-object</samp> is included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wglobal-module</key>
    <name>Warn about the global module fragment not containing only preprocessing directives</name>
    <description>
      <![CDATA[<p>Disable the diagnostic for when the global module fragment of a module
unit does not consist only of preprocessor directives.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Whardened</key>
    <name>Warn when -fhardened did not enable an option from its set</name>
    <description>
      <![CDATA[<p>Warn when <samp>-fhardened</samp> did not enable an option from its set (for
which see <samp>-fhardened</samp>).  For instance, using <samp>-fhardened</samp>
and <samp>-fstack-protector</samp> at the same time on the command line causes
<samp>-Whardened</samp> to warn because <samp>-fstack-protector-strong</samp> is
not enabled by <samp>-fhardened</samp>.
</p>
<p>This warning is enabled by default and has effect only when <samp>-fhardened</samp>
is enabled.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wif-not-aligned</key>
    <name>Warn when the field in a struct is not aligned</name>
    <description>
      <![CDATA[<p>Control if warnings triggered by the <code>warn_if_not_aligned</code> attribute
should be issued.  These warnings are enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wignored-attributes</key>
    <name>Warn whenever attributes are ignored</name>
    <description>
      <![CDATA[<p>This option controls warnings when an attribute is ignored.
This is different from the
<samp>-Wattributes</samp> option in that it warns whenever the compiler decides
to drop an attribute, not that the attribute is either unknown, used in a
wrong place, etc.  This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wignored-qualifiers</key>
    <name>Warn whenever type qualifiers are ignored</name>
    <description>
      <![CDATA[<p>Warn if the return type of a function has a type qualifier
such as <code>const</code>.  For ISO C such a type qualifier has no effect,
since the value returned by a function is not an lvalue.
For C++, the warning is only emitted for scalar types or <code>void</code>.
ISO C prohibits qualified <code>void</code> return types on function
definitions, so such return types always receive a warning
even without this option.
</p>
<p>This warning is also enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wimplicit</key>
    <name>Warn about implicit declarations</name>
    <description>
      <![CDATA[<p>Same as <samp>-Wimplicit-int</samp> and <samp>-Wimplicit-function-declaration</samp>.
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wimplicit-fallthrough</key>
    <name>Warn when a switch case falls through</name>
    <description>
      <![CDATA[<p>Warn when a switch case falls through.  For example:
</p>
<div>
<div><pre>switch (cond)
  {
  case 1:
    a = 1;
    break;
  case 2:
    a = 2;
  case 3:
    a = 3;
    break;
  }
</pre></div></div>
<p>This warning does not warn when the last statement of a case cannot
fall through, e.g. when there is a return statement or a call to function
declared with the noreturn attribute.  <samp>-Wimplicit-fallthrough=</samp>
also takes into account control flow statements, such as ifs, and only
warns when appropriate.  E.g.
</p>
<div>
<div><pre>switch (cond)
  {
  case 1:
    if (i &gt; 3) {
      bar (5);
      break;
    } else if (i &lt; 1) {
      bar (0);
    } else
      return;
  default:
    …
  }
</pre></div></div>
<p>Since there are occasions where a switch case fall through is desirable,
GCC provides an attribute, <code>__attribute__ ((fallthrough))</code>, that is
to be used along with a null statement to suppress this warning that
would normally occur:
</p>
<div>
<div><pre>switch (cond)
  {
  case 1:
    bar (0);
    __attribute__ ((fallthrough));
  default:
    …
  }
</pre></div></div>
<p>C++17 provides a standard way to suppress the <samp>-Wimplicit-fallthrough</samp>
warning using <code>[[fallthrough]];</code> instead of the GNU attribute.  In C++11
or C++14 users can use <code>[[gnu::fallthrough]];</code>, which is a GNU extension.
Instead of these attributes, it is also possible to add a fallthrough comment
to silence the warning.  The whole body of the C or C++ style comment should
match the given regular expressions listed below.  The option argument <var>n</var>
specifies what kind of comments are accepted:
</p>
<ul>
<li><samp>-Wimplicit-fallthrough=0</samp> disables the warning altogether.

</li><li><samp>-Wimplicit-fallthrough=1</samp> matches <code>.*</code> regular
expression, any comment is used as fallthrough comment.

</li><li><samp>-Wimplicit-fallthrough=2</samp> case insensitively matches
<code>.*falls?[ \t-]*thr(ough|u).*</code> regular expression.

</li><li><samp>-Wimplicit-fallthrough=3</samp> case sensitively matches one of the
following regular expressions:

<ul>
<li><code>-fallthrough</code>
</li><li><code>@fallthrough@</code>
</li><li><code>lint -fallthrough[ \t]*</code>
</li><li><code>[ \t.!]*(ELSE,? |INTENTIONAL(LY)? )?<br/>FALL(S | |-)?THR(OUGH|U)[ \t.!]*(-[^\n\r]*)?</code>
</li><li><code>[ \t.!]*(Else,? |Intentional(ly)? )?<br/>Fall((s | |-)[Tt]|t)hr(ough|u)[ \t.!]*(-[^\n\r]*)?</code>
</li><li><code>[ \t.!]*([Ee]lse,? |[Ii]ntentional(ly)? )?<br/>fall(s | |-)?thr(ough|u)[ \t.!]*(-[^\n\r]*)?</code>
</li></ul>
</li><li><samp>-Wimplicit-fallthrough=4</samp> case sensitively matches one of the
following regular expressions:

<ul>
<li><code>-fallthrough</code>
</li><li><code>@fallthrough@</code>
</li><li><code>lint -fallthrough[ \t]*</code>
</li><li><code>[ \t]*FALLTHR(OUGH|U)[ \t]*</code>
</li></ul>
</li><li><samp>-Wimplicit-fallthrough=5</samp> doesn’t recognize any comments as
fallthrough comments, only attributes disable the warning.

</li></ul>
<p>The comment needs to be followed after optional whitespace and other comments
by <code>case</code> or <code>default</code> keywords or by a user label that precedes some
<code>case</code> or <code>default</code> label.
</p>
<div>
<div><pre>switch (cond)
  {
  case 1:
    bar (0);
    /* FALLTHRU */
  default:
    …
  }
</pre></div></div>
<p>The <samp>-Wimplicit-fallthrough=3</samp> warning is enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wimplicit-function-declaration</key>
    <name>Warn about implicit function declarations</name>
    <description>
      <![CDATA[<p>This option controls warnings when a function is used before being declared.
This warning is enabled by default, as an error, in C99 and later
dialects of C, and also by <samp>-Wall</samp>.  The error can be downgraded
to a warning using <samp>-fpermissive</samp> (along with certain other
errors), or for this error alone, with
<samp>-Wno-error=implicit-function-declaration</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wimplicit-int</key>
    <name>Warn when a declaration does not specify a type</name>
    <description>
      <![CDATA[<p>This option controls warnings when a declaration does not specify a type.
This warning is enabled by default, as an error, in C99 and later
dialects of C, and also by <samp>-Wall</samp>.  The error can be downgraded
to a warning using <samp>-fpermissive</samp> (along with certain other
errors), or for this error alone, with <samp>-Wno-error=implicit-int</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winaccessible-base</key>
    <name>Warn when a base is inaccessible in derived due to ambiguity</name>
    <description>
      <![CDATA[<p>This option controls warnings
when a base class is inaccessible in a class derived from it due to
ambiguity.  The warning is enabled by default.
Note that the warning for ambiguous virtual
bases is enabled by the <samp>-Wextra</samp> option.
</p><div>
<div><pre>struct A { int a; };

struct B : A { };

struct C : B, A { };
</pre></div></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wincompatible-pointer-types</key>
    <name>Warn when there is a conversion between pointers that have incompatible types</name>
    <description>
      <![CDATA[<p>Warn when there is a conversion between pointers that have incompatible
types.  This warning is for cases not covered by <samp>-Wno-pointer-sign</samp>,
which warns for pointer argument passing or assignment with different
signedness.
</p>
<p>By default, in C99 and later dialects of C, GCC treats this issue as an
error.  The error can be downgraded to a warning using
<samp>-fpermissive</samp> (along with certain other errors), or for this
error alone, with <samp>-Wno-error=incompatible-pointer-types</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winfinite-recursion</key>
    <name>Warn for infinitely recursive calls</name>
    <description>
      <![CDATA[<p>Warn about infinitely recursive calls.  The warning is effective at all
optimization levels but requires optimization in order to detect infinite
recursion in calls between two or more functions.
<samp>-Winfinite-recursion</samp> is included in <samp>-Wall</samp>.
</p>
<p>Compare with <samp>-Wanalyzer-infinite-recursion</samp> which provides a
similar diagnostic, but is implemented in a different way (as part of
<samp>-fanalyzer</samp>).
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winherited-variadic-ctor</key>
    <name>Warn about C++11 inheriting constructors when the base has a variadic constructor</name>
    <description>
      <![CDATA[<p>Suppress warnings about use of C++11 inheriting constructors when the
base class inherited from has a C variadic constructor; the warning is
on by default because the ellipsis is not inherited.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winit-list-lifetime</key>
    <name>Warn about uses of std::initializer_list that can result in dangling pointers</name>
    <description>
      <![CDATA[<p>Warn about uses of <code>std::initializer_list</code> that are likely
to result in dangling pointers.  Since the underlying array for an
<code>initializer_list</code> is handled like a normal C++ temporary object,
it is easy to inadvertently keep a pointer to the array past the end
of the array’s lifetime.  For example:
</p>
<ul>
<li>If a function returns a temporary <code>initializer_list</code>, or a local
<code>initializer_list</code> variable, the array’s lifetime ends at the end
of the return statement, so the value returned has a dangling pointer.

</li><li>If a new-expression creates an <code>initializer_list</code>, the array only
lives until the end of the enclosing full-expression, so the
<code>initializer_list</code> in the heap has a dangling pointer.

</li><li>When an <code>initializer_list</code> variable is assigned from a
brace-enclosed initializer list, the temporary array created for the
right side of the assignment only lives until the end of the
full-expression, so at the next statement the <code>initializer_list</code>
variable has a dangling pointer.

<div>
<pre>// li's initial underlying array lives as long as li
std::initializer_list&lt;int&gt; li = { 1,2,3 };
// assignment changes li to point to a temporary array
li = { 4, 5 };
// now the temporary is gone and li has a dangling pointer
int i = li.begin()[0] // undefined behavior
</pre></div>
</li><li>When a list constructor stores the <code>begin</code> pointer from the
<code>initializer_list</code> argument, this doesn’t extend the lifetime of
the array, so if a class variable is constructed from a temporary
<code>initializer_list</code>, the pointer is left dangling by the end of
the variable declaration statement.

</li></ul>]]>
      </description>
    </rule>
  <rule>
    <key>-Winit-self</key>
    <name>Warn about variables which are initialized to themselves</name>
    <description>
      <![CDATA[<p>Warn about uninitialized variables that are initialized with themselves.
Note this option can only be used with the <samp>-Wuninitialized</samp> option.
</p>
<p>For example, GCC warns about <code>i</code> being uninitialized in the
following snippet only when <samp>-Winit-self</samp> has been specified:
</p><div>
<div><pre>int f()
{
  int i = i;
  return i;
}
</pre></div></div>
<p>This warning is enabled by <samp>-Wall</samp> in C++.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winline</key>
    <name>Warn when an inlined function cannot be inlined</name>
    <description>
      <![CDATA[<p>Warn if a function that is declared as inline cannot be inlined.
Even with this option, the compiler does not warn about failures to
inline functions declared in system headers.
</p>
<p>The compiler uses a variety of heuristics to determine whether or not
to inline a function.  For example, the compiler takes into account
the size of the function being inlined and the amount of inlining
that has already been done in the current function.  Therefore,
seemingly insignificant changes in the source program can cause the
warnings produced by <samp>-Winline</samp> to appear or disappear.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wint-conversion</key>
    <name>Warn about incompatible integer to pointer and pointer to integer conversions</name>
    <description>
      <![CDATA[<p>Warn about incompatible integer to pointer and pointer to integer
conversions.  This warning is about implicit conversions; for explicit
conversions the warnings <samp>-Wno-int-to-pointer-cast</samp> and
<samp>-Wno-pointer-to-int-cast</samp> may be used.
</p>
<p>By default, in C99 and later dialects of C, GCC treats this issue as an
error.  The error can be downgraded to a warning using
<samp>-fpermissive</samp> (along with certain other errors), or for this
error alone, with <samp>-Wno-error=int-conversion</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wint-in-bool-context</key>
    <name>Warn for suspicious integer expressions in boolean context</name>
    <description>
      <![CDATA[<p>Warn for suspicious use of integer values where boolean values are expected,
such as conditional expressions (?:) using non-boolean integer constants in
boolean context, like <code>if (a &lt;= b ? 2 : 3)</code>.  Or left shifting of signed
integers in boolean context, like <code>for (a = 0; 1 &lt;&lt; a; a++);</code>.  Likewise
for all kinds of multiplications regardless of the data type.
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wint-to-pointer-cast</key>
    <name>Warn when there is a cast to a pointer from an integer of a different size</name>
    <description>
      <![CDATA[<p>Suppress warnings from casts to pointer type of an integer of a
different size. In C++, casting to a pointer type of smaller size is
an error. <samp>Wint-to-pointer-cast</samp> is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winterference-size</key>
    <name>Warn about nonsensical values of --param destructive-interference-size or constructive-interference-size</name>
    <description>
      <![CDATA[<p>Warn about use of C++17 <code>std::hardware_destructive_interference_size</code>
without specifying its value with <samp>--param destructive-interference-size</samp>.
Also warn about questionable values for that option.
</p>
<p>This variable is intended to be used for controlling class layout, to
avoid false sharing in concurrent code:
</p>
<div>
<pre>struct independent_fields {
  alignas(std::hardware_destructive_interference_size)
    std::atomic&lt;int&gt; one;
  alignas(std::hardware_destructive_interference_size)
    std::atomic&lt;int&gt; two;
};
</pre></div>
<p>Here ‘<samp>one</samp>’ and ‘<samp>two</samp>’ are intended to be far enough apart
that stores to one won’t require accesses to the other to reload the
cache line.
</p>
<p>By default, <samp>--param destructive-interference-size</samp> and
<samp>--param constructive-interference-size</samp> are set based on the
current <samp>-mtune</samp> option, typically to the L1 cache line size
for the particular target CPU, sometimes to a range if tuning for a
generic target.  So all translation units that depend on ABI
compatibility for the use of these variables must be compiled with
the same <samp>-mtune</samp> (or <samp>-mcpu</samp>).
</p>
<p>If ABI stability is important, such as if the use is in a header for a
library, you should probably not use the hardware interference size
variables at all.  Alternatively, you can force a particular value
with <samp>--param</samp>.
</p>
<p>If you are confident that your use of the variable does not affect ABI
outside a single build of your project, you can turn off the warning
with <samp>-Wno-interference-size</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winvalid-constexpr</key>
    <name>Warn when a function never produces a constant expression</name>
    <description>
      <![CDATA[
<p>Warn when a function never produces a constant expression.  In C++20
and earlier, for every <code>constexpr</code> function and function template,
there must be at least one set of function arguments in at least one
instantiation such that an invocation of the function or constructor
could be an evaluated subexpression of a core constant expression.
C++23 removed this restriction, so it’s possible to have a function
or a function template marked <code>constexpr</code> for which no invocation
satisfies the requirements of a core constant expression.
</p>
<p>This warning is enabled as a pedantic warning by default in C++20 and
earlier.  In C++23, <samp>-Winvalid-constexpr</samp> can be turned on, in
which case it will be an ordinary warning.  For example:
</p>
<div>
<pre>void f (int&amp; i);
constexpr void
g (int&amp; i)
{
  // Warns by default in C++20, in C++23 only with -Winvalid-constexpr.
  f(i);
}
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Winvalid-imported-macros</key>
    <name>Warn about macros that have conflicting header units definitions</name>
    <description>
      <![CDATA[<p>Verify all imported macro definitions are valid at the end of
compilation.  This is not enabled by default, as it requires
additional processing to determine.  It may be useful when preparing
sets of header-units to ensure consistent macros.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winvalid-memory-model</key>
    <name>Warn when an atomic memory model parameter is known to be outside the valid range</name>
    <description>
      <![CDATA[<p>This option controls warnings
for invocations of <a href="_005f_005fatomic-Builtins.html">Built-in Functions for Memory Model Aware Atomic Operations</a>, <a href="_005f_005fsync-Builtins.html">Legacy <code>__sync</code> Built-in Functions for Atomic Memory Access</a>,
and the C11 atomic generic functions with a memory consistency argument
that is either invalid for the operation or outside the range of values
of the <code>memory_order</code> enumeration.  For example, since the
<code>__atomic_store</code> and <code>__atomic_store_n</code> built-ins are only
defined for the relaxed, release, and sequentially consistent memory
orders the following code is diagnosed:
</p>
<div>
<pre>void store (int *i)
{
  __atomic_store_n (i, 0, memory_order_consume);
}
</pre></div>
<p><samp>-Winvalid-memory-model</samp> is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winvalid-offsetof</key>
    <name>Warn about invalid uses of the "offsetof" macro</name>
    <description>
      <![CDATA[<p>Suppress warnings from applying the <code>offsetof</code> macro to a non-POD
type.  According to the 2014 ISO C++ standard, applying <code>offsetof</code>
to a non-standard-layout type is undefined.  In existing C++ implementations,
however, <code>offsetof</code> typically gives meaningful results.
This flag is for users who are aware that they are
writing nonportable code and who have deliberately chosen to ignore the
warning about it.
</p>
<p>The restrictions on <code>offsetof</code> may be relaxed in a future version
of the C++ standard.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winvalid-pch</key>
    <name>Warn about PCH files that are found but not used</name>
    <description>
      <![CDATA[<p>Warn if a precompiled header (see <a href="Precompiled-Headers.html">Using Precompiled Headers</a>) is found in
the search path but cannot be used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Winvalid-utf8</key>
    <name>Warn about invalid UTF-8 characters</name>
    <description>
      <![CDATA[<p>Warn if an invalid UTF-8 character is found.
This warning is on by default for C++23 if <samp>-finput-charset=UTF-8</samp>
is used and turned into error with <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wjump-misses-init</key>
    <name>Warn when a jump misses a variable initialization</name>
    <description>
      <![CDATA[<p>Warn if a <code>goto</code> statement or a <code>switch</code> statement jumps
forward across the initialization of a variable, or jumps backward to a
label after the variable has been initialized.  This only warns about
variables that are initialized when they are declared.  This warning is
only supported for C and Objective-C; in C++ this sort of branch is an
error in any case.
</p>
<p><samp>-Wjump-misses-init</samp> is included in <samp>-Wc++-compat</samp>.  It
can be disabled with the <samp>-Wno-jump-misses-init</samp> option.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wlarger-than</key>
    <name>Warn if an object's size exceeds &lt;byte-size&gt;</name>
    <description>
      <![CDATA[<p>Warn whenever an object is defined whose size exceeds <var>byte-size</var>.
<samp>-Wlarger-than=</samp>‘<samp>PTRDIFF_MAX</samp>’ is enabled by default.
Warnings controlled by the option can be disabled either by specifying
<var>byte-size</var> of ‘<samp>SIZE_MAX</samp>’ or more or by <samp>-Wno-larger-than</samp>.
</p>
<p>Also warn for calls to bounded functions such as <code>memchr</code> or
<code>strnlen</code> that specify a bound greater than the largest possible
object, which is ‘<samp>PTRDIFF_MAX</samp>’ bytes by default.  These warnings
can only be disabled by <samp>-Wno-larger-than</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wliteral-suffix</key>
    <name>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore</name>
    <description>
      <![CDATA[<p>Warn when a string or character literal is followed by a
ud-suffix which does not begin with an underscore.  As a conforming
extension, GCC treats such suffixes as separate preprocessing tokens
in order to maintain backwards compatibility with code that uses
formatting macros from <code>&lt;inttypes.h&gt;</code>.  For example:
</p>
<div>
<pre>#define __STDC_FORMAT_MACROS
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;

int main() {
  int64_t i64 = 123;
  printf("My int64: %" PRId64"\n", i64);
}
</pre></div>
<p>In this case, <code>PRId64</code> is treated as a separate preprocessing token.
</p>
<p>This option also controls warnings when a user-defined literal
operator is declared with a literal suffix identifier that doesn’t
begin with an underscore. Literal suffix identifiers that don’t begin
with an underscore are reserved for future standardization.
</p>
<p>These warnings are enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wlogical-not-parentheses</key>
    <name>Warn when logical not is used on the left hand side operand of a comparison</name>
    <description>
      <![CDATA[<p>Warn about logical not used on the left hand side operand of a comparison.
This option does not warn if the right operand is considered to be a boolean
expression.  Its purpose is to detect suspicious code like the following:
</p><div>
<pre>int a;
…
if (!a &gt; 1) { … }
</pre></div>
<p>It is possible to suppress the warning by wrapping the LHS into
parentheses:
</p><div>
<pre>if ((!a) &gt; 1) { … }
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wlogical-op</key>
    <name>Warn when a logical operator is suspiciously always evaluating to true or false</name>
    <description>
      <![CDATA[<p>Warn about suspicious uses of logical operators in expressions.
This includes using logical operators in contexts where a
bit-wise operator is likely to be expected.  Also warns when
the operands of a logical operator are the same:
</p><div>
<pre>extern int a;
if (a &lt; 0 &amp;&amp; a &lt; 0) { … }
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wlong-long</key>
    <name>Warn about using "long long"</name>
    <description>
      <![CDATA[<p>Warn if <code>long long</code> type is used.  This is enabled by either
<samp>-Wpedantic</samp> or <samp>-Wtraditional</samp> in ISO C90 and C++98
modes.  To inhibit the warning messages, use <samp>-Wno-long-long</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wlto-type-mismatch</key>
    <name>During link time optimization warn about mismatched types of global declarations</name>
    <description>
      <![CDATA[
<p>During the link-time optimization, do not warn about type mismatches in
global declarations from different compilation units.
Requires <samp>-flto</samp> to be enabled.  Enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmain</key>
    <name>Warn about suspicious declarations of "main"</name>
    <description>
      <![CDATA[<p>Warn if the type of <code>main</code> is suspicious.  <code>main</code> should be
a function with external linkage, returning int, taking either zero
arguments, two, or three arguments of appropriate types.  This warning
is enabled by default in C++ and is enabled by either <samp>-Wall</samp>
or <samp>-Wpedantic</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmaybe-uninitialized</key>
    <name>Warn about maybe uninitialized automatic variables</name>
    <description>
      <![CDATA[<p>For an object with automatic or allocated storage duration, if there exists
a path from the function entry to a use of the object that is initialized,
but there exist some other paths for which the object is not initialized,
the compiler emits a warning if it cannot prove the uninitialized paths
are not executed at run time.
</p>
<p>In addition, passing a pointer (or in C++, a reference) to an uninitialized
object to a <code>const</code>-qualified function argument is also diagnosed by
this warning.  (<samp>-Wuninitialized</samp> is issued for built-in functions
known to read the object.)  Annotating the function with attribute
<code>access (none)</code> indicates that the argument isn’t used to access
the object and avoids the warning (see <a href="Common-Function-Attributes.html">Common Function Attributes</a>).
</p>
<p>These warnings are only possible in optimizing compilation, because otherwise
GCC does not keep track of the state of variables.
</p>
<p>These warnings are made optional because GCC may not be able to determine when
the code is correct in spite of appearing to have an error.  Here is one
example of how this can happen:
</p>
<div>
<div><pre>{
  int x;
  switch (y)
    {
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    }
  foo (x);
}
</pre></div></div>
<p>If the value of <code>y</code> is always 1, 2 or 3, then <code>x</code> is
always initialized, but GCC doesn’t know this. To suppress the
warning, you need to provide a default case with assert(0) or
similar code.
</p>
<a id="index-longjmp-warnings"></a>
<p>This option also warns when a non-volatile automatic variable might be
changed by a call to <code>longjmp</code>.
The compiler sees only the calls to <code>setjmp</code>.  It cannot know
where <code>longjmp</code> will be called; in fact, a signal handler could
call it at any point in the code.  As a result, you may get a warning
even when there is in fact no problem because <code>longjmp</code> cannot
in fact be called at the place that would cause a problem.
</p>
<p>Some spurious warnings can be avoided if you declare all the functions
you use that never return as <code>noreturn</code>.  See <a href="Function-Attributes.html">Declaring Attributes of Functions</a>.
</p>
<p>This warning is enabled by <samp>-Wall</samp> or <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmemset-elt-size</key>
    <name>Warn about suspicious calls to memset where the third argument contains the number of elements not multiplied by the element size</name>
    <description>
      <![CDATA[<p>Warn for suspicious calls to the <code>memset</code> built-in function, if the
first argument references an array, and the third argument is a number
equal to the number of elements, but not equal to the size of the array
in memory.  This indicates that the user has omitted a multiplication by
the element size.  This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmemset-transposed-args</key>
    <name>Warn about suspicious calls to memset where the third argument is constant literal zero and the second is not</name>
    <description>
      <![CDATA[<p>Warn for suspicious calls to the <code>memset</code> built-in function where
the second argument is not zero and the third argument is zero.  For
example, the call <code>memset (buf, sizeof buf, 0)</code> is diagnosed because
<code>memset (buf, 0, sizeof buf)</code> was meant instead.  The diagnostic
is only emitted if the third argument is a literal zero.  Otherwise, if
it is an expression that is folded to zero, or a cast of zero to some
type, it is far less likely that the arguments have been mistakenly
transposed and no warning is emitted.  This warning is enabled
by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmisleading-indentation</key>
    <name>Warn when the indentation of the code does not reflect the block structure</name>
    <description>
      <![CDATA[<p>Warn when the indentation of the code does not reflect the block structure.
Specifically, a warning is issued for <code>if</code>, <code>else</code>, <code>while</code>, and
<code>for</code> clauses with a guarded statement that does not use braces,
followed by an unguarded statement with the same indentation.
</p>
<p>In the following example, the call to “bar” is misleadingly indented as
if it were guarded by the “if” conditional.
</p>
<div>
<pre>  if (some_condition ())
    foo ();
    bar ();  /* Gotcha: this is not guarded by the "if".  */
</pre></div>
<p>In the case of mixed tabs and spaces, the warning uses the
<samp>-ftabstop=</samp> option to determine if the statements line up
(defaulting to 8).
</p>
<p>The warning is not issued for code involving multiline preprocessor logic
such as the following example.
</p>
<div>
<pre>  if (flagA)
    foo (0);
#if SOME_CONDITION_THAT_DOES_NOT_HOLD
  if (flagB)
#endif
    foo (1);
</pre></div>
<p>The warning is not issued after a <code>#line</code> directive, since this
typically indicates autogenerated code, and no assumptions can be made
about the layout of the file that the directive references.
</p>
<p>This warning is enabled by <samp>-Wall</samp> in C and C++.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmismatched-dealloc</key>
    <name>Warn for deallocation calls with arguments returned from mismatched allocation functions</name>
    <description>
      <![CDATA[
<p>Warn for calls to deallocation functions with pointer arguments returned
from allocation functions for which the former isn’t a suitable
deallocator.  A pair of functions can be associated as matching allocators
and deallocators by use of attribute <code>malloc</code>.  Unless disabled by
the <samp>-fno-builtin</samp> option the standard functions <code>calloc</code>,
<code>malloc</code>, <code>realloc</code>, and <code>free</code>, as well as the corresponding
forms of C++ <code>operator new</code> and <code>operator delete</code> are implicitly
associated as matching allocators and deallocators.  In the following
example <code>mydealloc</code> is the deallocator for pointers returned from
<code>myalloc</code>.
</p>
<div>
<pre>void mydealloc (void*);

__attribute__ ((malloc (mydealloc, 1))) void*
myalloc (size_t);

void f (void)
{
  void *p = myalloc (32);
  // …use p…
  free (p);   // warning: not a matching deallocator for myalloc
  mydealloc (p);   // ok
}
</pre></div>
<p>In C++, the related option <samp>-Wmismatched-new-delete</samp> diagnoses
mismatches involving either <code>operator new</code> or <code>operator delete</code>.
</p>
<p>Option <samp>-Wmismatched-dealloc</samp> is included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmismatched-new-delete</key>
    <name>Warn for mismatches between calls to operator new or delete and the corresponding call to the allocation or deallocation function</name>
    <description>
      <![CDATA[<p>Warn for mismatches between calls to <code>operator new</code> or <code>operator
delete</code> and the corresponding call to the allocation or deallocation function.
This includes invocations of C++ <code>operator delete</code> with pointers
returned from either mismatched forms of <code>operator new</code>, or from other
functions that allocate objects for which the <code>operator delete</code> isn’t
a suitable deallocator, as well as calls to other deallocation functions
with pointers returned from <code>operator new</code> for which the deallocation
function isn’t suitable.
</p>
<p>For example, the <code>delete</code> expression in the function below is diagnosed
because it doesn’t match the array form of the <code>new</code> expression
the pointer argument was returned from.  Similarly, the call to <code>free</code>
is also diagnosed.
</p>
<div>
<pre>void f ()
{
  int *a = new int[n];
  delete a;   // warning: mismatch in array forms of expressions

  char *p = new char[n];
  free (p);   // warning: mismatch between new and free
}
</pre></div>
<p>The related option <samp>-Wmismatched-dealloc</samp> diagnoses mismatches
involving allocation and deallocation functions other than <code>operator
new</code> and <code>operator delete</code>.
</p>
<p><samp>-Wmismatched-new-delete</samp> is included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmismatched-tags</key>
    <name>Warn when a class is redeclared or referenced using a mismatched class-key</name>
    <description>
      <![CDATA[<p>Warn for declarations of structs, classes, and class templates and their
specializations with a class-key that does not match either the definition
or the first declaration if no definition is provided.
</p>
<p>For example, the declaration of <code>struct Object</code> in the argument list
of <code>draw</code> triggers the warning.  To avoid it, either remove the redundant
class-key <code>struct</code> or replace it with <code>class</code> to match its definition.
</p><div>
<pre>class Object {
public:
  virtual ~Object () = 0;
};
void draw (struct Object*);
</pre></div>
<p>It is not wrong to declare a class with the class-key <code>struct</code> as
the example above shows.  The <samp>-Wmismatched-tags</samp> option is intended
to help achieve a consistent style of class declarations.  In code that is
intended to be portable to Windows-based compilers the warning helps prevent
unresolved references due to the difference in the mangling of symbols
declared with different class-keys.  The option can be used either on its
own or in conjunction with <samp>-Wredundant-tags</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-attributes</key>
    <name>Warn about declarations of entities that may be missing attributes that related entities have been declared with</name>
    <description>
      <![CDATA[<p>Warn when a declaration of a function is missing one or more attributes
that a related function is declared with and whose absence may adversely
affect the correctness or efficiency of generated code.  For example,
the warning is issued for declarations of aliases that use attributes
to specify less restrictive requirements than those of their targets.
This typically represents a potential optimization opportunity.
By contrast, the <samp>-Wattribute-alias=2</samp> option controls warnings
issued when the alias is more restrictive than the target, which could
lead to incorrect code generation.
Attributes considered include <code>alloc_align</code>, <code>alloc_size</code>,
<code>cold</code>, <code>const</code>, <code>hot</code>, <code>leaf</code>, <code>malloc</code>,
<code>nonnull</code>, <code>noreturn</code>, <code>nothrow</code>, <code>pure</code>,
<code>returns_nonnull</code>, and <code>returns_twice</code>.
</p>
<p>In C++, the warning is issued when an explicit specialization of a primary
template declared with attribute <code>alloc_align</code>, <code>alloc_size</code>,
<code>assume_aligned</code>, <code>format</code>, <code>format_arg</code>, <code>malloc</code>,
or <code>nonnull</code> is declared without it.  Attributes <code>deprecated</code>,
<code>error</code>, and <code>warning</code> suppress the warning.
(see <a href="Function-Attributes.html">Declaring Attributes of Functions</a>).
</p>
<p>You can use the <code>copy</code> attribute to apply the same
set of attributes to a declaration as that on another declaration without
explicitly enumerating the attributes. This attribute can be applied
to declarations of functions (see <a href="Common-Function-Attributes.html">Common Function Attributes</a>),
variables (see <a href="Common-Variable-Attributes.html">Common Variable Attributes</a>), or types
(see <a href="Common-Type-Attributes.html">Common Type Attributes</a>).
</p>
<p><samp>-Wmissing-attributes</samp> is enabled by <samp>-Wall</samp>.
</p>
<p>For example, since the declaration of the primary function template
below makes use of both attribute <code>malloc</code> and <code>alloc_size</code>
the declaration of the explicit specialization of the template is
diagnosed because it is missing one of the attributes.
</p>
<div>
<pre>template &lt;class T&gt;
T* __attribute__ ((malloc, alloc_size (1)))
allocate (size_t);

template &lt;&gt;
void* __attribute__ ((malloc))   // missing alloc_size
allocate&lt;void&gt; (size_t);
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-braces</key>
    <name>Warn about possibly missing braces around initializers</name>
    <description>
      <![CDATA[<p>Warn if an aggregate or union initializer is not fully bracketed.  In
the following example, the initializer for <code>a</code> is not fully
bracketed, but that for <code>b</code> is fully bracketed.
</p>
<div>
<pre>int a[2][2] = { 0, 1, 2, 3 };
int b[2][2] = { { 0, 1 }, { 2, 3 } };
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-declarations</key>
    <name>Warn about global functions without previous declarations</name>
    <description>
      <![CDATA[<p>Warn if a global function is defined without a previous declaration.
Do so even if the definition itself provides a prototype.
Use this option to detect global functions that are not declared in
header files.  In C, no warnings are issued for functions with previous
non-prototype declarations; use <samp>-Wmissing-prototypes</samp> to detect
missing prototypes.  In C++, no warnings are issued for function templates,
or for inline functions, or for functions in anonymous namespaces.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-field-initializers</key>
    <name>Warn about missing fields in struct initializers</name>
    <description>
      <![CDATA[<p>Warn if a structure’s initializer has some fields missing.  For
example, the following code causes such a warning, because
<code>x.h</code> is implicitly zero:
</p>
<div>
<pre>struct s { int f, g, h; };
struct s x = { 3, 4 };
</pre></div>
<p>In C this option does not warn about designated initializers, so the
following modification does not trigger a warning:
</p>
<div>
<pre>struct s { int f, g, h; };
struct s x = { .f = 3, .g = 4 };
</pre></div>
<p>In C this option does not warn about the universal zero initializer
‘<samp>{ 0 }</samp>’:
</p>
<div>
<pre>struct s { int f, g, h; };
struct s x = { 0 };
</pre></div>
<p>Likewise, in C++ this option does not warn about the empty { }
initializer, for example:
</p>
<div>
<pre>struct s { int f, g, h; };
s x = { };
</pre></div>
<p>This warning is included in <samp>-Wextra</samp>.  To get other <samp>-Wextra</samp>
warnings without this one, use <samp>-Wextra -Wno-missing-field-initializers</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-include-dirs</key>
    <name>Warn about user-specified include directories that do not exist</name>
    <description>
      <![CDATA[<p>Warn if a user-supplied include directory does not exist. This option is disabled
by default for C, C++, Objective-C and Objective-C++. For Fortran, it is partially
enabled by default by warning for -I and -J, only.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-parameter-type</key>
    <name>Warn about function parameters declared without a type specifier in K&amp;R-style functions</name>
    <description>
      <![CDATA[<p>A function parameter is declared without a type specifier in K&amp;R-style
functions:
</p>
<div>
<pre>void foo(bar) { }
</pre></div>
<p>This warning is also enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-profile</key>
    <name>Warn in case profiles in -fprofile-use do not exist</name>
    <description>
      <![CDATA[<p>This option controls warnings if feedback profiles are missing when using the
<samp>-fprofile-use</samp> option.
This option diagnoses those cases where a new function or a new file is added
between compiling with <samp>-fprofile-generate</samp> and with
<samp>-fprofile-use</samp>, without regenerating the profiles.
In these cases, the profile feedback data files do not contain any
profile feedback information for
the newly added function or file respectively.  Also, in the case when profile
count data (.gcda) files are removed, GCC cannot use any profile feedback
information.  In all these cases, warnings are issued to inform you that a
profile generation step is due.
Ignoring the warning can result in poorly optimized code.
<samp>-Wno-missing-profile</samp> can be used to
disable the warning, but this is not recommended and should be done only
when non-existent profile data is justified.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-prototypes</key>
    <name>Warn about global functions without prototypes</name>
    <description>
      <![CDATA[<p>Warn if a global function is defined without a previous prototype
declaration.  This warning is issued even if the definition itself
provides a prototype.  Use this option to detect global functions
that do not have a matching prototype declaration in a header file.
This option is not valid for C++ because all function declarations
provide prototypes and a non-matching declaration declares an
overload rather than conflict with an earlier declaration.
Use <samp>-Wmissing-declarations</samp> to detect missing declarations in C++.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-requires</key>
    <name>Warn about likely missing requires keyword</name>
    <description>
      <![CDATA[
<p>By default, the compiler warns about a concept-id appearing as a C++20 simple-requirement:
</p>
<div>
<pre>bool satisfied = requires { C&lt;T&gt; };
</pre></div>
<p>Here ‘<samp>satisfied</samp>’ will be true if ‘<samp>C&lt;T&gt;</samp>’ is a valid
expression, which it is for all T.  Presumably the user meant to write
</p>
<div>
<pre>bool satisfied = requires { requires C&lt;T&gt; };
</pre></div>
<p>so ‘<samp>satisfied</samp>’ is only true if concept ‘<samp>C</samp>’ is satisfied for
type ‘<samp>T</samp>’.
</p>
<p>This warning can be disabled with <samp>-Wno-missing-requires</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-template-keyword</key>
    <name>Warn when the template keyword is missing after a member access token in a dependent member access expression if that member is a template</name>
    <description>
      <![CDATA[
<p>The member access tokens ., -&gt; and :: must be followed by the <code>template</code>
keyword if the parent object is dependent and the member being named is a
template.
</p>
<div>
<pre>template &lt;class X&gt;
void DoStuff (X x)
{
  x.template DoSomeOtherStuff&lt;X&gt;(); // Good.
  x.DoMoreStuff&lt;X&gt;(); // Warning, x is dependent.
}
</pre></div>
<p>In rare cases it is possible to get false positives. To silence this, wrap
the expression in parentheses. For example, the following is treated as a
template, even where m and N are integers:
</p>
<div>
<pre>void NotATemplate (my_class t)
{
  int N = 5;

  bool test = t.m &lt; N &gt; (0); // Treated as a template.
  test = (t.m &lt; N) &gt; (0); // Same meaning, but not treated as a template.
}
</pre></div>
<p>This warning can be disabled with <samp>-Wno-missing-template-keyword</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmissing-variable-declarations</key>
    <name>Warn about global variables without previous declarations</name>
    <description>
      <![CDATA[<p>Warn if a global variable is defined without a previous declaration.
Use this option to detect global variables that do not have a matching
extern declaration in a header file.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmultichar</key>
    <name>Warn about use of multi-character character constants</name>
    <description>
      <![CDATA[<p>Warn if a multicharacter constant (‘<samp>'FOOF'</samp>’) is used.
Usually they indicate a typo in the user’s code, as they have
implementation-defined values, and should not be used in portable code.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmultiple-inheritance</key>
    <name>Warn on direct multiple inheritance</name>
    <description>
      <![CDATA[<p>Warn when a class is defined with multiple direct base classes.  Some
coding rules disallow multiple inheritance, and this may be used to
enforce that rule.  The warning is inactive inside a system header file,
such as the STL, so one can still use the STL.  One may also define
classes that indirectly use multiple inheritance.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmultistatement-macros</key>
    <name>Warn about unsafe macros expanding to multiple statements used as a body of a clause such as if, else, while, switch, or for</name>
    <description>
      <![CDATA[<p>Warn about unsafe multiple statement macros that appear to be guarded
by a clause such as <code>if</code>, <code>else</code>, <code>for</code>, <code>switch</code>, or
<code>while</code>, in which only the first statement is actually guarded after
the macro is expanded.
</p>
<p>For example:
</p>
<div>
<pre>#define DOIT x++; y++
if (c)
  DOIT;
</pre></div>
<p>will increment <code>y</code> unconditionally, not just when <code>c</code> holds.
The can usually be fixed by wrapping the macro in a do-while loop:
</p><div>
<pre>#define DOIT do { x++; y++; } while (0)
if (c)
  DOIT;
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp> in C and C++.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnamespaces</key>
    <name>Warn on namespace definition</name>
    <description>
      <![CDATA[<p>Warn when a namespace definition is opened.  Some coding rules disallow
namespaces, and this may be used to enforce that rule.  The warning is
inactive inside a system header file, such as the STL, so one can still
use the STL.  One may also use using directives and qualified names.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnarrowing</key>
    <name>Warn about narrowing conversions within { } that are ill-formed in C++11</name>
    <description>
      <![CDATA[<p>For C++11 and later standards, narrowing conversions are diagnosed by default,
as required by the standard.  A narrowing conversion from a constant produces
an error, and a narrowing conversion from a non-constant produces a warning,
but <samp>-Wno-narrowing</samp> suppresses the diagnostic.
Note that this does not affect the meaning of well-formed code;
narrowing conversions are still considered ill-formed in SFINAE contexts.
</p>
<p>With <samp>-Wnarrowing</samp> in C++98, warn when a narrowing
conversion prohibited by C++11 occurs within
‘<samp>{ }</samp>’, e.g.
</p>
<div>
<pre>int i = { 2.2 }; // error: narrowing from double to int
</pre></div>
<p>This flag is included in <samp>-Wall</samp> and <samp>-Wc++11-compat</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnested-externs</key>
    <name>Warn about "extern" declarations not at file scope</name>
    <description>
      <![CDATA[<p>Warn if an <code>extern</code> declaration is encountered within a function.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnoexcept</key>
    <name>Warn when a noexcept expression evaluates to false even though the expression can't actually throw</name>
    <description>
      <![CDATA[<p>Warn when a noexcept-expression evaluates to false because of a call
to a function that does not have a non-throwing exception
specification (i.e. <code>throw()</code> or <code>noexcept</code>) but is known by
the compiler to never throw an exception.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnoexcept-type</key>
    <name>Warn if C++17 noexcept function type will change the mangled name of a symbol</name>
    <description>
      <![CDATA[<p>Warn if the C++17 feature making <code>noexcept</code> part of a function
type changes the mangled name of a symbol relative to C++14.  Enabled
by <samp>-Wabi</samp> and <samp>-Wc++17-compat</samp>.
</p>
<p>As an example:
</p>
<div>
<pre>template &lt;class T&gt; void f(T t) { t(); };
void g() noexcept;
void h() { f(g); } 
</pre></div>
<p>In C++14, <code>f</code> calls <code>f&lt;void(*)()&gt;</code>, but in
C++17 it calls <code>f&lt;void(*)()noexcept&gt;</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnon-template-friend</key>
    <name>Warn when non-templatized friend functions are declared within a template</name>
    <description>
      <![CDATA[<p>Disable warnings when non-template friend functions are declared
within a template.  In very old versions of GCC that predate implementation
of the ISO standard, declarations such as 
‘<samp>friend int foo(int)</samp>’, where the name of the friend is an unqualified-id,
could be interpreted as a particular specialization of a template
function; the warning exists to diagnose compatibility problems, 
and is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnon-virtual-dtor</key>
    <name>Warn about non-virtual destructors</name>
    <description>
      <![CDATA[<p>Warn when a class has virtual functions and an accessible non-virtual
destructor itself or in an accessible polymorphic base class, in which
case it is possible but unsafe to delete an instance of a derived
class through a pointer to the class itself or base class.  This
warning is automatically enabled if <samp>-Weffc++</samp> is specified.
The <samp>-Wdelete-non-virtual-dtor</samp> option (enabled by <samp>-Wall</samp>)
should be preferred because it warns about the unsafe cases without false
positives.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnonnull</key>
    <name>Warn about NULL being passed to argument slots marked as requiring non-NULL</name>
    <description>
      <![CDATA[<p>Warn about passing a null pointer for arguments marked as
requiring a non-null value by the <code>nonnull</code> function attribute.
</p>
<p><samp>-Wnonnull</samp> is included in <samp>-Wall</samp> and <samp>-Wformat</samp>.  It
can be disabled with the <samp>-Wno-nonnull</samp> option.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnonnull-compare</key>
    <name>Warn if comparing pointer parameter with nonnull attribute with NULL</name>
    <description>
      <![CDATA[<p>Warn when comparing an argument marked with the <code>nonnull</code>
function attribute against null inside the function.
</p>
<p><samp>-Wnonnull-compare</samp> is included in <samp>-Wall</samp>.  It
can be disabled with the <samp>-Wno-nonnull-compare</samp> option.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnormalized</key>
    <name>Warn about non-normalized Unicode strings</name>
    <description>
      <![CDATA[<p>In ISO C and ISO C++, two identifiers are different if they are
different sequences of characters.  However, sometimes when characters
outside the basic ASCII character set are used, you can have two
different character sequences that look the same.  To avoid confusion,
the ISO 10646 standard sets out some <em>normalization rules</em> which
when applied ensure that two sequences that look the same are turned into
the same sequence.  GCC can warn you if you are using identifiers that
have not been normalized; this option controls that warning.
</p>
<p>There are four levels of warning supported by GCC.  The default is
<samp>-Wnormalized=nfc</samp>, which warns about any identifier that is
not in the ISO 10646 “C” normalized form, <em>NFC</em>.  NFC is the
recommended form for most uses.  It is equivalent to
<samp>-Wnormalized</samp>.
</p>
<p>Unfortunately, there are some characters allowed in identifiers by
ISO C and ISO C++ that, when turned into NFC, are not allowed in 
identifiers.  That is, there’s no way to use these symbols in portable
ISO C or C++ and have all your identifiers in NFC.
<samp>-Wnormalized=id</samp> suppresses the warning for these characters.
It is hoped that future versions of the standards involved will correct
this, which is why this option is not the default.
</p>
<p>You can switch the warning off for all characters by writing
<samp>-Wnormalized=none</samp> or <samp>-Wno-normalized</samp>.  You should
only do this if you are using some other normalization scheme (like
“D”), because otherwise you can easily create bugs that are
literally impossible to see.
</p>
<p>Some characters in ISO 10646 have distinct meanings but look identical
in some fonts or display methodologies, especially once formatting has
been applied.  For instance <code>\u207F</code>, “SUPERSCRIPT LATIN SMALL
LETTER N”, displays just like a regular <code>n</code> that has been
placed in a superscript.  ISO 10646 defines the <em>NFKC</em>
normalization scheme to convert all these into a standard form as
well, and GCC warns if your code is not in NFKC if you use
<samp>-Wnormalized=nfkc</samp>.  This warning is comparable to warning
about every identifier that contains the letter O because it might be
confused with the digit 0, and so is not the default, but may be
useful as a local coding convention if the programming environment 
cannot be fixed to display these characters distinctly.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnrvo</key>
    <name>Warn if the named return value optimization is not performed although it is allowed</name>
    <description>
      <![CDATA[<p>Warn if the compiler does not elide the copy from a local variable to
the return value of a function in a context where it is allowed by
[class.copy.elision].  This elision is commonly known as the Named
Return Value Optimization.  For instance, in the example below the
compiler cannot elide copies from both v1 and v2, so it elides neither.
</p>
<div>
<pre>std::vector&lt;int&gt; f()
{
  std::vector&lt;int&gt; v1, v2;
  // ...
  if (cond) return v1;
  else return v2; // warning: not eliding copy
}
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wnull-dereference</key>
    <name>Warn if dereferencing a NULL pointer may lead to erroneous or undefined behavior</name>
    <description>
      <![CDATA[<p>Warn if the compiler detects paths that trigger erroneous or
undefined behavior due to dereferencing a null pointer.  This option
is only active when <samp>-fdelete-null-pointer-checks</samp> is active,
which is enabled by optimizations in most targets.  The precision of
the warnings depends on the optimization options used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wobjc-root-class</key>
    <name>Warn if a class interface has no superclass</name>
    <description>
      <![CDATA[<p>Warn if a class interface lacks a superclass. Most classes will inherit
from <code>NSObject</code> (or <code>Object</code>) for example.  When declaring
classes intended to be root classes, the warning can be suppressed by
marking their interfaces with <code>__attribute__((objc_root_class))</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wodr</key>
    <name>Warn about some C++ One Definition Rule violations during link time optimization</name>
    <description>
      <![CDATA[<p>Warn about One Definition Rule violations during link-time optimization.
Enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wold-style-cast</key>
    <name>Warn if a C-style cast is used in a program</name>
    <description>
      <![CDATA[<p>Warn if an old-style (C-style) cast to a non-void type is used within
a C++ program.  The new-style casts (<code>dynamic_cast</code>,
<code>static_cast</code>, <code>reinterpret_cast</code>, and <code>const_cast</code>) are
less vulnerable to unintended effects and much easier to search for.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wold-style-declaration</key>
    <name>Warn for obsolescent usage in a declaration</name>
    <description>
      <![CDATA[<p>Warn for obsolescent usages, according to the C Standard, in a
declaration. For example, warn if storage-class specifiers like
<code>static</code> are not the first things in a declaration.  This warning
is also enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wold-style-definition</key>
    <name>Warn if an old-style parameter definition is used</name>
    <description>
      <![CDATA[<p>Warn if an old-style function definition is used.  A warning is given
even if there is a previous prototype.  A definition using ‘<samp>()</samp>’
is not considered an old-style definition in C23 mode, because it is
equivalent to ‘<samp>(void)</samp>’ in that case, but is considered an
old-style definition for older standards.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wopenacc-parallelism</key>
    <name>Warn about potentially suboptimal choices related to OpenACC parallelism</name>
    <description>
      <![CDATA[<p>Warn about potentially suboptimal choices related to OpenACC parallelism.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wopenmp</key>
    <name>Warn about suspicious OpenMP code</name>
    <description>
      <![CDATA[<p>Warn about suspicious OpenMP code.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wopenmp-simd</key>
    <name>Warn if a simd directive is overridden by the vectorizer cost model</name>
    <description>
      <![CDATA[<p>Warn if the vectorizer cost model overrides the OpenMP
simd directive set by user.  The <samp>-fsimd-cost-model=unlimited</samp>
option can be used to relax the cost model.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Woverflow</key>
    <name>Warn about overflow in arithmetic expressions</name>
    <description>
      <![CDATA[<p>Warn about compile-time overflow in constant expressions.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Woverlength-strings</key>
    <name>Warn if a string is longer than the maximum portable length specified by the standard</name>
    <description>
      <![CDATA[<p>Warn about string constants that are longer than the “minimum
maximum” length specified in the C standard.  Modern compilers
generally allow string constants that are much longer than the
standard’s minimum limit, but very portable programs should avoid
using longer strings.
</p>
<p>The limit applies <em>after</em> string constant concatenation, and does
not count the trailing NUL.  In C90, the limit was 509 characters; in
C99, it was raised to 4095.  C++98 does not specify a normative
minimum maximum, so we do not diagnose overlength strings in C++.
</p>
<p>This option is implied by <samp>-Wpedantic</samp>, and can be disabled with
<samp>-Wno-overlength-strings</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Woverloaded-virtual</key>
    <name>Warn about overloaded virtual function names</name>
    <description>
      <![CDATA[<p>Warn when a function declaration hides virtual functions from a
base class.  For example, in:
</p>
<div>
<pre>struct A {
  virtual void f();
};

struct B: public A {
  void f(int); // does not override
};
</pre></div>
<p>the <code>A</code> class version of <code>f</code> is hidden in <code>B</code>, and code
like:
</p>
<div>
<pre>B* b;
b-&gt;f();
</pre></div>
<p>fails to compile.
</p>
<p>In cases where the different signatures are not an accident, the
simplest solution is to add a using-declaration to the derived class
to un-hide the base function, e.g. add <code>using A::f;</code> to <code>B</code>.
</p>
<p>The optional level suffix controls the behavior when all the
declarations in the derived class override virtual functions in the
base class, even if not all of the base functions are overridden:
</p>
<div>
<pre>struct C {
  virtual void f();
  virtual void f(int);
};

struct D: public C {
  void f(int); // does override
}
</pre></div>
<p>This pattern is less likely to be a mistake; if D is only used
virtually, the user might have decided that the base class semantics
for some of the overloads are fine.
</p>
<p>At level 1, this case does not warn; at level 2, it does.
<samp>-Woverloaded-virtual</samp> by itself selects level 2.  Level 1 is
included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Woverride-init</key>
    <name>Warn about overriding initializers without side effects</name>
    <description>
      <![CDATA[<p>Warn if an initialized field without side effects is overridden when
using designated initializers (see <a href="Designated-Inits.html">Designated
Initializers</a>).
</p>
<p>This warning is included in <samp>-Wextra</samp>.  To get other
<samp>-Wextra</samp> warnings without this one, use <samp>-Wextra
-Wno-override-init</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Woverride-init-side-effects</key>
    <name>Warn about overriding initializers with side effects</name>
    <description>
      <![CDATA[<p>Warn if an initialized field with side effects is overridden when
using designated initializers (see <a href="Designated-Inits.html">Designated
Initializers</a>).  This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpacked</key>
    <name>Warn when the packed attribute has no effect on struct layout</name>
    <description>
      <![CDATA[<p>Warn if a structure is given the packed attribute, but the packed
attribute has no effect on the layout or size of the structure.
Such structures may be mis-aligned for little benefit.  For
instance, in this code, the variable <code>f.x</code> in <code>struct bar</code>
is misaligned even though <code>struct bar</code> does not itself
have the packed attribute:
</p>
<div>
<div><pre>struct foo {
  int x;
  char a, b, c, d;
} __attribute__((packed));
struct bar {
  char z;
  struct foo f;
};
</pre></div></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpacked-bitfield-compat</key>
    <name>Warn about packed bit-fields whose offset changed in GCC 4.4</name>
    <description>
      <![CDATA[<p>The 4.1, 4.2 and 4.3 series of GCC ignore the <code>packed</code> attribute
on bit-fields of type <code>char</code>.  This was fixed in GCC 4.4 but
the change can lead to differences in the structure layout.  GCC
informs you when the offset of such a field has changed in GCC 4.4.
For example there is no longer a 4-bit padding between field <code>a</code>
and <code>b</code> in this structure:
</p>
<div>
<pre>struct foo
{
  char a:4;
  char b:8;
} __attribute__ ((packed));
</pre></div>
<p>This warning is enabled by default.  Use
<samp>-Wno-packed-bitfield-compat</samp> to disable this warning.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpacked-not-aligned</key>
    <name>Warn when fields in a struct with the packed attribute are misaligned</name>
    <description>
      <![CDATA[<p>Warn if a structure field with explicitly specified alignment in a
packed struct or union is misaligned.  For example, a warning will
be issued on <code>struct S</code>, like, <code>warning: alignment 1 of
'struct S' is less than 8</code>, in this code:
</p>
<div>
<div><pre>struct __attribute__ ((aligned (8))) S8 { char a[8]; };
struct __attribute__ ((packed)) S {
  struct S8 s8;
};
</pre></div></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpadded</key>
    <name>Warn when padding is required to align structure members</name>
    <description>
      <![CDATA[<p>Warn if padding is included in a structure, either to align an element
of the structure or to align the whole structure.  Sometimes when this
happens it is possible to rearrange the fields of the structure to
reduce the padding and so make the structure smaller.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wparentheses</key>
    <name>Warn about possibly missing parentheses</name>
    <description>
      <![CDATA[<p>Warn if parentheses are omitted in certain contexts, such
as when there is an assignment in a context where a truth value
is expected, or when operators are nested whose precedence people
often get confused about.
</p>
<p>Also warn if a comparison like <code>x&lt;=y&lt;=z</code> appears; this is
equivalent to <code>(x&lt;=y ? 1 : 0) &lt;= z</code>, which is a different
interpretation from that of ordinary mathematical notation.
</p>
<p>Also warn for dangerous uses of the GNU extension to
<code>?:</code> with omitted middle operand. When the condition
in the <code>?</code>: operator is a boolean expression, the omitted value is
always 1.  Often programmers expect it to be a value computed
inside the conditional expression instead.
</p>
<p>For C++ this also warns for some cases of unnecessary parentheses in
declarations, which can indicate an attempt at a function call instead
of a declaration:
</p><div>
<pre>{
  // Declares a local variable called mymutex.
  std::unique_lock&lt;std::mutex&gt; (mymutex);
  // User meant std::unique_lock&lt;std::mutex&gt; lock (mymutex);
}
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpedantic</key>
    <name>Issue warnings needed for strict compliance to the standard</name>
    <description>
      <![CDATA[<p>Issue all the warnings demanded by strict ISO C and ISO C++;
diagnose all programs that use forbidden extensions, and some other
programs that do not follow ISO C and ISO C++.  This follows the version
of the ISO C or C++ standard specified by any <samp>-std</samp> option used.
</p>
<p>Valid ISO C and ISO C++ programs should compile properly with or without
this option (though a rare few require <samp>-ansi</samp> or a
<samp>-std</samp> option specifying the version of the standard).  However,
without this option, certain GNU extensions and traditional C and C++
features are supported as well.  With this option, they are diagnosed
(or rejected with <samp>-pedantic-errors</samp>).
</p>
<p><samp>-Wpedantic</samp> does not cause warning messages for use of the
alternate keywords whose names begin and end with ‘<samp>__</samp>’.  This alternate
format can also be used to disable warnings for non-ISO ‘<samp>__intN</samp>’ types,
i.e. ‘<samp>__intN__</samp>’.
Pedantic warnings are also disabled in the expression that follows
<code>__extension__</code>.  However, only system header files should use
these escape routes; application programs should avoid them.
See <a href="Alternate-Keywords.html">Alternate Keywords</a>.
</p>
<p>Some warnings about non-conforming programs are controlled by options
other than <samp>-Wpedantic</samp>; in many cases they are implied by
<samp>-Wpedantic</samp> but can be disabled separately by their specific
option, e.g. <samp>-Wpedantic -Wno-pointer-sign</samp>.
</p>
<p>Where the standard specified with <samp>-std</samp> represents a GNU
extended dialect of C, such as ‘<samp>gnu90</samp>’ or ‘<samp>gnu99</samp>’, there is a
corresponding <em>base standard</em>, the version of ISO C on which the GNU
extended dialect is based.  Warnings from <samp>-Wpedantic</samp> are given
where they are required by the base standard.  (It does not make sense
for such warnings to be given only for features not in the specified GNU
C dialect, since by definition the GNU dialects of C include all
features the compiler supports with the given option, and there would be
nothing to warn about.)
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpedantic-ms-format</key>
    <name>Warn about none ISO msvcrt scanf/printf width extensions</name>
    <description>
      <![CDATA[<p>When used in combination with <samp>-Wformat</samp>
and <samp>-pedantic</samp> without GNU extensions, this option
disables the warnings about non-ISO <code>printf</code> / <code>scanf</code> format
width specifiers <code>I32</code>, <code>I64</code>, and <code>I</code> used on Windows targets,
which depend on the MS runtime.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpessimizing-move</key>
    <name>Warn about calling std::move on a local object in a return statement preventing copy elision</name>
    <description>
      <![CDATA[<p>This warning warns when a call to <code>std::move</code> prevents copy
elision.  A typical scenario when copy elision can occur is when returning in
a function with a class return type, when the expression being returned is the
name of a non-volatile automatic object, and is not a function parameter, and
has the same type as the function return type.
</p>
<div>
<pre>struct T {
…
};
T fn()
{
  T t;
  …
  return std::move (t);
}
</pre></div>
<p>But in this example, the <code>std::move</code> call prevents copy elision.
</p>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wplacement-new</key>
    <name>Warn for placement new expressions with undefined behavior</name>
    <description>
      <![CDATA[<p>Warn about placement new expressions with undefined behavior, such as
constructing an object in a buffer that is smaller than the type of
the object.  For example, the placement new expression below is diagnosed
because it attempts to construct an array of 64 integers in a buffer only
64 bytes large.
</p><div>
<pre>char buf [64];
new (buf) int[64];
</pre></div>
<p>This warning is enabled by default.
</p>
<dl>
<dt><code>-Wplacement-new=1</code></dt>
<dd><p>This is the default warning level of <samp>-Wplacement-new</samp>.  At this
level the warning is not issued for some strictly undefined constructs that
GCC allows as extensions for compatibility with legacy code.  For example,
the following <code>new</code> expression is not diagnosed at this level even
though it has undefined behavior according to the C++ standard because
it writes past the end of the one-element array.
</p><div>
<pre>struct S { int n, a[1]; };
S *s = (S *)malloc (sizeof *s + 31 * sizeof s-&gt;a[0]);
new (s-&gt;a)int [32]();
</pre></div>
</dd>
<dt><code>-Wplacement-new=2</code></dt>
<dd><p>At this level, in addition to diagnosing all the same constructs as at level
1, a diagnostic is also issued for placement new expressions that construct
an object in the last member of structure whose type is an array of a single
element and whose size is less than the size of the object being constructed.
While the previous example would be diagnosed, the following construct makes
use of the flexible member array extension to avoid the warning at level 2.
</p><div>
<pre>struct S { int n, a[]; };
S *s = (S *)malloc (sizeof *s + 32 * sizeof s-&gt;a[0]);
new (s-&gt;a)int [32]();
</pre></div>
</dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpmf-conversions</key>
    <name>Warn when converting the type of pointers to member functions</name>
    <description>
      <![CDATA[<p>Disable the diagnostic for converting a bound pointer to member function
to a plain pointer.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpointer-arith</key>
    <name>Warn about function pointer arithmetic</name>
    <description>
      <![CDATA[<p>Warn about anything that depends on the “size of” a function type or
of <code>void</code>.  GNU C assigns these types a size of 1, for
convenience in calculations with <code>void *</code> pointers and pointers
to functions.  In C++, warn also when an arithmetic operation involves
<code>NULL</code>.  This warning is also enabled by <samp>-Wpedantic</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpointer-compare</key>
    <name>Warn when a pointer is compared with a zero character constant</name>
    <description>
      <![CDATA[<p>Warn if a pointer is compared with a zero character constant.
This usually
means that the pointer was meant to be dereferenced.  For example:
</p>
<div>
<pre>const char *p = foo ();
if (p == '\0')
  return 42;
</pre></div>
<p>Note that the code above is invalid in C++11.
</p>
<p>This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpointer-sign</key>
    <name>Warn when a pointer differs in signedness in an assignment</name>
    <description>
      <![CDATA[<p>Warn for pointer argument passing or assignment with different signedness.
This option is only supported for C and Objective-C.  It is implied by
<samp>-Wall</samp> and by <samp>-Wpedantic</samp>, which can be disabled with
<samp>-Wno-pointer-sign</samp>.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpointer-to-int-cast</key>
    <name>Warn when a pointer is cast to an integer of a different size</name>
    <description>
      <![CDATA[<p>Suppress warnings from casts from a pointer to an integer type of a
different size.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wpragmas</key>
    <name>Warn about misuses of pragmas</name>
    <description>
      <![CDATA[<p>Warn about misuses of pragmas, such as incorrect parameters,
invalid syntax, or conflicts between pragmas.  See also
<samp>-Wunknown-pragmas</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wprio-ctor-dtor</key>
    <name>Warn if constructor or destructors with priorities from 0 to 100 are used</name>
    <description>
      <![CDATA[<p>Warn if a priority from 0 to 100 is used for constructor or destructor.
The use of constructor and destructor attributes allow you to assign a
priority to the constructor/destructor to control its order of execution
before <code>main</code> is called or after it returns.  The priority values must be
greater than 100 as the compiler reserves priority values between 0–100 for
the implementation.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wproperty-assign-default</key>
    <name>Warn if a property for an Objective-C object has no assign semantics specified</name>
    <description>
      <![CDATA[<p>Warn if a property for an Objective-C object has no assign
semantics specified.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wprotocol</key>
    <name>Warn if inherited methods are unimplemented</name>
    <description>
      <![CDATA[<p>If a class is declared to implement a protocol, a warning is issued for
every method in the protocol that is not implemented by the class.  The
default behavior is to issue a warning for every method not explicitly
implemented in the class, even if a method implementation is inherited
from the superclass.  If you use the <samp>-Wno-protocol</samp> option, then
methods inherited from the superclass are considered to be implemented,
and no warning is issued for them.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wrange-loop-construct</key>
    <name>Warn when a range-based for-loop is creating unnecessary copies</name>
    <description>
      <![CDATA[<p>This warning warns when a C++ range-based for-loop is creating an unnecessary
copy.  This can happen when the range declaration is not a reference, but
probably should be.  For example:
</p>
<div>
<pre>struct S { char arr[128]; };
void fn () {
  S arr[5];
  for (const auto x : arr) { … }
}
</pre></div>
<p>It does not warn when the type being copied is a trivially-copyable type whose
size is less than 64 bytes.
</p>
<p>This warning also warns when a loop variable in a range-based for-loop is
initialized with a value of a different type resulting in a copy.  For example:
</p>
<div>
<pre>void fn() {
  int arr[10];
  for (const double &amp;x : arr) { … }
}
</pre></div>
<p>In the example above, in every iteration of the loop a temporary value of
type <code>double</code> is created and destroyed, to which the reference
<code>const double &amp;</code> is bound.
</p>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wredundant-decls</key>
    <name>Warn about multiple declarations of the same object</name>
    <description>
      <![CDATA[<p>Warn if anything is declared more than once in the same scope, even in
cases where multiple declaration is valid and changes nothing.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wredundant-move</key>
    <name>Warn about redundant calls to std::move</name>
    <description>
      <![CDATA[<p>This warning warns about redundant calls to <code>std::move</code>; that is, when
a move operation would have been performed even without the <code>std::move</code>
call.  This happens because the compiler is forced to treat the object as if
it were an rvalue in certain situations such as returning a local variable,
where copy elision isn’t applicable.  Consider:
</p>
<div>
<pre>struct T {
…
};
T fn(T t)
{
  …
  return std::move (t);
}
</pre></div>
<p>Here, the <code>std::move</code> call is redundant.  Because G++ implements Core
Issue 1579, another example is:
</p>
<div>
<pre>struct T { // convertible to U
…
};
struct U {
…
};
U fn()
{
  T t;
  …
  return std::move (t);
}
</pre></div>
<p>In this example, copy elision isn’t applicable because the type of the
expression being returned and the function return type differ, yet G++
treats the return value as if it were designated by an rvalue.
</p>
<p>This warning is enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wredundant-tags</key>
    <name>Warn when a class or enumerated type is referenced using a redundant class-key</name>
    <description>
      <![CDATA[<p>Warn about redundant class-key and enum-key in references to class types
and enumerated types in contexts where the key can be eliminated without
causing an ambiguity.  For example:
</p>
<div>
<pre>struct foo;
struct foo *p;   // warn that keyword struct can be eliminated
</pre></div>
<p>On the other hand, in this example there is no warning:
</p>
<div>
<pre>struct foo;
void foo ();   // "hides" struct foo
void bar (struct foo&amp;);  // no warning, keyword struct is necessary
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wregister</key>
    <name>Warn about uses of register storage specifier</name>
    <description>
      <![CDATA[<p>Warn on uses of the <code>register</code> storage class specifier, except
when it is part of the GNU <a href="Explicit-Register-Variables.html">Variables in Specified Registers</a> extension.
The use of the <code>register</code> keyword as storage class specifier has
been deprecated in C++11 and removed in C++17.
Enabled by default with <samp>-std=c++17</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wreorder</key>
    <name>Warn when the compiler reorders code</name>
    <description>
      <![CDATA[<p>Warn when the order of member initializers given in the code does not
match the order in which they must be executed.  For instance:
</p>
<div>
<pre>struct A {
  int i;
  int j;
  A(): j (0), i (1) { }
};
</pre></div>
<p>The compiler rearranges the member initializers for <code>i</code>
and <code>j</code> to match the declaration order of the members, emitting
a warning to that effect.  This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wrestrict</key>
    <name>Warn when an argument passed to a restrict-qualified parameter aliases with another argument</name>
    <description>
      <![CDATA[<p>Warn when an object referenced by a <code>restrict</code>-qualified parameter
(or, in C++, a <code>__restrict</code>-qualified parameter) is aliased by another
argument, or when copies between such objects overlap.  For example,
the call to the <code>strcpy</code> function below attempts to truncate the string
by replacing its initial characters with the last four.  However, because
the call writes the terminating NUL into <code>a[4]</code>, the copies overlap and
the call is diagnosed.
</p>
<div>
<pre>void foo (void)
{
  char a[] = "abcd1234";
  strcpy (a, a + 4);
  …
}
</pre></div>
<p>The <samp>-Wrestrict</samp> option detects some instances of simple overlap
even without optimization but works best at <samp>-O2</samp> and above.  It
is included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wreturn-local-addr</key>
    <name>Warn about returning a pointer/reference to a local or temporary variable</name>
    <description>
      <![CDATA[<p>Warn about returning a pointer (or in C++, a reference) to a
variable that goes out of scope after the function returns.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wreturn-mismatch</key>
    <name>Warn whenever void-returning functions return a non-void expressions, or a return expression is missing in a function not returning void</name>
    <description>
      <![CDATA[<p>Warn about return statements without an expressions in functions which
do not return <code>void</code>.  Also warn about a <code>return</code> statement
with an expression in a function whose return type is <code>void</code>,
unless the expression type is also <code>void</code>.  As a GNU extension, the
latter case is accepted without a warning unless <samp>-Wpedantic</samp> is
used.
</p>
<p>Attempting to use the return value of a non-<code>void</code> function other
than <code>main</code> that flows off the end by reaching the closing curly
brace that terminates the function is undefined.
</p>
<p>This warning is specific to C and enabled by default.  In C99 and later
language dialects, it is treated as an error.  It can be downgraded
to a warning using <samp>-fpermissive</samp> (along with other warnings),
or for just this warning, with <samp>-Wno-error=return-mismatch</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wreturn-type</key>
    <name>Warn whenever a function's return type defaults to "int" (C), or about inconsistent return types (C++)</name>
    <description>
      <![CDATA[<p>Warn whenever a function is defined with a return type that defaults to
<code>int</code> (unless <samp>-Wimplicit-int</samp> is active, which takes
precedence).  Also warn if execution may reach the end of the function
body, or if the function does not contain any return statement at all.
</p>
<p>Attempting to use the return value of a non-<code>void</code> function other
than <code>main</code> that flows off the end by reaching the closing curly
brace that terminates the function is undefined.
</p>
<p>Unlike in C, in C++, flowing off the end of a non-<code>void</code> function other
than <code>main</code> results in undefined behavior even when the value of
the function is not used.
</p>
<p>This warning is enabled by default in C++ and by <samp>-Wall</samp> otherwise.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wscalar-storage-order</key>
    <name>Warn on suspicious constructs involving reverse scalar storage order</name>
    <description>
      <![CDATA[<p>Warn on suspicious constructs involving reverse scalar storage order.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wselector</key>
    <name>Warn if a selector has multiple methods</name>
    <description>
      <![CDATA[<p>Warn if multiple methods of different types for the same selector are
found during compilation.  The check is performed on the list of methods
in the final stage of compilation.  Additionally, a check is performed
for each selector appearing in a <code>@selector(…)</code>
expression, and a corresponding method for that selector has been found
during compilation.  Because these checks scan the method table only at
the end of compilation, these warnings are not produced if the final
stage of compilation is not reached, for example because an error is
found during compilation, or because the <samp>-fsyntax-only</samp> option is
being used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wself-move</key>
    <name>Warn when a value is moved to itself with std::move</name>
    <description>
      <![CDATA[<p>This warning warns when a value is moved to itself with <code>std::move</code>.
Such a <code>std::move</code> typically has no effect.
</p>
<div>
<pre>struct T {
…
};
void fn()
{
  T t;
  …
  t = std::move (t);
}
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsequence-point</key>
    <name>Warn about possible violations of sequence point rules</name>
    <description>
      <![CDATA[<p>Warn about code that may have undefined semantics because of violations
of sequence point rules in the C and C++ standards.
</p>
<p>The C and C++ standards define the order in which expressions in a C/C++
program are evaluated in terms of <em>sequence points</em>, which represent
a partial ordering between the execution of parts of the program: those
executed before the sequence point, and those executed after it.  These
occur after the evaluation of a full expression (one which is not part
of a larger expression), after the evaluation of the first operand of a
<code>&amp;&amp;</code>, <code>||</code>, <code>? :</code> or <code>,</code> (comma) operator, before a
function is called (but after the evaluation of its arguments and the
expression denoting the called function), and in certain other places.
Other than as expressed by the sequence point rules, the order of
evaluation of subexpressions of an expression is not specified.  All
these rules describe only a partial order rather than a total order,
since, for example, if two functions are called within one expression
with no sequence point between them, the order in which the functions
are called is not specified.  However, the standards committee have
ruled that function calls do not overlap.
</p>
<p>It is not specified when between sequence points modifications to the
values of objects take effect.  Programs whose behavior depends on this
have undefined behavior; the C and C++ standards specify that “Between
the previous and next sequence point an object shall have its stored
value modified at most once by the evaluation of an expression.
Furthermore, the prior value shall be read only to determine the value
to be stored.”.  If a program breaks these rules, the results on any
particular implementation are entirely unpredictable.
</p>
<p>Examples of code with undefined behavior are <code>a = a++;</code>, <code>a[n]
= b[n++]</code> and <code>a[i++] = i;</code>.  Some more complicated cases are not
diagnosed by this option, and it may give an occasional false positive
result, but in general it has been found fairly effective at detecting
this sort of problem in programs.
</p>
<p>The C++17 standard will define the order of evaluation of operands in
more cases: in particular it requires that the right-hand side of an
assignment be evaluated before the left-hand side, so the above
examples are no longer undefined.  But this option will still warn
about them, to help people avoid writing code that is undefined in C
and earlier revisions of C++.
</p>
<p>The standard is worded confusingly, therefore there is some debate
over the precise meaning of the sequence point rules in subtle cases.
Links to discussions of the problem, including proposed formal
definitions, may be found on the GCC readings page, at
<a href="https://gcc.gnu.org/readings.html">https://gcc.gnu.org/readings.html</a>.
</p>
<p>This warning is enabled by <samp>-Wall</samp> for C and C++.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wshadow</key>
    <name>Warn when one variable shadows another</name>
    <description>
      <![CDATA[<p>Warn whenever a local variable or type declaration shadows another
variable, parameter, type, class member (in C++), or instance variable
(in Objective-C) or whenever a built-in function is shadowed.  Note
that in C++, the compiler warns if a local variable shadows an
explicit typedef, but not if it shadows a struct/class/enum.
If this warning is enabled, it includes also all instances of
local shadowing.  This means that <samp>-Wno-shadow=local</samp>
and <samp>-Wno-shadow=compatible-local</samp> are ignored when
<samp>-Wshadow</samp> is used.
Same as <samp>-Wshadow=global</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wshadow-ivar</key>
    <name>Warn if a local declaration hides an instance variable</name>
    <description>
      <![CDATA[<p>Warn whenever a local variable shadows an instance variable in an
Objective-C method.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wshift-count-negative</key>
    <name>Warn if shift count is negative</name>
    <description>
      <![CDATA[<p>Controls warnings if a shift count is negative.
This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wshift-count-overflow</key>
    <name>Warn if shift count &gt;= width of type</name>
    <description>
      <![CDATA[<p>Controls warnings if a shift count is greater than or equal to the bit width
of the type.  This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wshift-negative-value</key>
    <name>Warn if left shifting a negative value</name>
    <description>
      <![CDATA[<p>Warn if left shifting a negative value.  This warning is enabled by
<samp>-Wextra</samp> in C99 (and newer) and C++11 to C++17 modes.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wshift-overflow</key>
    <name>Warn if left shift of a signed value overflows</name>
    <description>
      <![CDATA[<p>These options control warnings about left shift overflows.
</p>
<dl>
<dt><code>-Wshift-overflow=1</code></dt>
<dd><p>This is the warning level of <samp>-Wshift-overflow</samp> and is enabled
by default in C99 and C++11 modes (and newer).  This warning level does
not warn about left-shifting 1 into the sign bit.  (However, in C, such
an overflow is still rejected in contexts where an integer constant expression
is required.)  No warning is emitted in C++20 mode (and newer), as signed left
shifts always wrap.
</p>
</dd>
<dt><code>-Wshift-overflow=2</code></dt>
<dd><p>This warning level also warns about left-shifting 1 into the sign bit,
unless C++14 mode (or newer) is active.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsign-compare</key>
    <name>Warn about signed-unsigned comparisons</name>
    <description>
      <![CDATA[<p>Warn when a comparison between signed and unsigned values could produce
an incorrect result when the signed value is converted to unsigned.
In C++, this warning is also enabled by <samp>-Wall</samp>.  In C, it is
also enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsign-conversion</key>
    <name>Warn for implicit type conversions between signed and unsigned integers</name>
    <description>
      <![CDATA[<p>Warn for implicit conversions that may change the sign of an integer
value, like assigning a signed integer expression to an unsigned
integer variable. An explicit cast silences the warning. In C, this
option is enabled also by <samp>-Wconversion</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsign-promo</key>
    <name>Warn when overload promotes from unsigned to signed</name>
    <description>
      <![CDATA[<p>Warn when overload resolution chooses a promotion from unsigned or
enumerated type to a signed type, over a conversion to an unsigned type of
the same size.  Previous versions of G++ tried to preserve
unsignedness, but the standard mandates the current behavior.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsized-deallocation</key>
    <name>Warn about missing sized deallocation functions</name>
    <description>
      <![CDATA[<p>Warn about a definition of an unsized deallocation function
</p><div>
<pre>void operator delete (void *) noexcept;
void operator delete[] (void *) noexcept;
</pre></div>
<p>without a definition of the corresponding sized deallocation function
</p><div>
<pre>void operator delete (void *, std::size_t) noexcept;
void operator delete[] (void *, std::size_t) noexcept;
</pre></div>
<p>or vice versa.  Enabled by <samp>-Wextra</samp> along with
<samp>-fsized-deallocation</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsizeof-array-argument</key>
    <name>Warn when sizeof is applied on a parameter declared as an array</name>
    <description>
      <![CDATA[<p>Warn when the <code>sizeof</code> operator is applied to a parameter that is
declared as an array in a function definition.  This warning is enabled by
default for C and C++ programs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsizeof-array-div</key>
    <name>Warn about divisions of two sizeof operators when the first one is applied to an array and the divisor does not equal the size of the array element</name>
    <description>
      <![CDATA[<p>Warn about divisions of two sizeof operators when the first one is applied
to an array and the divisor does not equal the size of the array element.
In such a case, the computation will not yield the number of elements in the
array, which is likely what the user intended.  This warning warns e.g. about
</p><div>
<pre>int fn ()
{
  int arr[10];
  return sizeof (arr) / sizeof (short);
}
</pre></div>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsizeof-pointer-div</key>
    <name>Warn about suspicious divisions of two sizeof expressions that don't work correctly with pointers</name>
    <description>
      <![CDATA[<p>Warn for suspicious divisions of two sizeof expressions that divide
the pointer size by the element size, which is the usual way to compute
the array size but won’t work out correctly with pointers.  This warning
warns e.g. about <code>sizeof (ptr) / sizeof (ptr[0])</code> if <code>ptr</code> is
not an array, but a pointer.  This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsizeof-pointer-memaccess</key>
    <name>Warn about suspicious length parameters to certain string functions if the argument uses sizeof</name>
    <description>
      <![CDATA[<p>Warn for suspicious length parameters to certain string and memory built-in
functions if the argument uses <code>sizeof</code>.  This warning triggers for
example for <code>memset (ptr, 0, sizeof (ptr));</code> if <code>ptr</code> is not
an array, but a pointer, and suggests a possible fix, or about
<code>memcpy (&amp;foo, ptr, sizeof (&amp;foo));</code>.  <samp>-Wsizeof-pointer-memaccess</samp>
also warns about calls to bounded string copy functions like <code>strncat</code>
or <code>strncpy</code> that specify as the bound a <code>sizeof</code> expression of
the source array.  For example, in the following function the call to
<code>strncat</code> specifies the size of the source string as the bound.  That
is almost certainly a mistake and so the call is diagnosed.
</p><div>
<pre>void make_file (const char *name)
{
  char path[PATH_MAX];
  strncpy (path, name, sizeof path - 1);
  strncat (path, ".text", sizeof ".text");
  …
}
</pre></div>
<p>The <samp>-Wsizeof-pointer-memaccess</samp> option is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstack-protector</key>
    <name>Warn when not issuing stack smashing protection for some reason</name>
    <description>
      <![CDATA[<p>This option is only active when <samp>-fstack-protector</samp> is active.  It
warns about functions that are not protected against stack smashing.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstack-usage</key>
    <name>Warn if stack usage might exceed &lt;byte-size&gt;</name>
    <description>
      <![CDATA[<p>Warn if the stack usage of a function might exceed <var>byte-size</var>.
The computation done to determine the stack usage is conservative.
Any space allocated via <code>alloca</code>, variable-length arrays, or related
constructs is included by the compiler when determining whether or not to
issue a warning.
</p>
<p>The message is in keeping with the output of <samp>-fstack-usage</samp>.
</p>
<ul>
<li>If the stack usage is fully static but exceeds the specified amount, it’s:

<div>
<pre>  warning: stack usage is 1120 bytes
</pre></div>
</li><li>If the stack usage is (partly) dynamic but bounded, it’s:

<div>
<pre>  warning: stack usage might be 1648 bytes
</pre></div>
</li><li>If the stack usage is (partly) dynamic and not bounded, it’s:

<div>
<pre>  warning: stack usage might be unbounded
</pre></div>
</li></ul>
<p><samp>-Wstack-usage=</samp>‘<samp>PTRDIFF_MAX</samp>’ is enabled by default.
Warnings controlled by the option can be disabled either by specifying
<var>byte-size</var> of ‘<samp>SIZE_MAX</samp>’ or more or by
<samp>-Wno-stack-usage</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstrict-aliasing</key>
    <name>Warn about code which might break strict aliasing rules</name>
    <description>
      <![CDATA[<p>This option is only active when <samp>-fstrict-aliasing</samp> is active.
It warns about code that might break the strict aliasing rules that the
compiler is using for optimization.
Higher levels correspond to higher accuracy (fewer false positives).
Higher levels also correspond to more effort, similar to the way <samp>-O</samp> 
works.
<samp>-Wstrict-aliasing</samp> is equivalent to <samp>-Wstrict-aliasing=3</samp>.
</p>
<p>Level 1: Most aggressive, quick, least accurate.
Possibly useful when higher levels
do not warn but <samp>-fstrict-aliasing</samp> still breaks the code, as it has very few
false negatives.  However, it has many false positives.
Warns for all pointer conversions between possibly incompatible types,
even if never dereferenced.  Runs in the front end only.
</p>
<p>Level 2: Aggressive, quick, not too precise.
May still have many false positives (not as many as level 1 though),
and few false negatives (but possibly more than level 1).
Unlike level 1, it only warns when an address is taken.  Warns about
incomplete types.  Runs in the front end only.
</p>
<p>Level 3 (default for <samp>-Wstrict-aliasing</samp>):
Should have very few false positives and few false
negatives.  Slightly slower than levels 1 or 2 when optimization is enabled.
Takes care of the common pun+dereference pattern in the front end:
<code>*(int*)&amp;some_float</code>.
If optimization is enabled, it also runs in the back end, where it deals
with multiple statement cases using flow-sensitive points-to information.
Only warns when the converted pointer is dereferenced.
Does not warn about incomplete types.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstrict-flex-arrays</key>
    <name>Warn about improper usages of flexible array members according to the level of -fstrict-flex-arrays</name>
    <description>
      <![CDATA[<p>Warn about improper usages of flexible array members
according to the <var>level</var> of the <code>strict_flex_array (<var>level</var>)</code>
attribute attached to the trailing array field of a structure if it’s
available, otherwise according to the <var>level</var> of the option
<samp>-fstrict-flex-arrays=<var>level</var></samp>.  See <a href="Common-Variable-Attributes.html">Common Variable Attributes</a>,
for more information about the attribute, and <a href="C-Dialect-Options.html">Options Controlling C Dialect</a> for
more information about the option.  <code>-Wstrict-flex-arrays</code>
is effective only when <var>level</var> is greater than 0.
</p>
<p>When <var>level</var>=1, warnings are issued for a trailing array reference
of a structure that have 2 or more elements if the trailing array is referenced
as a flexible array member.
</p>
<p>When <var>level</var>=2, in addition to <var>level</var>=1, additional warnings are
issued for a trailing one-element array reference of a structure
if the array is referenced as a flexible array member.
</p>
<p>When <var>level</var>=3, in addition to <var>level</var>=2, additional warnings are
issued for a trailing zero-length array reference of a structure
if the array is referenced as a flexible array member.
</p>
<p>This option is more effective when <samp>-ftree-vrp</samp> is active (the
default for <samp>-O2</samp> and above) but some warnings may be diagnosed
even without optimization.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstrict-null-sentinel</key>
    <name>Warn about uncasted NULL used as sentinel</name>
    <description>
      <![CDATA[<p>Warn about the use of an uncasted <code>NULL</code> as sentinel.  When
compiling only with GCC this is a valid sentinel, as <code>NULL</code> is defined
to <code>__null</code>.  Although it is a null pointer constant rather than a
null pointer, it is guaranteed to be of the same size as a pointer.
But this use is not portable across different compilers.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstrict-overflow</key>
    <name>Warn about optimizations that assume that signed overflow is undefined</name>
    <description>
      <![CDATA[<p>This option is only active when signed overflow is undefined.
It warns about cases where the compiler optimizes based on the
assumption that signed overflow does not occur.  Note that it does not
warn about all cases where the code might overflow: it only warns
about cases where the compiler implements some optimization.  Thus
this warning depends on the optimization level.
</p>
<p>An optimization that assumes that signed overflow does not occur is
perfectly safe if the values of the variables involved are such that
overflow never does, in fact, occur.  Therefore this warning can
easily give a false positive: a warning about code that is not
actually a problem.  To help focus on important issues, several
warning levels are defined.  No warnings are issued for the use of
undefined signed overflow when estimating how many iterations a loop
requires, in particular when determining whether a loop will be
executed at all.
</p>
<dl>
<dt><code>-Wstrict-overflow=1</code></dt>
<dd><p>Warn about cases that are both questionable and easy to avoid.  For
example the compiler simplifies
<code>x + 1 &gt; x</code> to <code>1</code>.  This level of
<samp>-Wstrict-overflow</samp> is enabled by <samp>-Wall</samp>; higher levels
are not, and must be explicitly requested.
</p>
</dd>
<dt><code>-Wstrict-overflow=2</code></dt>
<dd><p>Also warn about other cases where a comparison is simplified to a
constant.  For example: <code>abs (x) &gt;= 0</code>.  This can only be
simplified when signed integer overflow is undefined, because
<code>abs (INT_MIN)</code> overflows to <code>INT_MIN</code>, which is less than
zero.  <samp>-Wstrict-overflow</samp> (with no level) is the same as
<samp>-Wstrict-overflow=2</samp>.
</p>
</dd>
<dt><code>-Wstrict-overflow=3</code></dt>
<dd><p>Also warn about other cases where a comparison is simplified.  For
example: <code>x + 1 &gt; 1</code> is simplified to <code>x &gt; 0</code>.
</p>
</dd>
<dt><code>-Wstrict-overflow=4</code></dt>
<dd><p>Also warn about other simplifications not covered by the above cases.
For example: <code>(x * 10) / 5</code> is simplified to <code>x * 2</code>.
</p>
</dd>
<dt><code>-Wstrict-overflow=5</code></dt>
<dd><p>Also warn about cases where the compiler reduces the magnitude of a
constant involved in a comparison.  For example: <code>x + 2 &gt; y</code> is
simplified to <code>x + 1 &gt;= y</code>.  This is reported only at the
highest warning level because this simplification applies to many
comparisons, so this warning level gives a very large number of
false positives.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstrict-prototypes</key>
    <name>Warn about unprototyped function declarations</name>
    <description>
      <![CDATA[<p>Warn if a function is declared or defined without specifying the
argument types.  (An old-style function definition is permitted without
a warning if preceded by a declaration that specifies the argument
types.)
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstrict-selector-match</key>
    <name>Warn if type signatures of candidate methods do not match exactly</name>
    <description>
      <![CDATA[<p>Warn if multiple methods with differing argument and/or return types are
found for a given selector when attempting to send a message using this
selector to a receiver of type <code>id</code> or <code>Class</code>.  When this flag
is off (which is the default behavior), the compiler omits such warnings
if any differences found are confined to types that share the same size
and alignment.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstring-compare</key>
    <name>Warn about calls to strcmp and strncmp used in equality expressions that are necessarily true or false due to the length of one and size of the other argument</name>
    <description>
      <![CDATA[<p>Warn for calls to <code>strcmp</code> and <code>strncmp</code> whose result is
determined to be either zero or non-zero in tests for such equality
owing to the length of one argument being greater than the size of
the array the other argument is stored in (or the bound in the case
of <code>strncmp</code>).  Such calls could be mistakes.  For example,
the call to <code>strcmp</code> below is diagnosed because its result is
necessarily non-zero irrespective of the contents of the array <code>a</code>.
</p>
<div>
<pre>extern char a[4];
void f (char *d)
{
  strcpy (d, "string");
  …
  if (0 == strcmp (a, d))   // cannot be true
    puts ("a and d are the same");
}
</pre></div>
<p><samp>-Wstring-compare</samp> is enabled by <samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstringop-overflow</key>
    <name>Under the control of Object Size type, warn about buffer overflow in string manipulation functions like memcpy and strcpy</name>
    <description>
      <![CDATA[<p>Warn for calls to string manipulation functions such as <code>memcpy</code> and
<code>strcpy</code> that are determined to overflow the destination buffer.  The
optional argument is one greater than the type of Object Size Checking to
perform to determine the size of the destination.  See <a href="Object-Size-Checking.html">Object Size Checking</a>.
The argument is meaningful only for functions that operate on character arrays
but not for raw memory functions like <code>memcpy</code> which always make use
of Object Size type-0.  The option also warns for calls that specify a size
in excess of the largest possible object or at most <code>SIZE_MAX / 2</code> bytes.
The option produces the best results with optimization enabled but can detect
a small subset of simple buffer overflows even without optimization in
calls to the GCC built-in functions like <code>__builtin_memcpy</code> that
correspond to the standard functions.  In any case, the option warns about
just a subset of buffer overflows detected by the corresponding overflow
checking built-ins.  For example, the option issues a warning for
the <code>strcpy</code> call below because it copies at least 5 characters
(the string <code>"blue"</code> including the terminating NUL) into the buffer
of size 4.
</p>
<div>
<pre>enum Color { blue, purple, yellow };
const char* f (enum Color clr)
{
  static char buf [4];
  const char *str;
  switch (clr)
    {
      case blue: str = "blue"; break;
      case purple: str = "purple"; break;
      case yellow: str = "yellow"; break;
    }

  return strcpy (buf, str);   // warning here
}
</pre></div>
<p>Option <samp>-Wstringop-overflow=2</samp> is enabled by default.
</p>
<dl>
<dt><a id="index-Wno-stringop-overflow-1"></a>
<a id="index-Wstringop-overflow-1"></a><span><code>-Wstringop-overflow</code><a href="#index-Wstringop-overflow-1"> ¶</a></span></dt>
<dt><code>-Wstringop-overflow=1</code></dt>
<dd><p>The <samp>-Wstringop-overflow=1</samp> option uses type-zero Object Size Checking
to determine the sizes of destination objects.  At this setting the option
does not warn for writes past the end of subobjects of larger objects accessed
by pointers unless the size of the largest surrounding object is known.  When
the destination may be one of several objects it is assumed to be the largest
one of them.  On Linux systems, when optimization is enabled at this setting
the option warns for the same code as when the <code>_FORTIFY_SOURCE</code> macro
is defined to a non-zero value.
</p>
</dd>
<dt><code>-Wstringop-overflow=2</code></dt>
<dd><p>The <samp>-Wstringop-overflow=2</samp> option uses type-one Object Size Checking
to determine the sizes of destination objects.  At this setting the option
warns about overflows when writing to members of the largest complete
objects whose exact size is known.  However, it does not warn for excessive
writes to the same members of unknown objects referenced by pointers since
they may point to arrays containing unknown numbers of elements.  This is
the default setting of the option.
</p>
</dd>
<dt><code>-Wstringop-overflow=3</code></dt>
<dd><p>The <samp>-Wstringop-overflow=3</samp> option uses type-two Object Size Checking
to determine the sizes of destination objects.  At this setting the option
warns about overflowing the smallest object or data member.  This is the
most restrictive setting of the option that may result in warnings for safe
code.
</p>
</dd>
<dt><code>-Wstringop-overflow=4</code></dt>
<dd><p>The <samp>-Wstringop-overflow=4</samp> option uses type-three Object Size Checking
to determine the sizes of destination objects.  At this setting the option
warns about overflowing any data members, and when the destination is
one of several objects it uses the size of the largest of them to decide
whether to issue a warning.  Similarly to <samp>-Wstringop-overflow=3</samp> this
setting of the option may result in warnings for benign code.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstringop-overread</key>
    <name>Warn about reading past the end of a source array in string manipulation functions like memchr and memcpy</name>
    <description>
      <![CDATA[<p>Warn for calls to string manipulation functions such as <code>memchr</code>, or
<code>strcpy</code> that are determined to read past the end of the source
sequence.
</p>
<p>Option <samp>-Wstringop-overread</samp> is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wstringop-truncation</key>
    <name>Warn about truncation in string manipulation functions like strncat and strncpy</name>
    <description>
      <![CDATA[<p>Warn for calls to bounded string manipulation functions
such as <code>strncat</code>,
<code>strncpy</code>, and <code>stpncpy</code> that may either truncate the copied string
or leave the destination unchanged.
</p>
<p>In the following example, the call to <code>strncat</code> specifies a bound that
is less than the length of the source string.  As a result, the copy of
the source will be truncated and so the call is diagnosed.  To avoid the
warning use <code>bufsize - strlen (buf) - 1)</code> as the bound.
</p>
<div>
<pre>void append (char *buf, size_t bufsize)
{
  strncat (buf, ".txt", 3);
}
</pre></div>
<p>As another example, the following call to <code>strncpy</code> results in copying
to <code>d</code> just the characters preceding the terminating NUL, without
appending the NUL to the end.  Assuming the result of <code>strncpy</code> is
necessarily a NUL-terminated string is a common mistake, and so the call
is diagnosed.  To avoid the warning when the result is not expected to be
NUL-terminated, call <code>memcpy</code> instead.
</p>
<div>
<pre>void copy (char *d, const char *s)
{
  strncpy (d, s, strlen (s));
}
</pre></div>
<p>In the following example, the call to <code>strncpy</code> specifies the size
of the destination buffer as the bound.  If the length of the source
string is equal to or greater than this size the result of the copy will
not be NUL-terminated.  Therefore, the call is also diagnosed.  To avoid
the warning, specify <code>sizeof buf - 1</code> as the bound and set the last
element of the buffer to <code>NUL</code>.
</p>
<div>
<pre>void copy (const char *s)
{
  char buf[80];
  strncpy (buf, s, sizeof buf);
  …
}
</pre></div>
<p>In situations where a character array is intended to store a sequence
of bytes with no terminating <code>NUL</code> such an array may be annotated
with attribute <code>nonstring</code> to avoid this warning.  Such arrays,
however, are not suitable arguments to functions that expect
<code>NUL</code>-terminated strings.  To help detect accidental misuses of
such arrays GCC issues warnings unless it can prove that the use is
safe.  See <a href="Common-Variable-Attributes.html">Common Variable Attributes</a>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsubobject-linkage</key>
    <name>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage</name>
    <description>
      <![CDATA[<p>Do not warn
if a class type has a base or a field whose type uses the anonymous
namespace or depends on a type with no linkage.  If a type A depends on
a type B with no or internal linkage, defining it in multiple
translation units would be an ODR violation because the meaning of B
is different in each translation unit.  If A only appears in a single
translation unit, the best way to silence the warning is to give it
internal linkage by putting it in an anonymous namespace as well.  The
compiler doesn’t give this warning for types defined in the main .C
file, as those are unlikely to have multiple definitions.
<samp>-Wsubobject-linkage</samp> is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=cold</key>
    <name>Warn about functions which might be candidates for __attribute__((cold))</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=const</key>
    <name>Warn about functions which might be candidates for __attribute__((const))</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=format</key>
    <name>Warn about functions which might be candidates for format attributes</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=malloc</key>
    <name>Warn about functions which might be candidates for __attribute__((malloc))</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=noreturn</key>
    <name>Warn about functions which might be candidates for __attribute__((noreturn))</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=pure</key>
    <name>Warn about functions which might be candidates for __attribute__((pure))</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-attribute=returns_nonnull</key>
    <name>Warn about functions which might be candidates for __attribute__((returns_nonnull))</name>
    <description>
      <![CDATA[<p>Warn for cases where adding an attribute may be beneficial. The
attributes currently supported are listed below.
</p>
<dl>
<dt><a id="index-Wno-suggest-attribute_003dpure"></a>
<a id="index-Wsuggest-attribute_003dconst"></a>
<a id="index-Wno-suggest-attribute_003dconst"></a>
<a id="index-Wsuggest-attribute_003dnoreturn"></a>
<a id="index-Wno-suggest-attribute_003dnoreturn"></a>
<a id="index-Wmissing-noreturn"></a>
<a id="index-Wno-missing-noreturn"></a>
<a id="index-Wsuggest-attribute_003dmalloc"></a>
<a id="index-Wno-suggest-attribute_003dmalloc"></a>
<a id="index-Wsuggest-attribute_003dpure"></a><span><code>-Wsuggest-attribute=pure</code><a href="#index-Wsuggest-attribute_003dpure"> ¶</a></span></dt>
<dt><code>-Wsuggest-attribute=const</code></dt>
<dt><code>-Wsuggest-attribute=noreturn</code></dt>
<dt><code>-Wmissing-noreturn</code></dt>
<dt><code>-Wsuggest-attribute=malloc</code></dt>
<dt><code>-Wsuggest-attribute=returns_nonnull</code></dt>
<dt><code>-Wno-suggest-attribute=returns_nonnull</code></dt>
<dd>
<p>Warn about functions that might be candidates for attributes
<code>pure</code>, <code>const</code>, <code>noreturn</code>, <code>malloc</code> or <code>returns_nonnull</code>. The compiler
only warns for functions visible in other compilation units or (in the case of
<code>pure</code> and <code>const</code>) if it cannot prove that the function returns
normally. A function returns normally if it doesn’t contain an infinite loop or
return abnormally by throwing, calling <code>abort</code> or trapping.  This analysis
requires option <samp>-fipa-pure-const</samp>, which is enabled by default at
<samp>-O</samp> and higher.  Higher optimization levels improve the accuracy
of the analysis.
</p>
</dd>
<dt><a id="index-Wmissing-format-attribute"></a>
<a id="index-Wno-suggest-attribute_003dformat"></a>
<a id="index-Wno-missing-format-attribute"></a>
<a id="index-Wformat-2"></a>
<a id="index-Wno-format-1"></a>
<a id="index-Wsuggest-attribute_003dformat"></a><span><code>-Wsuggest-attribute=format</code><a href="#index-Wsuggest-attribute_003dformat"> ¶</a></span></dt>
<dt><code>-Wmissing-format-attribute</code></dt>
<dd>
<p>Warn about function pointers that might be candidates for <code>format</code>
attributes.  Note these are only possible candidates, not absolute ones.
GCC guesses that function pointers with <code>format</code> attributes that
are used in assignment, initialization, parameter passing or return
statements should have a corresponding <code>format</code> attribute in the
resulting type.  I.e. the left-hand side of the assignment or
initialization, the type of the parameter variable, or the return type
of the containing function respectively should also have a <code>format</code>
attribute to avoid the warning.
</p>
<p>GCC also warns about function definitions that might be
candidates for <code>format</code> attributes.  Again, these are only
possible candidates.  GCC guesses that <code>format</code> attributes
might be appropriate for any function that calls a function like
<code>vprintf</code> or <code>vscanf</code>, but this might not always be the
case, and some functions for which <code>format</code> attributes are
appropriate may not be detected.
</p>
</dd>
<dt><a id="index-Wno-suggest-attribute_003dcold"></a>
<a id="index-Wsuggest-attribute_003dcold"></a><span><code>-Wsuggest-attribute=cold</code><a href="#index-Wsuggest-attribute_003dcold"> ¶</a></span></dt>
<dd>
<p>Warn about functions that might be candidates for <code>cold</code> attribute.  This
is based on static detection and generally only warns about functions which
always leads to a call to another <code>cold</code> function such as wrappers of
C++ <code>throw</code> or fatal error reporting functions leading to <code>abort</code>.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-final-methods</key>
    <name>Warn about C++ virtual methods where adding final keyword would improve code quality</name>
    <description>
      <![CDATA[<p>Warn about virtual methods where code quality would be improved if the method
were declared with the C++11 <code>final</code> specifier,
or, if possible, its type were
declared in an anonymous namespace or with the <code>final</code> specifier.
This warning is
more effective with link-time optimization, where the information about the
class hierarchy graph is more complete. It is recommended to first consider
suggestions of <samp>-Wsuggest-final-types</samp> and then rebuild with new
annotations.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-final-types</key>
    <name>Warn about C++ polymorphic types where adding final keyword would improve code quality</name>
    <description>
      <![CDATA[<p>Warn about types with virtual methods where code quality would be improved
if the type were declared with the C++11 <code>final</code> specifier,
or, if possible,
declared in an anonymous namespace. This allows GCC to more aggressively
devirtualize the polymorphic calls. This warning is more effective with
link-time optimization,
where the information about the class hierarchy graph is
more complete.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsuggest-override</key>
    <name>Suggest that the override keyword be used when the declaration of a virtual function overrides another</name>
    <description>
      <![CDATA[<p>Warn about overriding virtual functions that are not marked with the
<code>override</code> keyword.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wswitch</key>
    <name>Warn about enumerated switches, with no default, missing a case</name>
    <description>
      <![CDATA[<p>Warn whenever a <code>switch</code> statement has an index of enumerated type
and lacks a <code>case</code> for one or more of the named codes of that
enumeration.  (The presence of a <code>default</code> label prevents this
warning.)  <code>case</code> labels outside the enumeration range also
provoke warnings when this option is used (even if there is a
<code>default</code> label).
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wswitch-bool</key>
    <name>Warn about switches with boolean controlling expression</name>
    <description>
      <![CDATA[<p>Warn when a <code>switch</code> statement has an index of boolean type
and the case values are outside the range of a boolean type.
It is possible to suppress this warning by casting the controlling
expression to a type other than <code>bool</code>.  For example:
</p><div>
<div><pre>switch ((int) (a == 4))
  {
  …
  }
</pre></div></div>
<p>This warning is enabled by default for C and C++ programs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wswitch-default</key>
    <name>Warn about enumerated switches missing a "default:" statement</name>
    <description>
      <![CDATA[<p>Warn whenever a <code>switch</code> statement does not have a <code>default</code>
case.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wswitch-enum</key>
    <name>Warn about all enumerated switches missing a specific case</name>
    <description>
      <![CDATA[<p>Warn whenever a <code>switch</code> statement has an index of enumerated type
and lacks a <code>case</code> for one or more of the named codes of that
enumeration.  <code>case</code> labels outside the enumeration range also
provoke warnings when this option is used.  The only difference
between <samp>-Wswitch</samp> and this option is that this option gives a
warning about an omitted enumeration code even if there is a
<code>default</code> label.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wswitch-outside-range</key>
    <name>Warn about switch values that are outside of the switch's type range</name>
    <description>
      <![CDATA[<p>This option controls warnings when a <code>switch</code> case has a value
that is outside of its
respective type range.  This warning is enabled by default for
C and C++ programs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wswitch-unreachable</key>
    <name>Warn about statements between switch's controlling expression and the first case</name>
    <description>
      <![CDATA[<p>Warn when a <code>switch</code> statement contains statements between the
controlling expression and the first case label, which will never be
executed.  For example:
</p><div>
<div><pre>switch (cond)
  {
   i = 15;
  …
   case 5:
  …
  }
</pre></div></div>
<p><samp>-Wswitch-unreachable</samp> does not warn if the statement between the
controlling expression and the first case label is just a declaration:
</p><div>
<div><pre>switch (cond)
  {
   int i;
  …
   case 5:
   i = 5;
  …
  }
</pre></div></div>
<p>This warning is enabled by default for C and C++ programs.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsync-nand</key>
    <name>Warn when __sync_fetch_and_nand and __sync_nand_and_fetch built-in functions are used</name>
    <description>
      <![CDATA[<p>Warn when <code>__sync_fetch_and_nand</code> and <code>__sync_nand_and_fetch</code>
built-in functions are used.  These functions changed semantics in GCC 4.4.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wsynth</key>
    <name>Deprecated</name>
    <description>
      <![CDATA[Deprecated]]>
      </description>
    </rule>
  <rule>
    <key>-Wtautological-compare</key>
    <name>Warn if a comparison always evaluates to true or false</name>
    <description>
      <![CDATA[<p>Warn if a self-comparison always evaluates to true or false.  This
warning detects various mistakes such as:
</p><div>
<pre>int i = 1;
…
if (i &gt; i) { … }
</pre></div>
<p>This warning also warns about bitwise comparisons that always evaluate
to true or false, for instance:
</p><div>
<pre>if ((a &amp; 16) == 10) { … }
</pre></div>
<p>will always be false.
</p>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtemplate-id-cdtor</key>
    <name>Warn about simple-template-id in a constructor or destructor</name>
    <description>
      <![CDATA[<p>Disable the warning about the use of simple-template-id as the declarator-id
of a constructor or destructor, which became invalid in C++20 via DR 2237.
For example:
</p>
<div>
<pre>template&lt;typename T&gt; struct S {
  S&lt;T&gt;(); // should be S();
  ~S&lt;T&gt;();  // should be ~S();
};
</pre></div>
<p><samp>-Wtemplate-id-cdtor</samp> is enabled by default with
<samp>-std=c++20</samp>; it is also enabled by <samp>-Wc++20-compat</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtemplates</key>
    <name>Warn on primary template declaration</name>
    <description>
      <![CDATA[<p>Warn when a primary template declaration is encountered.  Some coding
rules disallow templates, and this may be used to enforce that rule.
The warning is inactive inside a system header file, such as the STL, so
one can still use the STL.  One may also instantiate or specialize
templates.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wterminate</key>
    <name>Warn if a throw expression will always result in a call to terminate()</name>
    <description>
      <![CDATA[<p>Disable the warning about a throw-expression that will immediately
result in a call to <code>terminate</code>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtraditional</key>
    <name>Warn about features not present in traditional C</name>
    <description>
      <![CDATA[<p>Warn about certain constructs that behave differently in traditional and
ISO C.  Also warn about ISO C constructs that have no traditional C
equivalent, and/or problematic constructs that should be avoided.
</p>
<ul>
<li>Macro parameters that appear within string literals in the macro body.
In traditional C macro replacement takes place within string literals,
but in ISO C it does not.

</li><li>In traditional C, some preprocessor directives did not exist.
Traditional preprocessors only considered a line to be a directive
if the ‘<samp>#</samp>’ appeared in column 1 on the line.  Therefore
<samp>-Wtraditional</samp> warns about directives that traditional C
understands but ignores because the ‘<samp>#</samp>’ does not appear as the
first character on the line.  It also suggests you hide directives like
<code>#pragma</code> not understood by traditional C by indenting them.  Some
traditional implementations do not recognize <code>#elif</code>, so this option
suggests avoiding it altogether.

</li><li>A function-like macro that appears without arguments.

</li><li>The unary plus operator.

</li><li>The ‘<samp>U</samp>’ integer constant suffix, or the ‘<samp>F</samp>’ or ‘<samp>L</samp>’ floating-point
constant suffixes.  (Traditional C does support the ‘<samp>L</samp>’ suffix on integer
constants.)  Note, these suffixes appear in macros defined in the system
headers of most modern systems, e.g. the ‘<samp>_MIN</samp>’/‘<samp>_MAX</samp>’ macros in <code>&lt;limits.h&gt;</code>.
Use of these macros in user code might normally lead to spurious
warnings, however GCC’s integrated preprocessor has enough context to
avoid warning in these cases.

</li><li>A function declared external in one block and then used after the end of
the block.

</li><li>A <code>switch</code> statement has an operand of type <code>long</code>.

</li><li>A non-<code>static</code> function declaration follows a <code>static</code> one.
This construct is not accepted by some traditional C compilers.

</li><li>The ISO type of an integer constant has a different width or
signedness from its traditional type.  This warning is only issued if
the base of the constant is ten.  I.e. hexadecimal or octal values, which
typically represent bit patterns, are not warned about.

</li><li>Usage of ISO string concatenation is detected.

</li><li>Initialization of automatic aggregates.

</li><li>Identifier conflicts with labels.  Traditional C lacks a separate
namespace for labels.

</li><li>Initialization of unions.  If the initializer is zero, the warning is
omitted.  This is done under the assumption that the zero initializer in
user code appears conditioned on e.g. <code>__STDC__</code> to avoid missing
initializer warnings and relies on default initialization to zero in the
traditional C case.

</li><li>Conversions by prototypes between fixed/floating-point values and vice
versa.  The absence of these prototypes when compiling with traditional
C causes serious problems.  This is a subset of the possible
conversion warnings; for the full set use <samp>-Wtraditional-conversion</samp>.

</li><li>Use of ISO C style function definitions.  This warning intentionally is
<em>not</em> issued for prototype declarations or variadic functions
because these ISO C features appear in your code when using
libiberty’s traditional C compatibility macros, <code>PARAMS</code> and
<code>VPARAMS</code>.  This warning is also bypassed for nested functions
because that feature is already a GCC extension and thus not relevant to
traditional C compatibility.
</li></ul>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtraditional-conversion</key>
    <name>Warn of prototypes causing type conversions different from what would happen in the absence of prototype</name>
    <description>
      <![CDATA[<p>Warn if a prototype causes a type conversion that is different from what
would happen to the same argument in the absence of a prototype.  This
includes conversions of fixed point to floating and vice versa, and
conversions changing the width or signedness of a fixed-point argument
except when the same as the default promotion.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtrampolines</key>
    <name>Warn whenever a trampoline is generated</name>
    <description>
      <![CDATA[<p>Warn about trampolines generated for pointers to nested functions.
A trampoline is a small piece of data or code that is created at run
time on the stack when the address of a nested function is taken, and is
used to call the nested function indirectly.  For some targets, it is
made up of data only and thus requires no special treatment.  But, for
most targets, it is made up of code and thus requires the stack to be
made executable in order for the program to work properly.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtrigraphs</key>
    <name>Warn if trigraphs are encountered that might affect the meaning of the program</name>
    <description>
      <![CDATA[<a id="Wtrigraphs"></a><p>Warn if any trigraphs are encountered that might change the meaning of
the program.  Trigraphs within comments are not warned about,
except those that would form escaped newlines.
</p>
<p>This option is implied by <samp>-Wall</samp>.  If <samp>-Wall</samp> is not
given, this option is still enabled unless trigraphs are enabled.  To
get trigraph conversion without warnings, but get the other
<samp>-Wall</samp> warnings, use ‘<samp>-trigraphs -Wall -Wno-trigraphs</samp>’.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtrivial-auto-var-init</key>
    <name>Warn about cases where -ftrivial-auto-var-init cannot initialize an auto variable</name>
    <description>
      <![CDATA[<p>Warn when <code>-ftrivial-auto-var-init</code> cannot initialize the automatic
variable.  A common situation is an automatic variable that is declared
between the controlling expression and the first case label of a <code>switch</code>
statement.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtsan</key>
    <name>Warn about unsupported features in ThreadSanitizer</name>
    <description>
      <![CDATA[
<p>Disable warnings about unsupported features in ThreadSanitizer.
</p>
<p>ThreadSanitizer does not support <code>std::atomic_thread_fence</code> and
can report false positives.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wtype-limits</key>
    <name>Warn if a comparison is always true or always false due to the limited range of the data type</name>
    <description>
      <![CDATA[<p>Warn if a comparison is always true or always false due to the limited
range of the data type, but do not warn for constant expressions.  For
example, warn if an unsigned variable is compared against zero with
<code>&lt;</code> or <code>&gt;=</code>.  This warning is also enabled by
<samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wundeclared-selector</key>
    <name>Warn about @selector()s without previously declared methods</name>
    <description>
      <![CDATA[<p>Warn if a <code>@selector(…)</code> expression referring to an
undeclared selector is found.  A selector is considered undeclared if no
method with that name has been declared before the
<code>@selector(…)</code> expression, either explicitly in an
<code>@interface</code> or <code>@protocol</code> declaration, or implicitly in
an <code>@implementation</code> section.  This option always performs its
checks as soon as a <code>@selector(…)</code> expression is found,
while <samp>-Wselector</samp> only performs its checks in the final stage of
compilation.  This also enforces the coding style convention
that methods and selectors must be declared before being used.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wundef</key>
    <name>Warn if an undefined macro is used in an #if directive</name>
    <description>
      <![CDATA[<p>Warn if an undefined identifier is evaluated in an <code>#if</code> directive.
Such identifiers are replaced with zero.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunicode</key>
    <name>Warn about invalid forms of delimited or named escape sequences</name>
    <description>
      <![CDATA[<p>Don’t diagnose invalid forms of delimited or named escape sequences which are
treated as separate tokens.  <samp>Wunicode</samp> is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wuninitialized</key>
    <name>Warn about uninitialized automatic variables</name>
    <description>
      <![CDATA[<p>Warn if an object with automatic or allocated storage duration is used
without having been initialized.  In C++, also warn if a non-static
reference or non-static <code>const</code> member appears in a class without
constructors.
</p>
<p>In addition, passing a pointer (or in C++, a reference) to an uninitialized
object to a <code>const</code>-qualified argument of a built-in function known to
read the object is also diagnosed by this warning.
(<samp>-Wmaybe-uninitialized</samp> is issued for ordinary functions.)
</p>
<p>If you want to warn about code that uses the uninitialized value of the
variable in its own initializer, use the <samp>-Winit-self</samp> option.
</p>
<p>These warnings occur for individual uninitialized elements of
structure, union or array variables as well as for variables that are
uninitialized as a whole.  They do not occur for variables or elements
declared <code>volatile</code>.  Because these warnings depend on
optimization, the exact variables or elements for which there are
warnings depend on the precise optimization options and version of GCC
used.
</p>
<p>Note that there may be no warning about a variable that is used only
to compute a value that itself is never used, because such
computations may be deleted by data flow analysis before the warnings
are printed.
</p>
<p>In C++, this warning also warns about using uninitialized objects in
member-initializer-lists.  For example, GCC warns about <code>b</code> being
uninitialized in the following snippet:
</p>
<div>
<pre>struct A {
  int a;
  int b;
  A() : a(b) { }
};
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunknown-pragmas</key>
    <name>Warn about unrecognized pragmas</name>
    <description>
      <![CDATA[<p>Warn when a <code>#pragma</code> directive is encountered that is not understood by 
GCC.  If this command-line option is used, warnings are even issued
for unknown pragmas in system header files.  This is not the case if
the warnings are only enabled by the <samp>-Wall</samp> command-line option.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunsuffixed-float-constants</key>
    <name>Warn about unsuffixed float constants</name>
    <description>
      <![CDATA[
<p>Issue a warning for any floating constant that does not have
a suffix.  When used together with <samp>-Wsystem-headers</samp> it
warns about such constants in system header files.  This can be useful
when preparing code to use with the <code>FLOAT_CONST_DECIMAL64</code> pragma
from the decimal floating-point extension to C99.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused</key>
    <name>Enable all -Wunused- warnings</name>
    <description>
      <![CDATA[<p>All the above <samp>-Wunused</samp> options combined, except those documented
as needing to be specified explicitly.
</p>
<p>In order to get a warning about an unused function parameter, you must
either specify <samp>-Wextra -Wunused</samp> (note that <samp>-Wall</samp> implies
<samp>-Wunused</samp>), or separately specify <samp>-Wunused-parameter</samp> and/or
<samp>-Wunused-but-set-parameter</samp>.
</p>
<p><samp>-Wunused</samp> enables only <samp>-Wunused-const-variable=1</samp> rather than
<samp>-Wunused-const-variable</samp>, and only for C, not C++.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-but-set-parameter</key>
    <name>Warn when a function parameter is only set, otherwise unused</name>
    <description>
      <![CDATA[<p>Warn whenever a function parameter is assigned to, but otherwise unused
(aside from its declaration).
</p>
<p>To suppress this warning use the <code>unused</code> attribute
(see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>).
</p>
<p>This warning is also enabled by <samp>-Wunused</samp> together with
<samp>-Wextra</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-but-set-variable</key>
    <name>Warn when a variable is only set, otherwise unused</name>
    <description>
      <![CDATA[<p>Warn whenever a local variable is assigned to, but otherwise unused
(aside from its declaration).
This warning is enabled by <samp>-Wall</samp>.
</p>
<p>To suppress this warning use the <code>unused</code> attribute
(see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>).
</p>
<p>This warning is also enabled by <samp>-Wunused</samp>, which is enabled
by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-const-variable</key>
    <name>Warn when a const variable is unused</name>
    <description>
      <![CDATA[<p>Warn whenever a constant static variable is unused aside from its declaration.
</p>
<p>To suppress this warning use the <code>unused</code> attribute
(see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>).
</p>
<dl>
<dt><code>-Wunused-const-variable=1</code></dt>
<dd><p>Warn about unused static const variables defined in the main
compilation unit, but not about static const variables declared in any
header included.
</p>
<p><samp>-Wunused-const-variable=1</samp> is enabled by either
<samp>-Wunused-variable</samp> or <samp>-Wunused</samp> for C, but not for
C++. In C this declares variable storage, but in C++ this is not an
error since const variables take the place of <code>#define</code>s.
</p>
</dd>
<dt><code>-Wunused-const-variable=2</code></dt>
<dd><p>This warning level also warns for unused constant static variables in
headers (excluding system headers).  It is equivalent to the short form
<samp>-Wunused-const-variable</samp>.  This level must be explicitly
requested in both C and C++ because it might be hard to clean up all
headers included.
</p></dd>
</dl>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-function</key>
    <name>Warn when a function is unused</name>
    <description>
      <![CDATA[<p>Warn whenever a static function is declared but not defined or a
non-inline static function is unused.
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-label</key>
    <name>Warn when a label is unused</name>
    <description>
      <![CDATA[<p>Warn whenever a label is declared but not used.
This warning is enabled by <samp>-Wall</samp>.
</p>
<p>To suppress this warning use the <code>unused</code> attribute
(see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>).
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-local-typedefs</key>
    <name>Warn when typedefs locally defined in a function are not used</name>
    <description>
      <![CDATA[<p>Warn when a typedef locally defined in a function is not used.
This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-macros</key>
    <name>Warn about macros defined in the main file that are not used</name>
    <description>
      <![CDATA[<p>Warn about macros defined in the main file that are unused.  A macro
is <em>used</em> if it is expanded or tested for existence at least once.
The preprocessor also warns if the macro has not been used at the
time it is redefined or undefined.
</p>
<p>Built-in macros, macros defined on the command line, and macros
defined in include files are not warned about.
</p>
<p><em>Note:</em> If a macro is actually used, but only used in skipped
conditional blocks, then the preprocessor reports it as unused.  To avoid the
warning in such a case, you might improve the scope of the macro’s
definition by, for example, moving it into the first skipped block.
Alternatively, you could provide a dummy use with something like:
</p>
<div>
<pre>#if defined the_macro_causing_the_warning
#endif
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-parameter</key>
    <name>Warn when a function parameter is unused</name>
    <description>
      <![CDATA[<p>Warn whenever a function parameter is unused aside from its declaration.
This option is not enabled by <code>-Wunused</code> unless <code>-Wextra</code> is also
specified.
</p>
<p>To suppress this warning use the <code>unused</code> attribute
(see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>).
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-result</key>
    <name>Warn if a caller of a function, marked with attribute warn_unused_result, does not use its return value</name>
    <description>
      <![CDATA[<p>Warn if a caller of a function marked with attribute
<code>warn_unused_result</code> (see <a href="Function-Attributes.html">Declaring Attributes of Functions</a>) does not use
its return value. The default is <samp>-Wunused-result</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-value</key>
    <name>Warn when an expression value is unused</name>
    <description>
      <![CDATA[<p>Warn whenever a statement computes a result that is explicitly not
used. To suppress this warning cast the unused expression to
<code>void</code>. This includes an expression-statement or the left-hand
side of a comma expression that contains no side effects. For example,
an expression such as <code>x[i,j]</code> causes a warning, while
<code>x[(void)i,j]</code> does not.
</p>
<p>This warning is enabled by <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunused-variable</key>
    <name>Warn when a variable is unused</name>
    <description>
      <![CDATA[<p>Warn whenever a local or static variable is unused aside from its
declaration. This option implies <samp>-Wunused-const-variable=1</samp> for C,
but not for C++. This warning is enabled by <samp>-Wall</samp>.
</p>
<p>To suppress this warning use the <code>unused</code> attribute
(see <a href="Variable-Attributes.html">Specifying Attributes of Variables</a>).
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wuse-after-free</key>
    <name>Warn for uses of pointers to deallocated storage</name>
    <description>
      <![CDATA[<p>Warn about uses of pointers to dynamically allocated objects that have
been rendered indeterminate by a call to a deallocation function.
The warning is enabled at all optimization levels but may yield different
results with optimization than without.
</p>
<dl>
<dt><code>-Wuse-after-free=1</code></dt>
<dd><p>At level 1 the warning attempts to diagnose only unconditional uses
of pointers made indeterminate by a deallocation call or a successful
call to <code>realloc</code>, regardless of whether or not the call resulted
in an actual reallocation of memory.  This includes double-<code>free</code>
calls as well as uses in arithmetic and relational expressions.  Although
undefined, uses of indeterminate pointers in equality (or inequality)
expressions are not diagnosed at this level.
</p></dd>
<dt><code>-Wuse-after-free=2</code></dt>
<dd><p>At level 2, in addition to unconditional uses, the warning also diagnoses
conditional uses of pointers made indeterminate by a deallocation call.
As at level 2, uses in equality (or inequality) expressions are not
diagnosed.  For example, the second call to <code>free</code> in the following
function is diagnosed at this level:
</p><div>
<pre>struct A { int refcount; void *data; };

void release (struct A *p)
{
  int refcount = --p-&gt;refcount;
  free (p);
  if (refcount == 0)
    free (p-&gt;data);   // warning: p may be used after free
}
</pre></div>
</dd>
<dt><code>-Wuse-after-free=3</code></dt>
<dd><p>At level 3, the warning also diagnoses uses of indeterminate pointers in
equality expressions.  All uses of indeterminate pointers are undefined
but equality tests sometimes appear after calls to <code>realloc</code> as
an attempt to determine whether the call resulted in relocating the object
to a different address.  They are diagnosed at a separate level to aid
gradually transitioning legacy code to safe alternatives.  For example,
the equality test in the function below is diagnosed at this level:
</p><div>
<pre>void adjust_pointers (int**, int);

void grow (int **p, int n)
{
  int **q = (int**)realloc (p, n *= 2);
  if (q == p)
    return;
  adjust_pointers ((int**)q, n);
}
</pre></div>
<p>To avoid the warning at this level, store offsets into allocated memory
instead of pointers.  This approach obviates needing to adjust the stored
pointers after reallocation.
</p></dd>
</dl>
<p><samp>-Wuse-after-free=2</samp> is included in <samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wuseless-cast</key>
    <name>Warn about useless casts</name>
    <description>
      <![CDATA[<p>Warn when an expression is cast to its own type.  This warning does not
occur when a class object is converted to a non-reference type as that
is a way to create a temporary:
</p>
<div>
<pre>struct S { };
void g (S&amp;&amp;);
void f (S&amp;&amp; arg)
{
  g (S(arg)); // make arg prvalue so that it can bind to S&amp;&amp;
}
</pre></div>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvarargs</key>
    <name>Warn about questionable usage of the macros used to retrieve variable arguments</name>
    <description>
      <![CDATA[<p>Warn upon questionable usage of the macros used to handle variable
arguments like <code>va_start</code>.  These warnings are enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvariadic-macros</key>
    <name>Warn about using variadic macros</name>
    <description>
      <![CDATA[<p>Warn if variadic macros are used in ISO C90 mode, or if the GNU
alternate syntax is used in ISO C99 mode.  This is enabled by either
<samp>-Wpedantic</samp> or <samp>-Wtraditional</samp>.  To inhibit the warning
messages, use <samp>-Wno-variadic-macros</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvector-operation-performance</key>
    <name>Warn when a vector operation is compiled outside the SIMD</name>
    <description>
      <![CDATA[<p>Warn if vector operation is not implemented via SIMD capabilities of the
architecture.  Mainly useful for the performance tuning.
Vector operation can be implemented <code>piecewise</code>, which means that the
scalar operation is performed on every vector element; 
<code>in parallel</code>, which means that the vector operation is implemented
using scalars of wider type, which normally is more performance efficient;
and <code>as a single scalar</code>, which means that vector fits into a
scalar type.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvexing-parse</key>
    <name>Warn about the most vexing parse syntactic ambiguity</name>
    <description>
      <![CDATA[<p>Warn about the most vexing parse syntactic ambiguity.  This warns about
the cases when a declaration looks like a variable definition, but the
C++ language requires it to be interpreted as a function declaration.
For instance:
</p>
<div>
<pre>void f(double a) {
  int i();        // extern int i (void);
  int n(int(a));  // extern int n (int);
}
</pre></div>
<p>Another example:
</p>
<div>
<pre>struct S { S(int); };
void f(double a) {
  S x(int(a));   // extern struct S x (int);
  S y(int());    // extern struct S y (int (*) (void));
  S z();         // extern struct S z (void);
}
</pre></div>
<p>The warning will suggest options how to deal with such an ambiguity; e.g.,
it can suggest removing the parentheses or using braces instead.
</p>
<p>This warning is enabled by default.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvirtual-inheritance</key>
    <name>Warn on direct virtual inheritance</name>
    <description>
      <![CDATA[<p>Warn when a class is defined with a virtual direct base class.  Some
coding rules disallow multiple inheritance, and this may be used to
enforce that rule.  The warning is inactive inside a system header file,
such as the STL, so one can still use the STL.  One may also define
classes that indirectly use virtual inheritance.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvirtual-move-assign</key>
    <name>Warn if a virtual base has a non-trivial move assignment operator</name>
    <description>
      <![CDATA[<p>Suppress warnings about inheriting from a virtual base with a
non-trivial C++11 move assignment operator.  This is dangerous because
if the virtual base is reachable along more than one path, it is
moved multiple times, which can mean both objects end up in the
moved-from state.  If the move assignment operator is written to avoid
moving from a moved-from object, this warning can be disabled.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvla</key>
    <name>Warn if a variable length array is used</name>
    <description>
      <![CDATA[<p>Warn if a variable-length array is used in the code.
<samp>-Wno-vla</samp> prevents the <samp>-Wpedantic</samp> warning of
the variable-length array.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvla-larger-than</key>
    <name>Warn on unbounded uses of variable-length arrays, and on bounded uses of variable-length arrays whose bound can be larger than &lt;number&gt; bytes</name>
    <description>
      <![CDATA[<p>If this option is used, the compiler warns for declarations of
variable-length arrays whose size is either unbounded, or bounded
by an argument that allows the array size to exceed <var>byte-size</var>
bytes.  This is similar to how <samp>-Walloca-larger-than=</samp><var>byte-size</var>
works, but with variable-length arrays.
</p>
<p>Note that GCC may optimize small variable-length arrays of a known
value into plain arrays, so this warning may not get triggered for
such arrays.
</p>
<p><samp>-Wvla-larger-than=</samp>‘<samp>PTRDIFF_MAX</samp>’ is enabled by default but
is typically only effective when <samp>-ftree-vrp</samp> is active (default
for <samp>-O2</samp> and above).
</p>
<p>See also <samp>-Walloca-larger-than=<var>byte-size</var></samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvla-parameter</key>
    <name>Warn about mismatched declarations of VLA parameters</name>
    <description>
      <![CDATA[<p>Warn about redeclarations of functions involving arguments of Variable
Length Array types of inconsistent kinds or forms, and enable the detection
of out-of-bounds accesses to such parameters by warnings such as
<samp>-Warray-bounds</samp>.
</p>
<p>If the first function declaration uses the VLA form the bound specified
in the array is assumed to be the minimum number of elements expected to
be provided in calls to the function and the maximum number of elements
accessed by it.  Failing to provide arguments of sufficient size or
accessing more than the maximum number of elements may be diagnosed.
</p>
<p>For example, the warning triggers for the following redeclarations because
the first one allows an array of any size to be passed to <code>f</code> while
the second one specifies that the array argument must have at least <code>n</code>
elements.  In addition, calling <code>f</code> with the associated VLA bound
parameter in excess of the actual VLA bound triggers a warning as well.
</p>
<div>
<pre>void f (int n, int[n]);
// warning: argument 2 previously declared as a VLA
void f (int, int[]);

void g (int n)
{
    if (n &gt; 4)
      return;
    int a[n];
    // warning: access to a by f may be out of bounds
    f (sizeof a, a);
  …
}

</pre></div>
<p><samp>-Wvla-parameter</samp> is included in <samp>-Wall</samp>.  The
<samp>-Warray-parameter</samp> option triggers warnings for similar problems
involving ordinary array arguments.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvolatile</key>
    <name>Warn about deprecated uses of volatile qualifier</name>
    <description>
      <![CDATA[<p>Warn about deprecated uses of the <code>volatile</code> qualifier.  This includes
postfix and prefix <code>++</code> and <code>--</code> expressions of
<code>volatile</code>-qualified types, using simple assignments where the left
operand is a <code>volatile</code>-qualified non-class type for their value,
compound assignments where the left operand is a <code>volatile</code>-qualified
non-class type, <code>volatile</code>-qualified function return type,
<code>volatile</code>-qualified parameter type, and structured bindings of a
<code>volatile</code>-qualified type.  This usage was deprecated in C++20.
</p>
<p>Enabled by default with <samp>-std=c++20</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wvolatile-register-var</key>
    <name>Warn when a register variable is declared volatile</name>
    <description>
      <![CDATA[<p>Warn if a register variable is declared volatile.  The volatile
modifier does not inhibit all optimizations that may eliminate reads
and/or writes to register variables.  This warning is enabled by
<samp>-Wall</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wwrite-strings</key>
    <name>In C++, nonzero means warn about deprecated conversion from string literals to 'char *'.  In C, similar warning, except that the conversion is of course not deprecated by the ISO C standard</name>
    <description>
      <![CDATA[<p>When compiling C, give string constants the type <code>const
char[<var>length</var>]</code> so that copying the address of one into a
non-<code>const</code> <code>char *</code> pointer produces a warning.  These
warnings help you find at compile time code that can try to write
into a string constant, but only if you have been very careful about
using <code>const</code> in declarations and prototypes.  Otherwise, it is
just a nuisance. This is why we did not make <samp>-Wall</samp> request
these warnings.
</p>
<p>When compiling C++, warn about the deprecated conversion from string
literals to <code>char *</code>.  This warning is enabled by default for C++
programs.
</p>
<p>This warning is upgraded to an error by <samp>-pedantic-errors</samp> in
C++11 mode or later.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wxor-used-as-pow</key>
    <name>Warn about xor operators where it appears the user meant exponentiation</name>
    <description>
      <![CDATA[<p>Disable warnings about uses of <code>^</code>, the exclusive or operator,
where it appears the code meant exponentiation.
Specifically, the warning occurs when the
left-hand side is the decimal constant 2 or 10 and the right-hand side
is also a decimal constant.
</p>
<p>In C and C++, <code>^</code> means exclusive or, whereas in some other languages
(e.g. TeX and some versions of BASIC) it means exponentiation.
</p>
<p>This warning can be silenced by converting one of the operands to
hexadecimal as well as by compiling with <samp>-Wno-xor-used-as-pow</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wzero-as-null-pointer-constant</key>
    <name>Warn when a literal '0' is used as null pointer</name>
    <description>
      <![CDATA[<p>Warn when a literal ‘<samp>0</samp>’ is used as null pointer constant.  This can
be useful to facilitate the conversion to <code>nullptr</code> in C++11.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wzero-length-bounds</key>
    <name>Warn about accesses to interior zero-length array members</name>
    <description>
      <![CDATA[<p>Warn about accesses to elements of zero-length array members that might
overlap other members of the same object.  Declaring interior zero-length
arrays is discouraged because accesses to them are undefined.
See <a href="Zero-Length.html">Arrays of Length Zero</a>.
</p>
<p>For example, the first two stores in function <code>bad</code> are diagnosed
because the array elements overlap the subsequent members <code>b</code> and
<code>c</code>.  The third store is diagnosed by <samp>-Warray-bounds</samp>
because it is beyond the bounds of the enclosing object.
</p>
<div>
<pre>struct X { int a[0]; int b, c; };
struct X x;

void bad (void)
{
  x.a[0] = 0;   // -Wzero-length-bounds
  x.a[1] = 1;   // -Wzero-length-bounds
  x.a[2] = 2;   // -Warray-bounds
}
</pre></div>
<p>Option <samp>-Wzero-length-bounds</samp> is enabled by <samp>-Warray-bounds</samp>.
</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Whsa</key>
    <name>Warn when a function cannot be expanded to HSAIL</name>
    <description>
      <![CDATA[<p>Issue a warning when HSAIL cannot be emitted for the compiled function or OpenMP construct.</p>]]>
      </description>
    </rule>
  <rule>
    <key>-Wmudflap</key>
    <name>Warn about constructs not instrumented by -fmudflap</name>
    <description>
      <![CDATA[Suppress warnings about constructs that cannot be instrumented by <samp>-fmudflap</samp>]]>
      </description>
    </rule>
  <rule>
    <key>-Wunsafe-loop-optimizations</key>
    <name>Warn if the loop cannot be optimized due to nontrivial assumptions</name>
    <description>
      <![CDATA[<p>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With <samp>-funsafe-loop-optimizations</samp> warn if the compiler makes such assumptions.</p>]]>
      </description>
    </rule>
  </rules>
