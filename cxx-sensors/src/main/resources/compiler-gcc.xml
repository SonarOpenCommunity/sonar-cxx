<?xml version="1.0" encoding="UTF-8"?>
<rules>
  <rule>
    <key>=CustomRuleTemplate</key>
    <cardinality>MULTIPLE</cardinality>
    <name><![CDATA[Template for custom Custom rules]]></name>
    <description>
      <![CDATA[
<p>
Follow these steps to make your custom Custom rules available in SonarQube:
</p>

<ol>
  <ol>
    <li>Create a new rule in SonarQube by "copying" this rule template and specify the <code>CheckId</code> of your custom rule, a title, a description, and a default severity.</li>
    <li>Enable the newly created rule in your quality profile</li>
  </ol>
  <li>Relaunch an analysis on your projects, et voilà, your custom rules are executed!</li>
</ol>
      ]]>
    </description>
    <severity>MAJOR</severity>
  </rule>
  <rule>
    <key>enabled by default</key>
    <name>Default compiler warnings</name>
    <description>
    Default compiler warnings.
    </description>
    <internalKey>enabled by default</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wabi</key>
    <name>Warn about things that will change when compiling with an ABI-compliant compiler</name>
    <description>
    Warn when G++ generates code that is probably not compatible with the vendor-neutral
    C++ ABI. Although an effort has been made to warn about all such cases, there are probably some
    cases that are not warned about, even though G++ is generating incompatible code. There may also
    be cases where warnings are emitted even though the code that is generated will be compatible.

    You should rewrite your code to avoid these warnings if you are concerned about the fact that code
    generated by G++ may not be binary compatible with code generated by other compilers.
    </description>
    <internalKey>-Wabi</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Waddress</key>
    <name>Warn about suspicious uses of memory addresses</name>
    <description>
    Warn about suspicious uses of memory addresses. These include using the address of
    a function in a conditional expression, such as "void func(void); if (func)", and comparisons
    against the memory address of a string literal, such as "if (x == "abc")". Such uses typically
    indicate a programmer error: the address of a function always evaluates to true, so their use in
    a conditional usually indicate that the programmer forgot the parentheses in a function call;
    and comparisons against string literals result in unspecified behavior and are not portable in C,
    so they usually indicate that the programmer intended to use "strcmp".
    </description>
    <internalKey>-Waddress</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Waggregate-return</key>
    <name>Warn about returning structures, unions or arrays</name>
    <description>
    Warn if any functions that return structures or unions are defined or called. (In
    languages where you can return an array, this also elicits a warning.)
    </description>
    <internalKey>-Waggregate-return</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Waliasing</key>
    <name>Warn about possible aliasing of dummy arguments</name>
    <description>
    Warn about possible aliasing of dummy arguments.
    </description>
    <internalKey>-Waliasing</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Walign-commons</key>
    <name>Warn about alignment of COMMON blocks</name>
    <description>
    Warn about alignment of COMMON blocks.
    </description>
    <internalKey>-Walign-commons</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wampersand</key>
    <name>Warn about missing ampersand in continued character constants</name>
    <description>
    Warn about missing ampersand in continued character constants.
    </description>
    <internalKey>-Wampersand</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Walloc-size-larger-than</key>
    <name>Warn about calls to functions decorated with attribute alloc_size </name>
    <description>
    Warn about calls to functions decorated with attribute alloc_size that attempt to allocate objects
    larger than the specified number of bytes, or where the result of the size computation in an
    integer type with infinite precision would exceed SIZE_MAX / 2. The option argument n may end in
    one of the standard suffixes designating a multiple of bytes such as kB and KiB for kilobyte and
    kibibyte, respectively, MB and MiB for megabyte and mebibyte, and so on.
    </description>
    <internalKey>-Walloc-size-larger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Walloc-zero</key>
    <name>Warn about calls to allocation functions decorated with attribute alloc_size that specify zero bytes</name>
    <description>
    Warn about calls to allocation functions decorated with attribute alloc_size that specify zero bytes,
    including those to the built-in forms of the functions aligned_alloc, alloca, calloc, malloc, and
    realloc. Because the behavior of these functions when called with a zero size differs among
    implementations (and in the case of realloc has been deprecated) relying on it may result in subtle
    portability bugs and should be avoided.
    </description>
    <internalKey>-Walloc-zero</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Walloca-larger-than</key>
    <name>Warn on calls to alloca that are not bounded by a controlling predicate</name>
    <description>
    This option warns on calls to alloca that are not bounded by a controlling predicate limiting its
    argument of integer type to at most n bytes, or calls to alloca where the bound is unknown. Arguments
    of non-integer types are considered unbounded even if they appear to be constrained to the expected
    range.

    For example, a bounded case of alloca could be:

    void func (size_t n)
    {
      void *p;
      if (n &lt;= 1000)
        p = alloca (n);
      else
        p = malloc (n);
      f (p);
    }

    In the above example, passing -Walloca-larger-than=1000 would not issue a warning because the call to
    alloca is known to be at most 1000 bytes. However, if -Walloca-larger-than=500 were passed, the
    compiler would emit a warning.

    Unbounded uses, on the other hand, are uses of alloca with no controlling predicate constraining its
    integer argument. For example:

    void func ()
    {
      void *p = alloca (n);
      f (p);
    }

    If -Walloca-larger-than=500 were passed, the above would trigger a warning, but this time because of
    the lack of bounds checking.

    Note, that even seemingly correct code involving signed integers could cause a warning:

    void func (signed int n)
    {
      if (n &lt; 500)
        {
          p = alloca (n);
          f (p);
        }
    }

    In the above example, n could be negative, causing a larger than expected argument to be implicitly cast
    into the alloca call.

    This option also warns when alloca is used in a loop.

    This warning is not enabled by -Wall, and is only active when -ftree-vrp is active (default for -O2 and above).

    See also -Wvla-larger-than=n.

    </description>
    <internalKey>-Walloca-larger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Warray-bounds</key>
    <name>Warn if an array is accessed out of bounds</name>
    <description>
    This option is only active when -ftree-vrp is active (default for -O2 and above). It
    warns about subscripts to arrays that are always out of bounds.
    </description>
    <internalKey>-Warray-bounds</internalKey>
    <severity>CRITICAL</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Warray-temporaries</key>
    <name>Warn about creation of array temporaries</name>
    <description>
    Warn about creation of array temporaries.
    </description>
    <internalKey>-Warray-temporaries</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wassign-intercept</key>
    <name>Warn whenever an Objective-C assignment is being intercepted by the garbage collector</name>
    <description>
    Warn whenever an Objective-C assignment is being intercepted by the garbage collector.
    </description>
    <internalKey>-Wassign-intercept</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wattributes</key>
    <name>Warn about inappropriate attribute usage</name>
    <description>
    Warn if an unexpected "__attribute__" is used, such as unrecognized attributes,
    function attributes applied to variables, etc. This will not stop errors for incorrect use of
    supported attributes.
    </description>
    <internalKey>-Wattributes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wbad-function-cast</key>
    <name>Warn about casting functions to incompatible types</name>
    <description>
    Warn whenever a function call is cast to a non-matching type. For example, warn if
    "int malloc()" is cast to "anything *".
    </description>
    <internalKey>-Wbad-function-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wbool-compare</key>
    <name>Warn about boolean expression compared with an integer value different from true/false</name>
    <description>
    Warn about boolean expression compared with an integer value different from true/false. For instance,
    the following comparison is always false:

    int n = 5;
    …
    if ((n &gt; 1) == 2) { … }

    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wbool-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wbool-operation</key>
    <name>Warn about suspicious operations on expressions of a boolean type</name>
    <description>
    Warn about suspicious operations on expressions of a boolean type. For instance, bitwise
    negation of a boolean is very likely a bug in the program. For C, this warning also warns
    about incrementing or decrementing a boolean, which rarely makes sense. (In C++,
    decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++1z, and
    deprecated otherwise.)

    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wbool-operation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wbuiltin-macro-redefined</key>
    <name>Warn when a built-in preprocessor macro is undefined or redefined</name>
    <description>
    Warn if certain built-in macros are redefined. This generate warnings for
    redefinition of "__TIMESTAMP__", "__TIME__", "__DATE__", "__FILE__", and "__BASE_FILE__".
    </description>
    <internalKey>-Wbuiltin-macro-redefined</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++-compat</key>
    <name>Warn about C constructs that are not in the common subset of C and C++</name>
    <description>
    Warn about ISO C constructs that are outside of the common subset of ISO C and ISO
    C++, e.g. request for implicit conversion from "void *" to a pointer to non-"void" type.
    </description>
    <internalKey>-Wc++-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++0x-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 200x</name>
    <description>
    Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 200x,
    e.g., identifiers in ISO C++ 1998 that will become keywords in ISO C++ 200x.
    </description>
    <internalKey>-Wc++0x-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++11-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011</name>
    <description>
    Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011,
    e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011.
    </description>
    <internalKey>-Wc++11-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++14-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014</name>
    <description>
    Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014,
    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wc++14-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++1z-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and the forthoming ISO C++ 2017(?).</name>
    <description>
    Warn about C++ constructs whose meaning differs between ISO C++ 2014 and the forthoming ISO C++ 2017(?).
    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wc++1z-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcast-align</key>
    <name>Warn about pointer casts which increase alignment</name>
    <description>
    Warn whenever a pointer is cast such that the required alignment of the target is
    increased.  For example, warn if a "char *" is cast to an "int *" on machines where integers can
    only be accessed at two- or four-byte boundaries.
    </description>
    <internalKey>-Wcast-align</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcast-qual</key>
    <name>Warn about casts which discard qualifiers</name>
    <description>
    Warn whenever a pointer is cast so as to remove a type qualifier from the target type.
    For example, warn if a "const char *" is cast to an ordinary "char *".

    Also warn when making a cast which introduces a type qualifier in an unsafe way.  For example,
    casting "char **" to "const char **" is unsafe, as in this example:

              /* p is char ** value.  */
              const char **q = (const char **) p;
              /* Assignment of readonly string to const char * is OK.  */
              *q = "string";
              /* Now char** pointer points to read-only memory.  */
              **p = 'b';
    </description>
    <internalKey>-Wcast-qual</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcatch-value</key>
    <name>Warn about catch handlers that do not catch via reference.</name>
    <description>
    Warn about catch handlers that do not catch via reference. With -Wcatch-value=1 (or
    -Wcatch-value for short) warn about polymorphic class types that are caught by value.
    With -Wcatch-value=2 warn about all class types that are caught by value. With
    -Wcatch-value=3 warn about all types that are not caught by reference.

    -Wcatch-value is enabled by -Wall.
    </description>
    <internalKey>-Wcatch-value</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wchar-subscripts</key>
    <name>Warn about subscripts whose type is "char"</name>
    <description>
    Warn if an array subscript has type "char". This is a common cause of error, as
    programmers often forget that this type is signed on some machines.
    </description>
    <internalKey>-Wchar-subscripts</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcharacter-truncation</key>
    <name>Warn about truncated character expressions</name>
    <description>
    Warn about truncated character expressions.
    </description>
    <internalKey>-Wcharacter-truncation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wchkp</key>
    <name>Warn about an invalid memory access that is found by Pointer Bounds Checker (-fcheck-pointer-bounds).</name>
    <description>
    Warn about an invalid memory access that is found by Pointer Bounds Checker (-fcheck-pointer-bounds).
    </description>
    <internalKey>-Wchkp</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wclass-memaccess</key>
    <name>Warn when the destination of a call to a raw memory function violate const-correctness or encapsulation, or corrupt the virtual table</name>
    <description><![CDATA[<p>
    Warn when the destination of a call to a raw memory function such as memset or memcpy is an object
    of class type writing into which might bypass the class non-trivial or deleted constructor or copy
    assignment, violate const-correctness or encapsulation, or corrupt the virtual table. Modifying
    the representation of such objects may violate invariants maintained by member functions of the
    class. For example, the call to memset below is undefined becase it modifies a non-trivial class
    object and is, therefore, diagnosed. The safe way to either initialize or clear the storage of
    objects of such types is by using the appropriate constructor or assignment operator, if one is
    available.</p>
<pre>
    std::string str = "abc";
    memset (&amp;str, 0, 3);
</pre>
    The -Wclass-memaccess option is enabled by -Wall.
    ]]>
    </description>
    <internalKey>-Wclass-memaccess</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wclobbered</key>
    <name>Warn about variables that might be changed by "longjmp" or "vfork"</name>
    <description>
    Warn for variables that might be changed by longjmp or vfork.
    </description>
    <internalKey>-Wclobbered</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcomment</key>
    <name>Warn about possibly nested block comments, and C++ comments spanning more than one physical line</name>
    <description>
    Warn whenever a comment-start sequence /* appears in a /* comment, or whenever a Backslash-Newline
    appears in a // comment.
    </description>
    <internalKey>-Wcomment</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconditionally-supported</key>
    <name>Warn for conditionally-supported (C++11 [intro.defs]) constructs. </name>
    <description>
    Warn for conditionally-supported (C++11 [intro.defs]) constructs.
    </description>
    <internalKey>-Wconditionally-supported</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconversion</key>
    <name>Warn for implicit type conversions that may change a value</name>
    <description>
    Warn for implicit conversions that may alter a value. This includes conversions
    between real and integer, like "abs (x)" when "x" is "double"; conversions between signed and
    unsigned, like "unsigned ui = -1"; and conversions to smaller types, like "sqrtf (M_PI)". Do not
    warn for explicit casts like "abs ((int) x)" and "ui = (unsigned) -1", or if the value is not
    changed by the conversion like in "abs (2.0)".  Warnings about conversions between signed and
    unsigned integers can be disabled by using -Wno-sign-conversion.

    For C++, also warn for confusing overload resolution for user-defined conversions; and conversions
    that will never use a type conversion operator: conversions to "void", the same type, a base class
    or a reference to them. Warnings about conversions between signed and unsigned integers are
    disabled by default in C++ unless -Wsign-conversion is explicitly enabled.
    </description>
    <internalKey>-Wconversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconversion-extra</key>
    <name>Warn about most implicit conversions</name>
    <description>
    Warn about most implicit conversions.
    </description>
    <internalKey>-Wconversion-extra</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconversion-null</key>
    <name>Warn for converting NULL from/to a non-pointer type</name>
    <description>
    Warn for conversions between "NULL" and non-pointer types.
    </description>
    <internalKey>-Wconversion-null</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcoverage-mismatch</key>
    <name>Warn in case profiles in -fprofile-use do not match</name>
    <description>
    Warn if feedback profiles do not match when using the -fprofile-use option. If a source
    file was changed between -fprofile-gen and -fprofile-use, the files with the profile feedback can
    fail to match the source file and GCC can not use the profile feedback information.  By default,
    this warning is enabled and is treated as an error. -Wno-coverage-mismatch can be used to disable
    the warning or -Wno-error=coverage-mismatch can be used to disable the error. Disable the error
    for this warning can result in poorly optimized code, so disabling the error is useful only in the
    case of very minor changes such as bug fixes to an existing code-base. Completely disabling the
    warning is not recommended.
    </description>
    <internalKey>-Wcoverage-mismatch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcpp</key>
    <name>Warn when a #warning directive is encountered</name>
    <description>
    Warning messages emitted by "#warning" directives.
    </description>
    <internalKey>-Wcpp</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wctor-dtor-privacy</key>
    <name>Warn when all constructors and destructors are private</name>
    <description>
    Warn when a class seems unusable because all the constructors or destructors in that
    class are private, and it has neither friends nor public static member functions.
    </description>
    <internalKey>-Wctor-dtor-privacy</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdangling-else</key>
    <name>Warn about constructions where there may be confusion to which if statement an else branch belongs.</name>
    <description>
    Warn about constructions where there may be confusion to which if statement an else branch
    belongs. Here is an example of such a case:

    {
      if (a)
        if (b)
          foo ();
      else
        bar ();
    }

    In C/C++, every else branch belongs to the innermost possible if statement, which in this
    example is if (b). This is often not what the programmer expected, as illustrated in the
    above example by indentation the programmer chose. When there is the potential for this
    confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add
    explicit braces around the innermost if statement so there is no way the else can belong
    to the enclosing if. The resulting code looks like this:

    {
      if (a)
        {
          if (b)
            foo ();
          else
            bar ();
        }
    }

    This warning is enabled by -Wparentheses.
    </description>
    <internalKey>-Wdangling-else</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdate-time</key>
    <name>Warn when macros __TIME__, __DATE__ or __TIMESTAMP__ are encountered</name>
    <description>
    Warn when macros __TIME__, __DATE__ or __TIMESTAMP__ are encountered as they might prevent
    bit-wise-identical reproducible compilations.
    </description>
    <internalKey>-Wdate-time</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdeclaration-after-statement</key>
    <name>Warn when a declaration is found after a statement</name>
    <description>
    Warn when a declaration is found after a statement in a block. This construct, known
    from C++, was introduced with ISO C99 and is by default allowed in GCC.  It is not supported by
    ISO C90 and was not supported by GCC versions before GCC 3.0.
    </description>
    <internalKey>-Wdeclaration-after-statement</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdelete-incomplete</key>
    <name>Warn when deleting a pointer to incomplete type</name>
    <description>
    Warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime.
    </description>
    <internalKey>-Wdelete-incomplete</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdelete-non-virtual-dtor</key>
    <name>Warn about deleting polymorphic objects with non-virtual destructors</name>
    <description>
    Warn when delete is used to destroy an instance of a class that has virtual functions
    and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer
    to a base class if the base class does not have a virtual destructor.
    </description>
    <internalKey>-Wdelete-non-virtual-dtor</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdeprecated</key>
    <name>Warn about usage of deprecated features</name>
    <description>
    Warn if a deprecated compiler feature, class, method, or field is used.
    </description>
    <internalKey>-Wdeprecated</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdeprecated-declarations</key>
    <name>Warn about uses of __attribute__((deprecated)) declarations</name>
    <description>
    Warn about uses of functions, variables, and types marked as deprecated by using the
    "deprecated" attribute.
    </description>
    <internalKey>-Wdeprecated-declarations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdisabled-optimization</key>
    <name>Warn when an optimization pass is disabled</name>
    <description>
    Warn if a requested optimization pass is disabled. This warning does not generally
    indicate that there is anything wrong with your code; it merely indicates that GCC's optimizers
    were unable to handle the code effectively. Often, the problem is that your code is too big or
    too complex; GCC will refuse to optimize programs when the optimization itself is likely to take
    inordinate amounts of time.
    </description>
    <internalKey>-Wdisabled-optimization</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdiv-by-zero</key>
    <name>Warn about compile-time integer division by zero</name>
    <description>
    Warn about compile-time integer division by zero. Floating point division by zero is
    not warned about, as it can be a legitimate way of obtaining infinities and NaNs.
    </description>
    <internalKey>-Wdiv-by-zero</internalKey>
    <severity>CRITICAL</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdouble-promotion</key>
    <name>Warn about implicit conversions from "float" to "double"</name>
    <description>
    Give a warning when a value of type "float" is implicitly promoted to "double". CPUs
    with a 32-bit "single-precision" floating-point unit implement "float" in hardware, but emulate
    "double" in software. On such a machine, doing computations using "double" values is much more
    expensive because of the overhead required for software emulation.

    It is easy to accidentally do computations with "double" because floating-point literals are
    implicitly of type "double". For example, in:

            float area(float radius)
            {
               return 3.14159 * radius * radius;
            }

    the compiler will perform the entire computation with "double" because the floating-point literal
    is a "double".
    </description>
    <internalKey>-Wdouble-promotion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wduplicate-decl-specifier</key>
    <name>Warn if a declaration has duplicate const, volatile, restrict or _Atomic specifier.</name>
    <description>
    Warn if a declaration has duplicate const, volatile, restrict or _Atomic specifier.
    </description>
    <internalKey>-Wduplicate-decl-specifier</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wduplicated-branches</key>
    <name>Warn when an if-else has identical branches</name>
    <description>
    Warn when an if-else has identical branches. This warning detects cases like

    if (p != NULL)
      return 0;
    else
      return 0;

    It doesn’t warn when both branches contain just a null statement. This warning
    also warn for conditional operators:

      int i = x ? *p : *p;

    </description>
    <internalKey>-Wduplicated-branches</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wduplicated-cond</key>
    <name>Warn about duplicated conditions in an if-else-if chain</name>
    <description>
    Warn about duplicated conditions in an if-else-if chain. For instance, warn for
    the following code:

    if (p-&gt;q != NULL) { … }
    else if (p-&gt;q != NULL) { … }

    </description>
    <internalKey>-Wduplicated-cond</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Weffc++</key>
    <name>Warn about violations of Effective C++ style rules</name>
    <description>
    Warn about violations of the following style guidelines from Scott Meyers' Effective
    C++, Second Edition book:
      * Item 11:  Define a copy constructor and an assignment operator for classes with dynamically allocated memory.
      * Item 12:  Prefer initialization to assignment in constructors.
      * Item 14:  Make destructors virtual in base classes.
      * Item 15:  Have "operator=" return a reference to *this.
      * Item 23:  Don't try to return a reference when you must return an object.

    Also warn about violations of the following style guidelines from Scott Meyers' More Effective C++ book:
      * Item 6:  Distinguish between prefix and postfix forms of increment and decrement operators.
      * Item 7:  Never overload "&amp;&amp;", "||", or ",".
    </description>
    <internalKey>-Weffc++</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wempty-body</key>
    <name>Warn about an empty body in an if or else statement</name>
    <description>
    Warn if an empty body occurs in an if, else or do while statement.
    </description>
    <internalKey>-Wempty-body</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wendif-labels</key>
    <name>Warn about stray tokens after #elif and #endif</name>
    <description>
    Warn whenever an #else or an #endif are followed by text.
    </description>
    <internalKey>-Wendif-labels</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wenum-compare</key>
    <name>Warn about comparison of different enum types</name>
    <description>
    Warn about a comparison between values of different enum types. In C++ this warning
    is enabled by default.
    </description>
    <internalKey>-Wenum-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wexpansion-to-defined</key>
    <name>Warn whenever ‘defined’ is encountered in the expansion of a macro</name>
    <description>
    Warn whenever ‘defined’ is encountered in the expansion of a macro (including the case
    where the macro is expanded by an ‘#if’ directive). Such usage is not portable.

    This warning is also enabled by -Wpedantic and -Wextra.
    </description>
    <internalKey>-Wexpansion-to-defined</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfloat-conversion</key>
    <name>Warn for implicit conversions that reduce the precision of a real value.</name>
    <description>
    Warn for implicit conversions that reduce the precision of a real value. This includes
    conversions from real to integer, and from higher precision real to lower precision
    real values. This option is also enabled by -Wconversion.
    </description>
    <internalKey>-Wfloat-conversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfloat-equal</key>
    <name>Warn if testing floating point numbers for equality</name>
    <description>
    Warn if floating point values are used in equality comparisons.

    The idea behind this is that sometimes it is convenient (for the programmer) to consider
    floating-point values as approximations to infinitely precise real numbers. If you are doing this,
    then you need to compute (by analyzing the code, or in some other way) the maximum or likely
    maximum error that the computation introduces, and allow for it when performing comparisons (and
    when producing output, but that's a different problem).  In particular, instead of testing for
    equality, you would check to see whether the two values have ranges that overlap; and this is done
    with the relational operators, so equality comparisons are probably mistaken.
    </description>
    <internalKey>-Wfloat-equal</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat</key>
    <name>Warn about printf/scanf/strftime/strfmon format string anomalies</name>
    <description>
    Check calls to "printf" and "scanf", etc., to make sure that the arguments supplied
    have types appropriate to the format string specified, and that the conversions specified in the
    format string make sense. This includes standard functions, and others specified by format
    attributes, in the "printf", "scanf", "strftime" and "strfmon" (an X/Open extension, not in the C
    standard) families (or other target-specific families). Which functions are checked without format
    attributes having been specified depends on the standard version selected, and such checks of
    functions without the attribute specified are disabled by -ffreestanding or -fno-builtin.

    The formats are checked against the format features supported by GNU libc version 2.2. These
    include all ISO C90 and C99 features, as well as features from the Single Unix Specification and
    some BSD and GNU extensions. Other library implementations may not support all these features;
    GCC does not support warning about features that go beyond a particular library's limitations.
    However, if -pedantic is used with -Wformat, warnings will be given about format features not in
    the selected standard version (but not for "strfmon" formats, since those are not in any version
    of the C standard).
    </description>
    <internalKey>-Wformat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-contains-nul</key>
    <name>Warn about format strings that contain NUL bytes</name>
    <description>
    Warn about format strings that contain NUL bytes.
    </description>
    <internalKey>-Wformat-contains-nul</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-extra-args</key>
    <name>Warn if passing too many arguments to a function for its format string</name>
    <description>
    Warn about excess arguments to a "printf" or "scanf" format function. The C standard
    specifies that such arguments are ignored.

    Where the unused arguments lie between used arguments that are specified with $ operand number
    specifications, normally warnings are still given, since the implementation could not know what
    type to pass to "va_arg" to skip the unused arguments. However, in the case of "scanf" formats,
    this option will suppress the warning if the unused arguments are all pointers, since the Single
    Unix Specification says that such unused arguments are allowed.
    </description>
    <internalKey>-Wformat-extra-args</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-nonliteral</key>
    <name>Warn about format strings that are not literals</name>
    <description>
    Warn if the format string is not a string literal and so cannot be checked, unless
    the format function takes its format arguments as a "va_list".
    </description>
    <internalKey>-Wformat-nonliteral</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-overflow</key>
    <name>Warn about calls to formatted input/output functions that might overflow the destination buffer</name>
    <description>
    Warn about calls to formatted input/output functions such as sprintf and vsprintf
    that might overflow the destination buffer. When the exact number of bytes written
    by a format directive cannot be determined at compile-time it is estimated based
    on heuristics that depend on the level argument and on optimization. While enabling
    optimization will in most cases improve the accuracy of the warning, it may also
    result in false positives.

    -Wformat-overflow
    -Wformat-overflow=1

    Level 1 of -Wformat-overflow enabled by -Wformat employs a conservative approach that
    warns only about calls that most likely overflow the buffer. At this level, numeric
    arguments to format directives with unknown values are assumed to have the value of
    one, and strings of unknown length to be empty. Numeric arguments that are known to
    be bounded to a subrange of their type, or string arguments whose output is bounded
    either by their directive’s precision or by a finite set of string literals, are
    assumed to take on the value within the range that results in the most bytes on
    output. For example, the call to sprintf below is diagnosed because even with both
    a and b equal to zero, the terminating NUL character ('\0') appended by the function
    to the destination buffer will be written past its end. Increasing the size of the
    buffer by a single byte is sufficient to avoid the warning, though it may not be
    sufficient to avoid the overflow.

    void f (int a, int b)
    {
      char buf [12];
      sprintf (buf, "a = %i, b = %i\n", a, b);
    }

    -Wformat-overflow=2

    Level 2 warns also about calls that might overflow the destination buffer given an
    argument of sufficient length or magnitude. At level 2, unknown numeric arguments are
    assumed to have the minimum representable value for signed types with a precision
    greater than 1, and the maximum representable value otherwise. Unknown string
    arguments whose length cannot be assumed to be bounded either by the directive’s
    precision, or by a finite set of string literals they may evaluate to, or the
    character array they may point to, are assumed to be 1 character long.

    At level 2, the call in the example above is again diagnosed, but this time because
    with a equal to a 32-bit INT_MIN the first %i directive will write some of its digits
    beyond the end of the destination buffer. To make the call safe regardless of the
    values of the two variables, the size of the destination buffer must be increased to
    at least 34 bytes. GCC includes the minimum size of the buffer in an informational
    note following the warning.

    An alternative to increasing the size of the destination buffer is to constrain the
    range of formatted values. The maximum length of string arguments can be bounded by
    specifying the precision in the format directive. When numeric arguments of format
    directives can be assumed to be bounded by less than the precision of their type,
    choosing an appropriate length modifier to the format specifier will reduce the
    required buffer size. For example, if a and b in the example above can be assumed to
    be within the precision of the short int type then using either the %hi format
    directive or casting the argument to short reduces the maximum required size of the
    buffer to 24 bytes.

    void f (int a, int b)
    {
      char buf [23];
      sprintf (buf, "a = %hi, b = %i\n", a, (short)b);
    }

    </description>
    <internalKey>-Wformat-overflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-security</key>
    <name>Warn about possible security problems with format functions</name>
    <description>
    Warn about uses of format functions that represent possible security problems. At
    present, this warns about calls to "printf" and "scanf" functions where the format string is not
    a string literal and there are no format arguments, as in "printf (foo);". This may be a security
    hole if the format string came from untrusted input and contains %n.
    </description>
    <internalKey>-Wformat-security</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-signedness</key>
    <name>Warn if the format string requires an unsigned argument and the argument is signed and vice versa.</name>
    <description>
    If -Wformat is specified, also warn if the format string requires an unsigned argument and the
    argument is signed and vice versa.
    </description>
    <internalKey>-Wformat-signedness</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-truncation</key>
    <name>Warn about calls to formatted input/output functions that might result in output truncation</name>
    <description>
    Warn about calls to formatted input/output functions such as snprintf and vsnprintf that might
    result in output truncation. When the exact number of bytes written by a format directive
    cannot be determined at compile-time it is estimated based on heuristics that depend on the
    level argument and on optimization. While enabling optimization will in most cases improve the
    accuracy of the warning, it may also result in false positives. Except as noted otherwise, the
    option uses the same logic -Wformat-overflow.

    -Wformat-truncation
    -Wformat-truncation=1

    Level 1 of -Wformat-truncation enabled by -Wformat employs a conservative approach that warns
    only about calls to bounded functions whose return value is unused and that will most likely
    result in output truncation.

    -Wformat-truncation=2

    Level 2 warns also about calls to bounded functions whose return value is used and that might
    result in truncation given an argument of sufficient length or magnitude.
    </description>
    <internalKey>-Wformat-truncation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-y2k</key>
    <name>Warn about strftime formats yielding 2-digit years</name>
    <description>
    Warn about "strftime" formats which may yield only a two-digit year.
    </description>
    <internalKey>-Wformat-y2k</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-zero-length</key>
    <name>Warn about zero-length formats</name>
    <description>
    Warn about zero-length formats. The C standard specifies that zero-length formats are
    allowed.
    </description>
    <internalKey>-Wformat-zero-length</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wframe-address</key>
    <name>Warn when the ‘__builtin_frame_address’ or ‘__builtin_return_address’ is called with an argument greater than 0</name>
    <description>
    Warn when the ‘__builtin_frame_address’ or ‘__builtin_return_address’ is called with
    an argument greater than 0. Such calls may return indeterminate values or crash the
    program. The warning is included in -Wall.
    </description>
    <internalKey>-Wframe-address</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wframe-larger-than</key>
    <name>Warn about large frames</name>
    <description>
    Warn if the size of a function frame is larger than len bytes. The computation done
    to determine the stack frame size is approximate and not conservative.  The actual requirements
    may be somewhat greater than len even if you do not get a warning. In addition, any space allocated
    via "alloca", variable-length arrays, or related constructs is not included by the compiler when
    determining whether or not to issue a warning.
    </description>
    <internalKey>-Wframe-larger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfree-nonheap-object</key>
    <name>Warn when attempting to free a non-heap object</name>
    <description>
    Warn when attempting to free a non-heap object.
    </description>
    <internalKey>-Wfree-nonheap-object</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfunction-elimination</key>
    <name>Warn about function call elimination</name>
    <description>
    Warn about function call elimination.
    </description>
    <internalKey>-Wfunction-elimination</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Whsa</key>
    <name>Issue a warning when HSAIL cannot be emitted for the compiled function or OpenMP construct.</name>
    <description>
    Issue a warning when HSAIL cannot be emitted for the compiled function or OpenMP construct.
    </description>
    <internalKey>-Whsa</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wignored-attributes</key>
    <name>Warn when an attribute is ignored.</name>
    <description>
    Warn when an attribute is ignored. This is different from the -Wattributes option in that it
    warns whenever the compiler decides to drop an attribute, not that the attribute is either
    unknown, used in a wrong place, etc. This warning is enabled by default.
    </description>
    <internalKey>-Wignored-attributes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wignored-qualifiers</key>
    <name>Warn whenever type qualifiers are ignored.</name>
    <description>
    Warn if the return type of a function has a type qualifier such as "const". For ISO
    C such a type qualifier has no effect, since the value returned by a function is not an lvalue.
    For C++, the warning is only emitted for scalar types or "void". ISO C prohibits qualified "void"
    return types on function definitions, so such return types always receive a warning even without
    this option.
    </description>
    <internalKey>-Wignored-qualifiers</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-fallthrough</key>
    <name>Warn when a switch case falls through</name>
    <description>
    Warn when a switch case falls through. For example:

    switch (cond)
      {
      case 1:
        a = 1;
        break;
      case 2:
        a = 2;
      case 3:
        a = 3;
        break;
      }

    This warning does not warn when the last statement of a case cannot fall through, e.g.
    when there is a return statement or a call to function declared with the noreturn
    attribute. -Wimplicit-fallthrough= also takes into account control flow statements,
    such as ifs, and only warns when appropriate. E.g.

    switch (cond)
      {
      case 1:
        if (i &gt; 3) {
          bar (5);
          break;
        } else if (i &lt; 1) {
          bar (0);
        } else
          return;
      default:
        …
      }

    Since there are occasions where a switch case fall through is desirable, GCC provides
    an attribute, __attribute__ ((fallthrough)), that is to be used along with a null
    statement to suppress this warning that would normally occur:

    switch (cond)
      {
      case 1:
        bar (0);
        __attribute__ ((fallthrough));
      default:
        …
      }

    C++17 provides a standard way to suppress the -Wimplicit-fallthrough warning using
    [[fallthrough]]; instead of the GNU attribute. In C++11 or C++14 users can use
    [[gnu::fallthrough]];, which is a GNU extension. Instead of these attributes, it is
    also possible to add a fallthrough comment to silence the warning. The whole body
    of the C or C++ style comment should match the given regular expressions listed below.
    The option argument n specifies what kind of comments are accepted:

    -Wimplicit-fallthrough=0 disables the warning altogether.
    -Wimplicit-fallthrough=1 matches .* regular expression, any comment is used as fallthrough comment.
    -Wimplicit-fallthrough=2 case insensitively matches .*falls?[ \t-]*thr(ough|u).* regular expression.
    -Wimplicit-fallthrough=3 case sensitively matches one of the following regular expressions:
        -fallthrough
        @fallthrough@
        lint -fallthrough[ \t]*
        [ \t.!]*(ELSE,? |INTENTIONAL(LY)? )?
        FALL(S | |-)?THR(OUGH|U)[ \t.!]*(-[^\n\r]*)?
        [ \t.!]*(Else,? |Intentional(ly)? )?
        Fall((s | |-)[Tt]|t)hr(ough|u)[ \t.!]*(-[^\n\r]*)?
        [ \t.!]*([Ee]lse,? |[Ii]ntentional(ly)? )?
        fall(s | |-)?thr(ough|u)[ \t.!]*(-[^\n\r]*)?
    -Wimplicit-fallthrough=4 case sensitively matches one of the following regular expressions:
        -fallthrough
        @fallthrough@
        lint -fallthrough[ \t]*
        [ \t]*FALLTHR(OUGH|U)[ \t]*
    -Wimplicit-fallthrough=5 doesn’t recognize any comments as fallthrough comments, only attributes disable the warning.

    The comment needs to be followed after optional whitespace and other comments by case
    or default keywords or by a user label that precedes some case or default label.

    switch (cond)
      {
      case 1:
        bar (0);
        /* FALLTHRU */
      default:
        …
      }

    The -Wimplicit-fallthrough=3 warning is enabled by -Wextra.
    </description>
    <internalKey>-Wimplicit-fallthrough</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-function-declaration</key>
    <name>Warn about implicit function declarations</name>
    <description>
    Give a warning whenever a function is used before being declared.
    </description>
    <internalKey>-Wimplicit-function-declaration</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-int</key>
    <name>Warn when a declaration does not specify a type</name>
    <description>
    Warn when a declaration does not specify a type.
    </description>
    <internalKey>-Wimplicit-int</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-interface</key>
    <name>Warn about calls with implicit interface</name>
    <description>
    Warn about calls with implicit interface.
    </description>
    <internalKey>-Wimplicit-interface</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-procedure</key>
    <name>Warn about called procedures not explicitly declared</name>
    <description>
    Warn about called procedures not explicitly declared.
    </description>
    <internalKey>-Wimplicit-procedure</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winit-self</key>
    <name>Warn about variables which are initialized to themselves</name>
    <description>
    Warn about uninitialized variables which are initialized with themselves.

    For example, GCC will warn about "i" being uninitialized in the following snippet only when
    -Winit-self has been specified:

            int f()
            {
              int i = i;
              return i;
            }
    </description>
    <internalKey>-Winit-self</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winline</key>
    <name>Warn when an inlined function cannot be inlined</name>
    <description>
    Warn if a function can not be inlined and it was declared as inline. Even with this
    option, the compiler will not warn about failures to inline functions declared in system headers.

    The compiler uses a variety of heuristics to determine whether or not to inline a function. For
    example, the compiler takes into account the size of the function being inlined and the amount of
    inlining that has already been done in the current function. Therefore, seemingly insignificant
    changes in the source program can cause the warnings produced by -Winline to appear or disappear.
    </description>
    <internalKey>-Winline</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wint-in-bool-context</key>
    <name>Warn for suspicious use of integer values where boolean values are expected</name>
    <description>
    Warn for suspicious use of integer values where boolean values are expected, such as
    conditional expressions (?:) using non-boolean integer constants in boolean context,
    like if (a &lt;= b ? 2 : 3). Or left shifting of signed integers in boolean context,
    like for (a = 0; 1 &lt;&lt; a; a++);. Likewise for all kinds of multiplications
    regardless of the data type. This warning is enabled by -Wall.
    </description>
    <internalKey>-Wint-in-bool-context</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wint-to-pointer-cast</key>
    <name>Warn when there is a cast to a pointer from an integer of a different size</name>
    <description>
    Warn when casting to pointer type of an integer of a different size. In C++, casting
    to a pointer type of smaller size is an error.
    </description>
    <internalKey>-Wint-to-pointer-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wintrinsic-shadow</key>
    <name>Warn if a user-procedure has the same name as an intrinsic</name>
    <description>
    Warn if a user-procedure has the same name as an intrinsic.
    </description>
    <internalKey>-Wintrinsic-shadow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wintrinsics-std</key>
    <name>Warn on intrinsics not part of the selected standard</name>
    <description>
    Warn on intrinsics not part of the selected standard.
    </description>
    <internalKey>-Wintrinsics-std</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winvalid-memory-model</key>
    <name>Warn when an atomic memory model parameter is known to be outside the valid range.</name>
    <description>
    Warn when an atomic memory model parameter is known to be outside the valid range.
    </description>
    <internalKey>-Winvalid-memory-model</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winvalid-offsetof</key>
    <name>Warn about invalid uses of the "offsetof" macro</name>
    <description>
    Warn when applying the offsetof macro to a non-POD type. According to the 1998 ISO
    C++ standard, applying offsetof to a non-POD type is undefined. In existing C++ implementations,
    however, offsetof typically gives meaningful results even when applied to certain kinds of non-POD
    types. (Such as a simple struct that fails to be a POD type only by virtue of having a constructor.)

    The restrictions on offsetof may be relaxed in a future version of the C++ standard.

    </description>
    <internalKey>-Winvalid-offsetof</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winvalid-pch</key>
    <name>Warn about PCH files that are found but not used</name>
    <description>
    Warn if a precompiled header is found in the search path but can't be used.
    </description>
    <internalKey>-Winvalid-pch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wjump-misses-init</key>
    <name>Warn when a jump misses a variable initialization</name>
    <description>
    Warn if a "goto" statement or a "switch" statement jumps forward across the
    initialization of a variable, or jumps backward to a label after the variable has been initialized.
    This only warns about variables which are initialized when they are declared.  This warning is
    only supported for C and Objective C; in C++ this sort of branch is an error in any case.
    </description>
    <internalKey>-Wjump-misses-init</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlarger-than</key>
    <name>Warn if an object is larger than specified number of bytes</name>
    <description>
    Warn whenever an object larger than the specified length (in bytes) is defined.
    </description>
    <internalKey>-Wlarger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wline-truncation</key>
    <name>Warn about truncated source lines</name>
    <description>
    Warn about truncated source lines.
    </description>
    <internalKey>-Wline-truncation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wliteral-suffix</key>
    <name>Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore</name>
    <description><![CDATA[<p>
    Warn when a string or character literal is followed by a ud-suffix which does
    not begin with an underscore. As a conforming extension, GCC treats such
    suffixes as separate preprocessing tokens in order to maintain backwards
    compatibility with code that uses formatting macros from &gt;inttypes.h&gt;. For example:</p>
<pre>
    #define __STDC_FORMAT_MACROS
    #include &lt;inttypes.h&gt;
    #include &lt;stdio.h&gt;

    int main() {
      int64_t i64 = 123;
      printf("My int64: %" PRId64"\n", i64);
    }
</pre>
    In this case, PRId64 is treated as a separate preprocessing token.

    Additionally, warn when a user-defined literal operator is declared with a
    literal suffix identifier that doesn’t begin with an underscore. Literal
    suffix identifiers that don’t begin with an underscore are reserved for
    future standardization.
    ]]>
    </description>
    <internalKey>-Wliteral-suffix</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlogical-not-parentheses</key>
    <name>Warn about logical not used on the left hand side operand of a comparison</name>
    <description>
    Warn about logical not used on the left hand side operand of a comparison.
    This option does not warn if the RHS operand is of a boolean type. Its purpose
    is to detect suspicious code like the following:

          int a;
          ...
          if (!a &gt; 1) { ... }

    It is possible to suppress the warning by wrapping the LHS into parentheses:

          if ((!a) &gt; 1) { ... }

    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wlogical-not-parentheses</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlogical-op</key>
    <name>Warn when a logical operator is suspiciously always evaluating to true or false</name>
    <description>
    Warn about suspicious uses of logical operators in expressions. This includes using
    logical operators in contexts where a bit-wise operator is likely to be expected.
    </description>
    <internalKey>-Wlogical-op</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlong-long</key>
    <name>Warn if long long type is used. </name>
    <description>
    Warn if long long type is used.
    </description>
    <internalKey>-Wlong-long</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlto-type-mismatch</key>
    <name>During the link-time optimization warn about type mismatches in global declarations from different compilation units</name>
    <description>
    During the link-time optimization warn about type mismatches in global declarations
    from different compilation units. Requires -flto to be enabled.
    </description>
    <internalKey>-Wlto-type-mismatch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmain</key>
    <name>Warn about suspicious declarations of "main"</name>
    <description>
    Warn if the type of main is suspicious. main should be a function with external
    linkage, returning int, taking either zero arguments, two, or three arguments of appropriate
    types.
    </description>
    <internalKey>-Wmain</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmaybe-uninitialized</key>
    <name>Warn about maybe uninitialized automatic variables</name>
    <description>
    Warn about maybe uninitialized automatic variables
    </description>
    <internalKey>-Wmaybe-uninitialized</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmemset-elt-size</key>
    <name>Warn for suspicious calls to the memset built-in function</name>
    <description>
    Warn for suspicious calls to the memset built-in function, if the first argument
    references an array, and the third argument is a number equal to the number of
    elements, but not equal to the size of the array in memory. This indicates that
    the user has omitted a multiplication by the element size.

    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wmemset-elt-size</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmemset-transposed-args</key>
    <name>Warn for suspicious calls to the memset built-in function</name>
    <description>
    Warn for suspicious calls to the memset built-in function, if the second argument
    is not zero and the third argument is zero. This warns e.g. about
    memset (buf, sizeof buf, 0) where most probably memset (buf, 0, sizeof buf) was
    meant instead. The diagnostics is only emitted if the third argument is literal
    zero. If it is some expression that is folded to zero, a cast of zero to some
    type, etc., it is far less likely that the user has mistakenly exchanged the
    arguments and no warning is emitted. This warning is enabled by -Wall.
    </description>
    <internalKey>-Wmemset-transposed-args</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmisleading-indentation</key>
    <name>Warn when the indentation of the code does not reflect the block structure</name>
    <description>
    Warn when the indentation of the code does not reflect the block structure. Specifically,
    a warning is issued for if, else, while, and for clauses with a guarded statement that
    does not use braces, followed by an unguarded statement with the same indentation.

    In the following example, the call to “bar” is misleadingly indented as if it were guarded
    by the “if” conditional.

      if (some_condition ())
        foo ();
        bar ();  /* Gotcha: this is not guarded by the "if".  */

    In the case of mixed tabs and spaces, the warning uses the -ftabstop= option to determine
    if the statements line up (defaulting to 8).

    The warning is not issued for code involving multiline preprocessor logic such as the
    following example.

      if (flagA)
        foo (0);
    #if SOME_CONDITION_THAT_DOES_NOT_HOLD
      if (flagB)
    #endif
        foo (1);

    The warning is not issued after a #line directive, since this typically indicates
    autogenerated code, and no assumptions can be made about the layout of the file that the
    directive references.

    This warning is enabled by -Wall in C and C++.
    </description>
    <internalKey>-Wmisleading-indentation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-braces</key>
    <name>Warn about possibly missing braces around initializers</name>
    <description>
    Warn if an aggregate or union initializer is not fully bracketed. In the following
    example, the initializer for a is not fully bracketed, but that for b is fully bracketed.

            int a[2][2] = { 0, 1, 2, 3 };
            int b[2][2] = { { 0, 1 }, { 2, 3 } };
    </description>
    <internalKey>-Wmissing-braces</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-declarations</key>
    <name>Warn about global functions without previous declarations</name>
    <description>
    Warn if a global function is defined without a previous declaration. Do so even if
    the definition itself provides a prototype. Use this option to detect global functions that are
    not declared in header files. In C++, no warnings are issued for function templates, or for inline
    functions, or for functions in anonymous namespaces.
    </description>
    <internalKey>-Wmissing-declarations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-field-initializers</key>
    <name>Warn about missing fields in struct initializers</name>
    <description>
    Warn if a structure's initializer has some fields missing. For example, the following
    code would cause such a warning, because "x.h" is implicitly zero:

            struct s { int f, g, h; };
            struct s x = { 3, 4 };

    This option does not warn about designated initializers, so the following modification would not
    trigger a warning:

            struct s { int f, g, h; };
            struct s x = { .f = 3, .g = 4 };
    </description>
    <internalKey>-Wmissing-field-initializers</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-format-attribute</key>
    <name>Warn about functions which might be candidates for format attributes</name>
    <description>
    Warn about function pointers that might be candidates for "format" attributes. Note
    these are only possible candidates, not absolute ones. GCC will guess that function pointers with
    "format" attributes that are used in assignment, initialization, parameter passing or return
    statements should have a corresponding "format" attribute in the resulting type. I.e. the left-hand
    side of the assignment or initialization, the type of the parameter variable, or the return type
    of the containing function respectively should also have a "format" attribute to avoid the warning.

    GCC will also warn about function definitions that might be candidates for "format" attributes.
    Again, these are only possible candidates. GCC will guess that "format" attributes might be
    appropriate for any function that calls a function like "vprintf" or "vscanf", but this might not
    always be the case, and some functions for which "format" attributes are appropriate may not be
    detected.
    </description>
    <internalKey>-Wmissing-format-attribute</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-include-dirs</key>
    <name>Warn about user-specified include directories that do not exist</name>
    <description>
    Warn if a user-supplied include directory does not exist.
    </description>
    <internalKey>-Wmissing-include-dirs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-noreturn</key>
    <name>Warn about functions which might be candidates for __attribute__((noreturn))</name>
    <description>
    Warn about functions which might be candidates for __attribute__((noreturn))
    </description>
    <internalKey>-Wmissing-noreturn</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-parameter-type</key>
    <name>Warn about function parameters declared without a type specifier in K&amp;R-style functions</name>
    <description><![CDATA[
    A function parameter is declared without a type specifier in K&amp;R-style functions:
<pre>
            void foo(bar) { }
</pre>
]]>
    </description>
    <internalKey>-Wmissing-parameter-type</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-prototypes</key>
    <name>Warn about global functions without prototypes</name>
    <description>
    Warn if a global function is defined without a previous prototype declaration. This
    warning is issued even if the definition itself provides a prototype. The aim is to detect global
    functions that are not declared in header files.
    </description>
    <internalKey>-Wmissing-prototypes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmudflap</key>
    <name>Warn about constructs not instrumented by -fmudflap</name>
    <description>
    Warn about constructs that cannot be instrumented by -fmudflap.
    </description>
    <internalKey>-Wmudflap</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmultichar</key>
    <name>Warn about use of multi-character character constants</name>
    <description>
    Warn if a multicharacter constant ('FOOF') is used. Usually they indicate a typo in
    the user's code, as they have implementation-defined values, and should not be used in portable
    code.
    </description>
    <internalKey>-Wmultichar</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmultiple-inheritance</key>
    <name>Warn when a class is defined with multiple direct base classes</name>
    <description>
    Warn when a class is defined with multiple direct base classes. Some coding rules disallow
    multiple inheritance, and this may be used to enforce that rule. The warning is inactive inside
    a system header file, such as the STL, so one can still use the STL. One may also define
    classes that indirectly use multiple inheritance.
    </description>
    <internalKey>-Wmultiple-inheritance</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmultistatement-macros</key>
    <name>Warn about unsafe multiple statement macros that appear to be guarded by a clause</name>
    <description>
    Warn about unsafe multiple statement macros that appear to be guarded by a clause such as if,
    else, for, switch, or while, in which only the first statement is actually guarded after the
    macro is expanded.

    For example:

    #define DOIT x++; y++
    if (c)
      DOIT;

    will increment y unconditionally, not just when c holds. The can usually be fixed by wrapping
    the macro in a do-while loop:

    #define DOIT do { x++; y++; } while (0)
    if (c)
      DOIT;

    This warning is enabled by -Wall in C and C++.
    </description>
    <internalKey>-Wmultistatement-macros</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnarrowing</key>
    <name>Warn about narrowing conversions within { } that are ill-formed in C++11</name>
    <description>
    Warn when a narrowing conversion prohibited by C++11 occurs within { }, e.g.

            int i = { 2.2 }; // error: narrowing from double to int

    This flag is included in -Wall and -Wc++11-compat.

    With -std=c++11, -Wno-narrowing suppresses the diagnostic required by the standard. Note that this
    does not affect the meaning of well-formed code; narrowing conversions are still considered ill-formed
    in SFINAE context.
    </description>
    <internalKey>-Wnarrowing</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnamespaces</key>
    <name>Warn when a namespace definition is opened</name>
    <description>
    Warn when a namespace definition is opened. Some coding rules disallow namespaces, and this may be
    used to enforce that rule. The warning is inactive inside a system header file, such as the STL, so
    one can still use the STL. One may also use using directives and qualified names.
    </description>
    <internalKey>-Wnamespaces</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnested-externs</key>
    <name>Warn about "extern" declarations not at file scope</name>
    <description>
    Warn if an "extern" declaration is encountered within a function.
    </description>
    <internalKey>-Wnested-externs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wno-aggressive-loop-optimizations</key>
    <name>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations.</name>
    <description>
    Warn if in a loop with constant number of iterations the compiler detects undefined behavior in
    some statement during one or more of the iterations.
    </description>
    <internalKey>-Wno-aggressive-loop-optimizations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wno-builtin-declaration-mismatch</key>
    <name>Warn if a built-in function is declared with the wrong signature</name>
    <description>
    Warn if a built-in function is declared with the wrong signature. This warning is enabled by default.
    </description>
    <internalKey>-Wno-builtin-declaration-mismatch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnoexcept</key>
    <name>Warn when a noexcept expression evaluates to false even though the expression can't actually throw</name>
    <description>
    Warn when a noexcept-expression evaluates to false because of a call to a function
    that does not have a non-throwing exception specification (i.e. throw() or noexcept) but is known
    by the compiler to never throw an exception.
    </description>
    <internalKey>-Wnoexcept</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnoexcept-type</key>
    <name>Warn if the C++1z feature making noexcept part of a function type changes the mangled name of a symbol relative to C++14</name>
    <description>
    Warn if the C++1z feature making noexcept part of a function type changes the mangled name of a
    symbol relative to C++14. Enabled by -Wabi and -Wc++1z-compat.
    </description>
    <internalKey>-Wnoexcept-type</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnon-template-friend</key>
    <name>Warn when non-templatized friend functions are declared within a template</name>
    <description>
    Disable warnings when non-templatized friend functions are declared within a template.
    Since the advent of explicit template specification support in G++, if the name of the friend is
    an unqualified-id (i.e., friend foo(int)), the C++ language specification demands that the friend
    declare or define an ordinary, nontemplate function. (Section 14.5.3). Before G++ implemented
    explicit specification, unqualified-ids could be interpreted as a particular specialization of a
    templatized function. Because this non-conforming behavior is no longer the default behavior for
    G++, -Wnon-template-friend allows the compiler to check existing code for potential trouble spots
    and is on by default. This new compiler behavior can be turned off with -Wno-non-template-friend,
    which keeps the conformant compiler code but disables the helpful warning.
    </description>
    <internalKey>-Wnon-template-friend</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnon-virtual-dtor</key>
    <name>Warn about non-virtual destructors</name>
    <description>
    Warn when a class has virtual functions and accessible non-virtual destructor, in which
    case it would be possible but unsafe to delete an instance of a derived class through a pointer
    to the base class.
    </description>
    <internalKey>-Wnon-virtual-dtor</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnonnull</key>
    <name>Warn about NULL being passed to argument slots marked as requiring non-NULL</name>
    <description>
    Warn about passing a null pointer for arguments marked as requiring a non-null value
    by the "nonnull" function attribute.
    </description>
    <internalKey>-Wnonnull</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnonnull-compare</key>
    <name>Warn when comparing an argument marked with the nonnull function attribute against null inside the function.</name>
    <description>
    Warn when comparing an argument marked with the nonnull function attribute against null
    inside the function.

    -Wnonnull-compare is included in -Wall. It can be disabled with the -Wno-nonnull-compare
    option.
    </description>
    <internalKey>-Wnonnull-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnormalized</key>
    <name>Warn about non-normalised Unicode strings</name>
    <description>
    In ISO C and ISO C++, two identifiers are different if they are different sequences
    of characters. However, sometimes when characters outside the basic ASCII character set are used,
    you can have two different character sequences that look the same. To avoid confusion, the ISO
    10646 standard sets out some normalization rules which when applied ensure that two sequences that
    look the same are turned into the same sequence. GCC can warn you if you are using identifiers
    that have not been normalized; this option controls that warning.

    There are four levels of warning supported by GCC. The default is -Wnormalized=nfc, which warns
    about any identifier that is not in the ISO 10646 "C" normalized form, NFC. NFC is the recommended
    form for most uses.

    Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when
    turned into NFC, are not allowed in identifiers. That is, there's no way to use these symbols in
    portable ISO C or C++ and have all your identifiers in NFC. -Wnormalized=id suppresses the warning
    for these characters. It is hoped that future versions of the standards involved will correct
    this, which is why this option is not the default.

    You can switch the warning off for all characters by writing -Wnormalized=none. You would only
    want to do this if you were using some other normalization scheme (like "D"), because otherwise
    you can easily create bugs that are literally impossible to see.

    Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display
    methodologies, especially once formatting has been applied. For instance "\u207F", "SUPERSCRIPT
    LATIN SMALL LETTER N", will display just like a regular "n" that has been placed in a superscript.
    ISO 10646 defines the NFKC normalization scheme to convert all these into a standard form as well,
    and GCC will warn if your code is not in NFKC if you use -Wnormalized=nfkc. This warning is
    comparable to warning about every identifier that contains the letter O because it might be confused
    with the digit 0, and so is not the default, but may be useful as a local coding convention if the
    programming environment is unable to be fixed to display these characters distinctly.
    </description>
    <internalKey>-Wnormalized</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnull-dereference</key>
    <name>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer.</name>
    <description>
    Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing
    a null pointer. This option is only active when -fdelete-null-pointer-checks is active, which is
    enabled by optimizations in most targets. The precision of the warnings depends on the optimization
    options used.
    </description>
    <internalKey>-Wnull-dereference</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wold-style-cast</key>
    <name>Warn if a C-style cast is used in a program</name>
    <description>
    Warn if an old-style (C-style) cast to a non-void type is used within a C++ program.
    The new-style casts (dynamic_cast, static_cast, reinterpret_cast, and const_cast) are less vulnerable
    to unintended effects and much easier to search for.
    </description>
    <internalKey>-Wold-style-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wold-style-declaration</key>
    <name>Warn for obsolescent usage in a declaration</name>
    <description>
    Warn for obsolescent usages, according to the C Standard, in a declaration. For
    example, warn if storage-class specifiers like "static" are not the first things in a declaration.
    </description>
    <internalKey>-Wold-style-declaration</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wold-style-definition</key>
    <name>Warn if an old-style parameter definition is used</name>
    <description>
    Warn if an old-style function definition is used. A warning is given even if there
    is a previous prototype.
    </description>
    <internalKey>-Wold-style-definition</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverflow</key>
    <name>Warn about overflow in arithmetic expressions</name>
    <description>
    Warn about compile-time overflow in constant expressions.
    </description>
    <internalKey>-Woverflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverlength-strings</key>
    <name>Warn if a string is longer than the maximum portable length specified by the standard</name>
    <description>
    Warn about string constants that are longer than the "minimum maximum" length specified
    in the C standard. Modern compilers generally allow string constants that are much longer than the
    standard's minimum limit, but very portable programs should avoid using longer strings.

    The limit applies after string constant concatenation, and does not count the trailing NUL. In C90,
    the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative
    minimum maximum, so we do not diagnose overlength strings in C++.
    </description>
    <internalKey>-Woverlength-strings</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverloaded-virtual</key>
    <name>Warn about overloaded virtual function names</name>
    <description>
    Warn when a function declaration hides virtual functions from a base class. For example, in:

            struct A {
              virtual void f();
            };

            struct B: public A {
              void f(int);
            };

    the "A" class version of "f" is hidden in "B", and code like:

            B* b;
            b->f();

    will fail to compile.
    </description>
    <internalKey>-Woverloaded-virtual</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverride-init</key>
    <name>Warn about overriding initializers without side effects</name>
    <description>
    Warn if an initialized field without side effects is overridden when using designated
    initializers.
    </description>
    <internalKey>-Woverride-init</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverride-init-side-effects</key>
    <name>Warn if an initialized field with side effects is overridden when using designated initializers</name>
    <description>
    Warn if an initialized field with side effects is overridden when using designated initializers.
    </description>
    <internalKey>-Woverride-init-side-effects</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpacked</key>
    <name>Warn when the packed attribute has no effect on struct layout</name>
    <description>
    Warn if a structure is given the packed attribute, but the packed attribute has no
    effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit.
    For instance, in this code, the variable "f.x" in "struct bar" will be misaligned even though
    "struct bar" does not itself have the packed attribute:

            struct foo {
              int x;
              char a, b, c, d;
            } __attribute__((packed));
            struct bar {
              char z;
              struct foo f;
            };
    </description>
    <internalKey>-Wpacked</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpacked-bitfield-compat</key>
    <name>Warn about packed bit-fields whose offset changed in GCC 4.4</name>
    <description>
     The 4.1, 4.2 and 4.3 series of GCC ignore the "packed" attribute on bit-fields of
    type "char". This has been fixed in GCC 4.4 but the change can lead to differences in the structure
    layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there
    is no longer a 4-bit padding between field "a" and "b" in this structure:

            struct foo
            {
              char a:4;
              char b:8;
            } __attribute__ ((packed));
    </description>
    <internalKey>-Wpacked-bitfield-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpadded</key>
    <name>Warn when padding is required to align structure members</name>
    <description>
    Warn if padding is included in a structure, either to align an element of the structure
    or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields
    of the structure to reduce the padding and so make the structure smaller.
    </description>
    <internalKey>-Wpadded</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wparentheses</key>
    <name>Warn about possibly missing parentheses</name>
    <description>
    Warn if parentheses are omitted in certain contexts, such as when there is an
    assignment in a context where a truth value is expected, or when operators are nested whose
    precedence people often get confused about.

    Also warn if a comparison like x&lt;=y&lt;=z appears; this is equivalent to (x&lt;=y ? 1 : 0) &lt;= z, which
    is a different interpretation from that of ordinary mathematical notation.

    Also warn about constructions where there may be confusion to which "if" statement an "else"
    branch belongs. Here is an example of such a case:

            {
              if (a)
                if (b)
                  foo ();
              else
                bar ();
            }

    In C/C++, every "else" branch belongs to the innermost possible "if" statement, which in this
    example is "if (b)". This is often not what the programmer expected, as illustrated in the above
    example by indentation the programmer chose. When there is the potential for this confusion, GCC
    will issue a warning when this flag is specified. To eliminate the warning, add explicit braces
    around the innermost "if" statement so there is no way the "else" could belong to the enclosing
    "if". The resulting code would look like this:

            {
              if (a)
                {
                  if (b)
                    foo ();
                  else
                    bar ();
                }
            }

    Also warn for dangerous uses of the ?: with omitted middle operand GNU extension. When the condition
    in the ?: operator is a boolean expression the omitted value will be always 1. Often the user
    expects it to be a value computed inside the conditional expression instead.
    </description>
    <internalKey>-Wparentheses</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wplacement-new</key>
    <name>Warn about placement new expressions with undefined behavior</name>
    <description>
    Warn about placement new expressions with undefined behavior, such as constructing an object in a
    buffer that is smaller than the type of the object. For example, the placement new expression below
    is diagnosed because it attempts to construct an array of 64 integers in a buffer only 64 bytes large.

    char buf [64];
    new (buf) int[64];

    This warning is enabled by default.

    -Wplacement-new=1

    This is the default warning level of -Wplacement-new. At this level the warning is not issued for
    some strictly undefined constructs that GCC allows as extensions for compatibility with legacy
    code. For example, the following new expression is not diagnosed at this level even though it has
    undefined behavior according to the C++ standard because it writes past the end of the one-element
    array.

    struct S { int n, a[1]; };
    S *s = (S *)malloc (sizeof *s + 31 * sizeof s->a[0]);
    new (s->a)int [32]();

    -Wplacement-new=2

    At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is
    also issued for placement new expressions that construct an object in the last member of structure
    whose type is an array of a single element and whose size is less than the size of the object being
    constructed. While the previous example would be diagnosed, the following construct makes use of the
    flexible member array extension to avoid the warning at level 2.

    struct S { int n, a[]; };
    S *s = (S *)malloc (sizeof *s + 32 * sizeof s->a[0]);
    new (s->a)int [32]();

    </description>
    <internalKey>-Wplacement-new</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpmf-conversions</key>
    <name>Warn when converting the type of pointers to member functions</name>
    <description>
    Warn when converting a bound pointer to member function to a plain pointer.
    </description>
    <internalKey>-Wpmf-conversions</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-arith</key>
    <name>Warn about function pointer arithmetic</name>
    <description>
    Warn about anything that depends on the "size of" a function type or of "void". GNU
    C assigns these types a size of 1, for convenience in calculations with "void *" pointers and
    pointers to functions.  In C++, warn also when an arithmetic operation involves "NULL".
    </description>
    <internalKey>-Wpointer-arith</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-compare</key>
    <name>Warn if a pointer is compared with a zero character constant</name>
    <description>
    Warn if a pointer is compared with a zero character constant. This usually means that the
    pointer was meant to be dereferenced. For example:

    const char *p = foo ();
    if (p == '\0')
      return 42;

    Note that the code above is invalid in C++11.
    </description>
    <internalKey>-Wpointer-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-sign</key>
    <name>Warn when a pointer differs in signedness in an assignment</name>
    <description>
    Warn for pointer argument passing or assignment with different signedness. This option
    is only supported for C and Objective-C.
    </description>
    <internalKey>-Wpointer-sign</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-to-int-cast</key>
    <name>Warn when a pointer is cast to an integer of a different size</name>
    <description>
    Warn when casting casting from a pointer to an integer type of a different size.
    </description>
    <internalKey>-Wpointer-to-int-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpragmas</key>
    <name>Warn about misuses of pragmas</name>
    <description>
    Warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or
    conflicts between pragmas.
    </description>
    <internalKey>-Wpragmas</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wproperty-assign-default</key>
    <name>Warn if a property for an Objective-C object has no assign semantics specified</name>
    <description>
    Warn if a property for an Objective-C object has no assign semantics specified
    </description>
    <internalKey>-Wproperty-assign-default</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wprotocol</key>
    <name>Warn if inherited methods are unimplemented</name>
    <description>
    If a class is declared to implement a protocol, a warning is issued for every method
    in the protocol that is not implemented by the class.  The default behavior is to issue a warning
    for every method not explicitly implemented in the class, even if a method implementation is
    inherited from the superclass.  If you use the -Wno-protocol option, then methods inherited from
    the superclass are considered to be implemented, and no warning is issued for them.
    </description>
    <internalKey>-Wprotocol</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wreal-q-constant</key>
    <name>Warn about real-literal-constants with 'q' exponent-letter</name>
    <description>
    Warn about real-literal-constants with 'q' exponent-letter
    </description>
    <internalKey>-Wreal-q-constant</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wredundant-decls</key>
    <name>Warn about multiple declarations of the same object</name>
    <description>
    Warn if anything is declared more than once in the same scope, even
    in cases where multiple declaration is valid and changes nothing.
    </description>
    <internalKey>-Wredundant-decls</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wregister</key>
    <name>Warn on uses of the register storage class specifier, except when it is part of the GNU Explicit Register Variables extension</name>
    <description>
    Warn on uses of the register storage class specifier, except when it is part of the GNU Explicit
    Register Variables extension. The use of the register keyword as storage class specifier has been
    deprecated in C++11 and removed in C++17. Enabled by default with -std=c++1z.
    </description>
    <internalKey>-Wregister</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wreorder</key>
    <name>Warn when the compiler reorders code</name>
    <description>
    Warn when the order of member initializers given in the code does not match the order
    in which they must be executed. For instance:

            struct A {
              int i;
              int j;
              A(): j (0), i (1) { }
            };

    The compiler will rearrange the member initializers for i and j to match the declaration order of
    the members, emitting a warning to that effect.
    </description>
    <internalKey>-Wreorder</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wrestrict</key>
    <name>Warn when an argument passed to a restrict-qualified parameter aliases with another argument</name>
    <description>
    Warn when an argument passed to a restrict-qualified parameter aliases with another argument.
    </description>
    <internalKey>-Wrestrict</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wreturn-type</key>
    <name>Warn whenever a function's return type defaults to "int" (C), or about inconsistent return types (C++)</name>
    <description>
    Warn whenever a function is defined with a return-type that defaults to "int". Also
    warn about any "return" statement with no return-value in a function whose return-type is not "void"
    (falling off the end of the function body is considered returning without a value), and about a
    "return" statement with an expression in a function whose return- type is "void".

    For C++, a function without return type always produces a diagnostic message, even when
    -Wno-return-type is specified. The only exceptions are main and functions defined in system headers.
    </description>
    <internalKey>-Wreturn-type</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wselector</key>
    <name>Warn if a selector has multiple methods</name>
    <description>
    Warn if multiple methods of different types for the same selector are found during
    compilation.  The check is performed on the list of methods in the final stage of compilation.
    Additionally, a check is performed for each selector appearing in a "@selector(...)"  expression,
    and a corresponding method for that selector has been found during compilation.  Because these
    checks scan the method table only at the end of compilation, these warnings are not produced if
    the final stage of compilation is not reached, for example because an error is found during
    compilation, or because the -fsyntax-only option is being used.
    </description>
    <internalKey>-Wselector</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsequence-point</key>
    <name>Warn about possible violations of sequence point rules</name>
    <description>
    Warn about code that may have undefined semantics because of violations of sequence
    point rules in the C and C++ standards.

    The C and C++ standards defines the order in which expressions in a C/C++ program are evaluated
    in terms of sequence points, which represent a partial ordering between the execution of parts of
    the program: those executed before the sequence point, and those executed after it. These occur
    after the evaluation of a full expression (one which is not part of a larger expression), after
    the evaluation of the first operand of a "&amp;&amp;", "||", "? :" or "," (comma) operator, before a
    function is called (but after the evaluation of its arguments and the expression denoting the
    called function), and in certain other places. Other than as expressed by the sequence point
    rules, the order of evaluation of subexpressions of an expression is not specified. All these
    rules describe only a partial order rather than a total order, since, for example, if two functions
    are called within one expression with no sequence point between them, the order in which the
    functions are called is not specified. However, the standards committee have ruled that function
    calls do not overlap.

    It is not specified when between sequence points modifications to the values of objects take effect.
    Programs whose behavior depends on this have undefined behavior; the C and C++ standards specify
    that "Between the previous and next sequence point an object shall have its stored value modified
    at most once by the evaluation of an expression. Furthermore, the prior value shall be read only
    to determine the value to be stored.". If a program breaks these rules, the results on any
    particular implementation are entirely unpredictable.

    Examples of code with undefined behavior are "a = a++;", "a[n] = b[n++]" and "a[i++] = i;". Some
    more complicated cases are not diagnosed by this option, and it may give an occasional false
    positive result, but in general it has been found fairly effective at detecting this sort of
    problem in programs.

    The standard is worded confusingly, therefore there is some debate over the precise meaning of the
    sequence point rules in subtle cases. Links to discussions of the problem, including proposed
    formal definitions, may be found on the GCC readings page, at http://gcc.gnu.org/readings.html.
    </description>
    <internalKey>-Wsequence-point</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wshadow</key>
    <name>Warn when one local variable shadows another</name>
    <description>
    Warn whenever a local variable or type declaration shadows another variable, parameter,
    type, or class member (in C++), or whenever a built-in function is shadowed. Note that in C++,
    the compiler will not warn if a local variable shadows a struct/class/enum, but will warn if it
    shadows an explicit typedef.
    </description>
    <internalKey>-Wshadow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wshift-count-negative</key>
    <name>Warn if shift count is negative</name>
    <description>
    Warn if shift count is negative
    </description>
    <internalKey>-Wshift-count-negative</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wshift-count-overflow</key>
    <name>Warn if shift count &gt;= width of type</name>
    <description>
    Warn if shift count &gt;= width of type
    </description>
    <internalKey>-Wshift-count-overflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wshift-negative-value</key>
    <name>Warn if left shifting a negative value</name>
    <description>
    Warn if left shifting a negative value. This warning is enabled by -Wextra in C99 and C++11
    modes (and newer).
    </description>
    <internalKey>-Wshift-negative-value</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wshift-overflow</key>
    <name>Warn about left shift overflows</name>
    <description>
    Warn about left shift overflows. This warning is enabled by default in C99 and C++11 modes
    (and newer).

    -Wshift-overflow=1

    This is the warning level of -Wshift-overflow and is enabled by default in C99 and C++11
    modes (and newer). This warning level does not warn about left-shifting 1 into the sign bit.
    (However, in C, such an overflow is still rejected in contexts where an integer constant
    expression is required.)

    -Wshift-overflow=2

    This warning level also warns about left-shifting 1 into the sign bit, unless C++14 mode is
    active.
    </description>
    <internalKey>-Wshift-overflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsign-compare</key>
    <name>Warn about signed-unsigned comparisons</name>
    <description>
    Warn when a comparison between signed and unsigned values could produce an incorrect
    result when the signed value is converted to unsigned.
    </description>
    <internalKey>-Wsign-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsign-conversion</key>
    <name>Warn about signed-unsigned conversion</name>
    <description>
    Warn for implicit conversions that may change the sign of an integer value, like
    assigning a signed integer expression to an unsigned integer variable. An explicit cast silences
    the warning.
    </description>
    <internalKey>-Wsign-conversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsign-promo</key>
    <name>Warn when overload promotes from unsigned to signed</name>
    <description>
    Warn when overload resolution chooses a promotion from unsigned or enumerated type
    to a signed type, over a conversion to an unsigned type of the same size. Previous versions of
    G++ would try to preserve unsignedness, but the standard mandates the current behavior.

            struct A {
              operator int ();
              A&amp; operator = (int);
            };

            main ()
            {
              A a,b;
              a = b;
            }

    In this example, G++ will synthesize a default A&amp; operator = (const A&amp;);, while cfront will use
    the user-defined operator =.
    </description>
    <internalKey>-Wsign-promo</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsized-deallocation</key>
    <name>Warn about a definition of an unsized deallocation function</name>
    <description>
    Warn about a definition of an unsized deallocation function

    void operator delete (void *) noexcept;
    void operator delete[] (void *) noexcept;

    without a definition of the corresponding sized deallocation function

    void operator delete (void *, std::size_t) noexcept;
    void operator delete[] (void *, std::size_t) noexcept;

    or vice versa. Enabled by -Wextra along with -fsized-deallocation.
    </description>
    <internalKey>-Wsized-deallocation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsizeof-array-argument</key>
    <name>Warn when the sizeof operator is applied to a parameter that is declared as an array in a function definition</name>
    <description>
    Warn when the sizeof operator is applied to a parameter that is declared
    as an array in a function definition. This warning is enabled by default
    for C and C++ programs.
    </description>
    <internalKey>-Wsizeof-array-argument</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsizeof-pointer-div</key>
    <name>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size</name>
    <description>
    Warn for suspicious divisions of two sizeof expressions that divide the
    pointer size by the element size, which is the usual way to compute the
    array size but won’t work out correctly with pointers. This warning
    warns e.g. about sizeof (ptr) / sizeof (ptr[0]) if ptr is not an array,
    but a pointer. This warning is enabled by -Wall.
    </description>
    <internalKey>-Wsizeof-pointer-div</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsizeof-pointer-memaccess</key>
    <name>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses sizeof</name>
    <description><![CDATA[<p>
    Warn for suspicious length parameters to certain string and memory
    built-in functions if the argument uses sizeof. This warning warns e.g.
    about memset (ptr, 0, sizeof (ptr)); if ptr is not an array, but a
    pointer, and suggests a possible fix, or about
    memcpy (&amp;foo, ptr, sizeof (&amp;foo));.</p>

    <p>This warning is enabled by -Wall</p>
]]>
    </description>
    <internalKey>-Wsizeof-pointer-memaccess</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstack-protector</key>
    <name>Warn when not issuing stack smashing protection for some reason</name>
    <description>
    Warns about functions that will not be protected against stack smashing.This option
    is only active when -fstack-protector is active.
    </description>
    <internalKey>-Wstack-protector</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstack-usage</key>
    <name>Warn if stack usage might be larger than specified amount</name>
    <description>
    Warn if the stack usage of a function might be larger than len bytes.  The computation done to determine the stack
    usage is conservative.  Any space allocated via "alloca", variable-length arrays, or related constructs is included by
    the compiler when determining whether or not to issue a warning.

    The message is in keeping with the output of -fstack-usage.

      * If the stack usage is fully static but exceeds the specified amount, it's:

                  warning: stack usage is 1120 bytes

      * If the stack usage is (partly) dynamic but bounded, it's:

                  warning: stack usage might be 1648 bytes

      * If the stack usage is (partly) dynamic and not bounded, it's:

                  warning: stack usage might be unbounded
    </description>
    <internalKey>-Wstack-usage</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-aliasing</key>
    <name>Warn about code which might break strict aliasing rules</name>
    <description><![CDATA[<p>
    Warn about code which might break the strict aliasing rules that the compiler is using
    for optimization. The warning does not catch all cases, but does attempt to catch the more common
    pitfalls. Higher levels correspond to higher accuracy (fewer false positives). Higher levels also
    correspond to more effort, similar to the way -O works. -Wstrict-aliasing is equivalent to
    -Wstrict-aliasing=n, with n=3.</p>

    <p>Level 1: Most aggressive, quick, least accurate.  Possibly useful when higher levels do not warn but
    -fstrict-aliasing still breaks the code, as it has very few false negatives.  However, it has many
    false positives.  Warns for all pointer conversions between possibly incompatible types, even if
    never dereferenced.  Runs in the frontend only.</p>

    <p>Level 2: Aggressive, quick, not too precise.  May still have many false positives (not as many as
    level 1 though), and few false negatives (but possibly more than level 1).  Unlike level 1, it
    only warns when an address is taken.  Warns about incomplete types.  Runs in the frontend only.</p>

    <p>Level 3 (default for -Wstrict-aliasing): Should have very few false positives and few false negatives.
    Slightly slower than levels 1 or 2 when optimization is enabled. Takes care of the common pun+dereference
    pattern in the frontend: "*(int*)&amp;some_float". If optimization is enabled, it also runs in the
    backend, where it deals with multiple statement cases using flow-sensitive points-to information.
    Only warns when the converted pointer is dereferenced. Does not warn about incomplete types.</p>
]]>
    </description>
    <internalKey>-Wstrict-aliasing</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-null-sentinel</key>
    <name>Warn about uncasted NULL used as sentinel</name>
    <description>
    Warn also about the use of an uncasted "NULL" as sentinel. When compiling only with
    GCC this is a valid sentinel, as "NULL" is defined to "__null". Although it is a null pointer
    constant not a null pointer, it is guaranteed to be of the same size as a pointer. But this use
    is not portable across different compilers.
    </description>
    <internalKey>-Wstrict-null-sentinel</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-overflow</key>
    <name>Warn about optimizations that assume that signed overflow is undefined</name>
    <description>
    Warn about cases where the compiler optimizes based on the assumption that signed
    overflow does not occur.  Note that it does not warn about all cases where the code might overflow:
    it only warns about cases where the compiler implements some optimization.  Thus this warning
    depends  on the optimization level.

    An optimization which assumes that signed overflow does not occur is perfectly safe if the values
    of the variables involved are such that overflow never does, in fact, occur.  Therefore this warning
    can easily give a false positive: a warning about code which is not actually a problem. To help
    focus on important issues, several warning levels are defined. No warnings are issued for the use
    of undefined signed overflow when estimating how many iterations a loop will require, in particular
    when determining whether a loop will be executed at all.

    -Wstrict-overflow=1
        Warn about cases which are both questionable and easy to avoid.  For example: "x + 1 &gt; x"; with
        -fstrict-overflow, the compiler will simplify this to 1.  This level of -Wstrict-overflow is
        enabled by -Wall; higher levels are not, and must be explicitly requested.

    -Wstrict-overflow=2
        Also warn about other cases where a comparison is simplified to a constant.  For example:
        "abs (x) &gt;= 0".  This can only be simplified when -fstrict-overflow is in effect, because
        "abs (INT_MIN)" overflows to "INT_MIN", which is less than zero. -Wstrict-overflow (with no
        level) is the same as -Wstrict-overflow=2.

    -Wstrict-overflow=3
        Also warn about other cases where a comparison is simplified.  For example: "x + 1 &gt; 1" will
        be simplified to "x &gt; 0".

    -Wstrict-overflow=4
        Also warn about other simplifications not covered by the above cases.  For example: "(x * 10) / 5"
        will be simplified to "x * 2".

    -Wstrict-overflow=5
        Also warn about cases where the compiler reduces the magnitude of a constant involved in a
        comparison.  For example: "x + 2 &gt; y" will be simplified to "x + 1 &gt;= y". This is reported
        only at the highest warning level because this simplification applies to many comparisons,
        so this warning level will give a very large number of false positives.
    </description>
    <internalKey>-Wstrict-overflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-prototypes</key>
    <name>Warn about unprototyped function declarations</name>
    <description>
    Warn if a function is declared or defined without specifying the argument types. (An
    old-style function definition is permitted without a warning if preceded by a declaration that
    specifies the argument types.)
    </description>
    <internalKey>-Wstrict-prototypes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-selector-match</key>
    <name>Warn if type signatures of candidate methods do not match exactly</name>
    <description>
    Warn if multiple methods with differing argument and/or return types are found for
    a given selector when attempting to send a message using this selector to a receiver of type "id"
    or "Class".  When this flag is off (which is the default behavior), the compiler will omit such
    warnings if any differences found are confined to types which share the same size and alignment.
    </description>
    <internalKey>-Wstrict-selector-match</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstringop-overflow</key>
    <name>Warn for calls to string manipulation functions such as memcpy and strcpy that are determined to overflow the destination buffer.</name>
    <description>
    Warn for calls to string manipulation functions such as memcpy and strcpy that are determined
    to overflow the destination buffer. The optional argument is one greater than the type of
    Object Size Checking to perform to determine the size of the destination. See Object Size
    Checking. The argument is meaningful only for functions that operate on character arrays but
    not for raw memory functions like memcpy which always make use of Object Size type-0. The
    option also warns for calls that specify a size in excess of the largest possible object or
    at most SIZE_MAX / 2 bytes. The option produces the best results with optimization enabled
    but can detect a small subset of simple buffer overflows even without optimization in calls
    to the GCC built-in functions like __builtin_memcpy that correspond to the standard functions.
    In any case, the option warns about just a subset of buffer overflows detected by the
    corresponding overflow checking built-ins. For example, the option will issue a warning for
    the strcpy call below because it copies at least 5 characters (the string "blue" including
    the terminating NUL) into the buffer of size 4.

    enum Color { blue, purple, yellow };
    const char* f (enum Color clr)
    {
      static char buf [4];
      const char *str;
      switch (clr)
        {
          case blue: str = "blue"; break;
          case purple: str = "purple"; break;
          case yellow: str = "yellow"; break;
        }

      return strcpy (buf, str);   // warning here
    }

    Option -Wstringop-overflow=2 is enabled by default.

    -Wstringop-overflow
    -Wstringop-overflow=1

    The -Wstringop-overflow=1 option uses type-zero Object Size Checking to determine the sizes
    of destination objects. This is the default setting of the option. At this setting the option
    will not warn for writes past the end of subobjects of larger objects accessed by pointers
    unless the size of the largest surrounding object is known. When the destination may be one of
    several objects it is assumed to be the largest one of them. On Linux systems, when
    optimization is enabled at this setting the option warns for the same code as when the
    _FORTIFY_SOURCE macro is defined to a non-zero value.

    -Wstringop-overflow=2

    The -Wstringop-overflow=2 option uses type-one Object Size Checking to determine the sizes of
    destination objects. At this setting the option will warn about overflows when writing to
    members of the largest complete objects whose exact size is known. It will, however, not warn
    for excessive writes to the same members of unknown objects referenced by pointers since they
    may point to arrays containing unknown numbers of elements.

    -Wstringop-overflow=3

    The -Wstringop-overflow=3 option uses type-two Object Size Checking to determine the sizes of
    destination objects. At this setting the option warns about overflowing the smallest object or
    data member. This is the most restrictive setting of the option that may result in warnings
    for safe code.

    -Wstringop-overflow=4

    The -Wstringop-overflow=4 option uses type-three Object Size Checking to determine the sizes
    of destination objects. At this setting the option will warn about overflowing any data
    members, and when the destination is one of several objects it uses the size of the largest of
    them to decide whether to issue a warning. Similarly to -Wstringop-overflow=3 this setting of
    the option may result in warnings for benign code.
    </description>
    <internalKey>-Wstringop-overflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsubobject-linkage</key>
    <name>Warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage</name>
    <description>
    Warn if a class type has a base or a field whose type uses the anonymous namespace or depends
    on a type with no linkage. If a type A depends on a type B with no or internal linkage,
    defining it in multiple translation units would be an ODR violation because the meaning of B
    is different in each translation unit. If A only appears in a single translation unit, the
    best way to silence the warning is to give it internal linkage by putting it in an anonymous
    namespace as well. The compiler doesn’t give this warning for types defined in the main .C
    file, as those are unlikely to have multiple definitions.
    </description>
    <internalKey>-Wsubobject-linkage</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=const</key>
    <name>Warn about functions which might be candidates for __attribute__((const))</name>
    <description>
    Warn about functions which might be candidates for attribute "const". The compiler
    only warns for functions visible in other compilation units or (in the case of "pure" and "const")
    if it cannot prove that the function returns normally. A function returns normally if it doesn't
    contain an infinite loop nor returns abnormally by throwing, calling "abort()" or trapping. This
    analysis requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher
    optimization levels improve the accuracy of the analysis.
    </description>
    <internalKey>-Wsuggest-attribute=const</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=format</key>
    <name>Warn for cases where adding an attribute may be beneficial</name>
    <description>
    Warn for cases where adding an attribute may be beneficial. The attributes currently supported are
    listed below.

    -Wsuggest-attribute=pure
    -Wsuggest-attribute=const
    -Wsuggest-attribute=noreturn

    Warn about functions that might be candidates for attributes pure, const or noreturn. The compiler
    only warns for functions visible in other compilation units or (in the case of pure and const) if
    it cannot prove that the function returns normally. A function returns normally if it doesn’t
    contain an infinite loop or return abnormally by throwing, calling abort or trapping. This analysis
    requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher optimization
    levels improve the accuracy of the analysis.

    -Wsuggest-attribute=format
    -Wmissing-format-attribute

    Warn about function pointers that might be candidates for format attributes. Note these are only
    possible candidates, not absolute ones. GCC guesses that function pointers with format attributes
    that are used in assignment, initialization, parameter passing or return statements should have a
    corresponding format attribute in the resulting type. I.e. the left-hand side of the assignment or
    initialization, the type of the parameter variable, or the return type of the containing function
    respectively should also have a format attribute to avoid the warning.

    GCC also warns about function definitions that might be candidates for format attributes. Again,
    these are only possible candidates. GCC guesses that format attributes might be appropriate for any
    function that calls a function like vprintf or vscanf, but this might not always be the case, and
    some functions for which format attributes are appropriate may not be detected.
    </description>
    <internalKey>-Wsuggest-attribute=format</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=noreturn</key>
    <name>Warn about functions which might be candidates for __attribute__((noreturn))</name>
    <description>
    Warn about functions which might be candidates for attribute "noreturn". The compiler
    only warns for functions visible in other compilation units or (in the case of "pure" and "const")
    if it cannot prove that the function returns normally. A function returns normally if it doesn't
    contain an infinite loop nor returns abnormally by throwing, calling "abort()" or trapping. This
    analysis requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher
    optimization levels improve the accuracy of the analysis.
    </description>
    <internalKey>-Wsuggest-attribute=noreturn</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=pure</key>
    <name>Warn about functions which might be candidates for __attribute__((pure))</name>
    <description>
    Warn about functions which might be candidates for attribute "pure". The compiler
    only warns for functions visible in other compilation units or (in the case of "pure" and "const")
    if it cannot prove that the function returns normally. A function returns normally if it doesn't
    contain an infinite loop nor returns abnormally by throwing, calling "abort()" or trapping. This
    analysis requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher
    optimization levels improve the accuracy of the analysis.
    </description>
    <internalKey>-Wsuggest-attribute=pure</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-final-methods</key>
    <name>Warn about virtual methods where code quality would be improved if the method were declared with the C++11 final specifier</name>
    <description>
    Warn about virtual methods where code quality would be improved if the method were declared with
    the C++11 final specifier, or, if possible, its type were declared in an anonymous namespace or
    with the final specifier. This warning is more effective with link-time optimization, where the
    information about the class hierarchy graph is more complete. It is recommended to first consider
    suggestions of -Wsuggest-final-types and then rebuild with new annotations.
    </description>
    <internalKey>-Wsuggest-final-methods</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-final-types</key>
    <name>Warn about types with virtual methods where code quality would be improved if the type were declared with the C++11 final specifier</name>
    <description>
    Warn about types with virtual methods where code quality would be improved if the type were declared
    with the C++11 final specifier, or, if possible, declared in an anonymous namespace. This allows GCC
    to more aggressively devirtualize the polymorphic calls. This warning is more effective with link
    time optimization, where the information about the class hierarchy graph is more complete.
    </description>
    <internalKey>-Wsuggest-final-types</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-override</key>
    <name>Warn about overriding virtual functions that are not marked with the override keyword.</name>
    <description>
    Warn about overriding virtual functions that are not marked with the override keyword.
    </description>
    <internalKey>-Wsuggest-override</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsurprising</key>
    <name>Warn about "suspicious" constructs</name>
    <description>
    Warn about "suspicious" constructs.
    </description>
    <internalKey>-Wsurprising</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch</key>
    <name>Warn about enumerated switches, with no default, missing a case</name>
    <description>
    Warn whenever a "switch" statement has an index of enumerated type and lacks a "case"
    for one or more of the named codes of that enumeration. (The presence of a "default" label prevents
    this warning.) "case" labels outside the enumeration range also provoke warnings when this option
    is used (even if there is a "default" label).
    </description>
    <internalKey>-Wswitch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch-bool</key>
    <name>Warn whenever a switch statement has an index of boolean type and the case values are outside the range of a boolean type.</name>
    <description>
    Warn whenever a switch statement has an index of boolean type and the case values are outside the
    range of a boolean type. It is possible to suppress this warning by casting the controlling
    expression to a type other than bool. For example:

    switch ((int) (a == 4))
      {
      …
      }

    This warning is enabled by default for C and C++ programs.
    </description>
    <internalKey>-Wswitch-bool</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch-default</key>
    <name>Warn about enumerated switches missing a "default:" statement</name>
    <description>
    Warn whenever a "switch" statement does not have a "default" case.
    </description>
    <internalKey>-Wswitch-default</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch-enum</key>
    <name>Warn about all enumerated switches missing a specific case</name>
    <description>
    Warn whenever a "switch" statement has an index of enumerated type and lacks a "case"
    for one or more of the named codes of that enumeration.  "case" labels outside the enumeration
    range also provoke warnings when this option is used. The only difference between -Wswitch and
    this option is that this option gives a warning about an omitted enumeration code even if there
    is a "default" label.
    </description>
    <internalKey>-Wswitch-enum</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch-unreachable</key>
    <name>Warn whenever a switch statement contains statements between the controlling expression and the first case label, which will never be executed</name>
    <description>
    Warn whenever a switch statement contains statements between the controlling expression
    and the first case label, which will never be executed. For example:

    switch (cond)
      {
       i = 15;
      …
       case 5:
      …
      }

    -Wswitch-unreachable does not warn if the statement between the controlling expression
    and the first case label is just a declaration:

    switch (cond)
      {
       int i;
      …
       case 5:
       i = 5;
      …
      }

    This warning is enabled by default for C and C++ programs.
    </description>
    <internalKey>-Wswitch-unreachable</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsync-nand</key>
    <name>Warn when __sync_fetch_and_nand and __sync_nand_and_fetch built-in functions are used</name>
    <description>
    Warn when "__sync_fetch_and_nand" and "__sync_nand_and_fetch" built-in functions are
    used. These functions changed semantics in GCC 4.4.
    </description>
    <internalKey>-Wsync-nand</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsystem-headers</key>
    <name>Print warning messages for constructs found in system header files</name>
    <description>
    Print warning messages for constructs found in system header files. Warnings from system headers
    are normally suppressed, on the assumption that they usually do not indicate real problems and
    would only make the compiler output harder to read. Using this command-line option tells GCC to
    emit warnings from system headers as if they occurred in user code. However, note that using
    -Wall in conjunction with this option does not warn about unknown pragmas in system headers—for
    that, -Wunknown-pragmas must also be used.
    </description>
    <internalKey>-Wsystem-headers</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtautological-compare</key>
    <name>Warn if a self-comparison always evaluates to true or false.</name>
    <description>
    Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes
    such as:

    int i = 1;
    …
    if (i &gt; i) { … }

    This warning is enabled by -Wall.
    </description>
    <internalKey>-Wtautological-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtemplates</key>
    <name>Warn when a primary template declaration is encountered</name>
    <description>
    Warn when a primary template declaration is encountered. Some coding rules disallow templates, and
    this may be used to enforce that rule. The warning is inactive inside a system header file, such
    as the STL, so one can still use the STL. One may also instantiate or specialize templates.
    </description>
    <internalKey>-Wtemplates</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtraditional</key>
    <name>Warn about features not present in traditional C</name>
    <description><![CDATA[<p>
    Warn about certain constructs that behave differently in traditional and ISO C. Also
    warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs
    which should be avoided.</p>
    <ul>
    <li>Macro parameters that appear within string literals in the macro body.  In traditional C macro
        replacement takes place within string literals, but does not in ISO C.</li>
    <li>In traditional C, some preprocessor directives did not exist.  Traditional preprocessors would
        only consider a line to be a directive if the # appeared in column 1 on the line.  Therefore
        -Wtraditional warns about directives that traditional C understands but would ignore because the #
        does not appear as the first character on the line. It also suggests you hide directives like #pragma
        not understood by traditional C by indenting them.  Some traditional implementations would not
        recognize #elif, so it suggests avoiding it altogether.</li>
    <li>A function-like macro that appears without arguments.</li>
    <li>The unary plus operator.</li>
    <li>The U integer constant suffix, or the F or L floating point constant suffixes.  (Traditional C
        does support the L suffix on integer constants.)  Note, these suffixes appear in macros defined
        in the system headers of most modern systems, e.g. the _MIN/_MAX macros in "&lt;limits.h&gt;".
        Use of these macros in user code might normally lead to spurious warnings, however GCC's integrated
        preprocessor has enough context to avoid warning in these cases.</li>
    <li>A function declared external in one block and then used after the end of the block.</li>
    <li>A "switch" statement has an operand of type "long".</li>
    <li>A non-"static" function declaration follows a "static" one.  This construct is not accepted by
        some traditional C compilers.</li>
    <li>The ISO type of an integer constant has a different width or signedness from its traditional type.
        This warning is only issued if the base of the constant is ten.  I.e. hexadecimal or octal values,
        which typically represent bit patterns, are not warned about.</li>
    <li>Usage of ISO string concatenation is detected.</li>
    <li>Initialization of automatic aggregates.</li>
    <li>Identifier conflicts with labels.  Traditional C lacks a separate namespace for labels.</li>
    <li>Initialization of unions.  If the initializer is zero, the warning is omitted.  This is done under
        the assumption that the zero initializer in user code appears conditioned on e.g. "__STDC__" to
        avoid missing initializer warnings and relies on default initialization to zero in the traditional
        C case.</li>
    <li>Conversions by prototypes between fixed/floating point values and vice versa.  The absence of
        these prototypes when compiling with traditional C would cause serious problems.  This is a subset
        of the possible conversion warnings, for the full set use -Wtraditional-conversion.</li>
    <li>Use of ISO C style function definitions.  This warning intentionally is not issued for prototype
        declarations or variadic functions because these ISO C features will appear in your code when
        using libiberty's traditional C compatibility macros, "PARAMS" and "VPARAMS".  This warning is
        also bypassed for nested functions because that feature is already a GCC extension and thus not
        relevant to traditional C compatibility.</li>
    </ul>
]]>
    </description>
    <internalKey>-Wtraditional</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtraditional-conversion</key>
    <name>Warn of prototypes causing type conversions different from what would happen in the absence of prototype</name>
    <description>
    Warn if a prototype causes a type conversion that is different from what would happen
    to the same argument in the absence of a prototype. This includes conversions of fixed point to
    floating and vice versa, and conversions changing the width or signedness of a fixed point argument
    except when the same as the default promotion.
    </description>
    <internalKey>-Wtraditional-conversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtrampolines</key>
    <name>Warn whenever a trampoline is generated</name>
    <description>
    Warn about trampolines generated for pointers to nested functions.

    A trampoline is a small piece of data or code that is created at run time on the stack when the
    address of a nested function is taken, and is used to call the nested function indirectly. For
    some targets, it is made up of data only and thus requires no special treatment. But, for most
    targets, it is made up of code and thus requires the stack to be made executable in order for
    the program to work properly.
    </description>
    <internalKey>-Wtrampolines</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtrigraphs</key>
    <name>Warn if trigraphs are encountered that might affect the meaning of the program</name>
    <description>
    Warn if any trigraphs are encountered that might change the meaning of the program
    (trigraphs within comments are not warned about).
    </description>
    <internalKey>-Wtrigraphs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtype-limits</key>
    <name>Warn if a comparison is always true or always false due to the limited range of the data type</name>
    <description>
    Warn if a comparison is always true or always false due to the limited range of the
    data type, but do not warn for constant expressions.  For example, warn if an unsigned variable
    is compared against zero with &lt; or &gt;=.
    </description>
    <internalKey>-Wtype-limits</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wundeclared-selector</key>
    <name>Warn about @selector()s without previously declared methods</name>
    <description>
    Warn if a "@selector(...)" expression referring to an undeclared selector is found.
    A selector is considered undeclared if no method with that name has been declared before the
    "@selector(...)" expression, either explicitly in an @interface or @protocol declaration, or
    implicitly in an @implementation section.  This option always performs its checks as soon as a
    "@selector(...)" expression is found, while -Wselector only performs its checks in the final stage
    of compilation.  This also enforces the coding style convention that methods and selectors must
    be declared before being used.
    </description>
    <internalKey>-Wundeclared-selector</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wundef</key>
    <name>Warn if an undefined macro is used in an #if directive</name>
    <description>
    Warn if an undefined identifier is evaluated in an #if directive.
    </description>
    <internalKey>-Wundef</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunderflow</key>
    <name>Warn about underflow of numerical constant expressions</name>
    <description>
    Warn about underflow of numerical constant expressions
    </description>
    <internalKey>-Wunderflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wuninitialized</key>
    <name>Warn about uninitialized automatic variables</name>
    <description>
    Warn if an automatic variable is used without first being initialized or if a variable
    may be clobbered by a "setjmp" call. In C++, warn if a non-static reference or non-static const
    member appears in a class without constructors.

    If you want to warn about code which uses the uninitialized value of the variable in its own
    initializer, use the -Winit-self option.

    These warnings occur for individual uninitialized or clobbered elements of structure, union or
    array variables as well as for variables which are uninitialized or clobbered as a whole.  They
    do not occur for variables or elements declared "volatile".  Because these warnings depend on
    optimization, the exact variables or elements for which there are warnings will depend on the
    precise optimization options and version of GCC used.

    Note that there may be no warning about a variable that is used only to compute a value that itself
    is never used, because such computations may be deleted by data flow analysis before the warnings
    are printed.

    These warnings are made optional because GCC is not smart enough to see all the reasons why the
    code might be correct despite appearing to have an error.  Here is one example of how this can
    happen:

            {
              int x;
              switch (y)
                {
                case 1: x = 1;
                  break;
                case 2: x = 4;
                  break;
                case 3: x = 5;
                }
              foo (x);
            }

    If the value of "y" is always 1, 2 or 3, then "x" is always initialized, but GCC doesn't know this.
    Here is another common case:

            {
              int save_y;
              if (change_y) save_y = y, y = new_y;
              ...
              if (change_y) y = save_y;
            }

    This has no bug because "save_y" is used only if it is set.

    This option also warns when a non-volatile automatic variable might be changed by a call to "longjmp".
    These warnings as well are possible only in optimizing compilation.

    The compiler sees only the calls to "setjmp".  It cannot know where "longjmp" will be called; in
    fact, a signal handler could call it at any point in the code. As a result, you may get a warning
    even when there is in fact no problem because "longjmp" cannot in fact be called at the place which
    would cause a problem.

    Some spurious warnings can be avoided if you declare all the functions you use that never return as
    "noreturn".
    </description>
    <internalKey>-Wuninitialized</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunknown-pragmas</key>
    <name>Warn about unrecognized pragmas</name>
    <description>
    Warn when a #pragma directive is encountered which is not understood by GCC. If this
    command line option is used, warnings will even be issued for unknown pragmas in system header
    files. This is not the case if the warnings were only enabled by the -Wall command line option.
    </description>
    <internalKey>-Wunknown-pragmas</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunsafe-loop-optimizations</key>
    <name>Warn if the loop cannot be optimized due to nontrivial assumptions</name>
    <description>
    Warn if the loop cannot be optimized because the compiler could not assume anything
    on the bounds of the loop indices. With -funsafe-loop-optimizations warn if the compiler made such
    assumptions.
    </description>
    <internalKey>-Wunsafe-loop-optimizations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunsuffixed-float-constants</key>
    <name>Warn about unsuffixed float constants</name>
    <description>
    GCC will issue a warning for any floating constant that does not have a suffix. When
    used together with -Wsystem-headers it will warn about such constants in system header files. This
    can be useful when preparing code to use with the "FLOAT_CONST_DECIMAL64" pragma from the decimal
    floating-point extension to C99.
    </description>
    <internalKey>-Wunsuffixed-float-constants</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-but-set-parameter</key>
    <name>Warn when a function parameter is only set, otherwise unused</name>
    <description>
    Warn whenever a function parameter is assigned to, but otherwise unused (aside from
    its declaration).

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-but-set-parameter</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-but-set-variable</key>
    <name>Warn when a variable is only set, otherwise unused</name>
    <description>
    Warn whenever a local variable is assigned to, but otherwise unused (aside from its
    declaration).

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-but-set-variable</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-const-variable</key>
    <name>Warn whenever a constant static variable is unused aside from its declaration</name>
    <description>
    Warn whenever a constant static variable is unused aside from its declaration.
    -Wunused-const-variable=1 is enabled by -Wunused-variable for C, but not for C++.
    In C this declares variable storage, but in C++ this is not an error since const
    variables take the place of #defines.

    To suppress this warning use the unused attribute (see Variable Attributes).

    -Wunused-const-variable=1

    This is the warning level that is enabled by -Wunused-variable for C. It warns only
    about unused static const variables defined in the main compilation unit, but not
    about static const variables declared in any header included.

    -Wunused-const-variable=2

    This warning level also warns for unused constant static variables in headers
    (excluding system headers). This is the warning level of -Wunused-const-variable and
    must be explicitly requested since in C++ this isn’t an error and in C it might be
    harder to clean up all headers included.
    </description>
    <internalKey>-Wunused-const-variable</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-dummy-argument</key>
    <name>Warn about unused dummy arguments.</name>
    <description>
    Warn about unused dummy arguments.
    </description>
    <internalKey>-Wunused-dummy-argument</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-function</key>
    <name>Warn when a function is unused</name>
    <description>
    Warn whenever a static function is declared but not defined or a non-inline static function is unused.
    </description>
    <internalKey>-Wunused-function</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-label</key>
    <name>Warn when a label is unused</name>
    <description>
    Warn whenever a label is declared but not used.

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-label</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-local-typedefs</key>
    <name>Warn when typedefs locally defined in a function are not used</name>
    <description>
    Warn when a typedef locally defined in a function is not used.
    </description>
    <internalKey>-Wunused-local-typedefs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-macros</key>
    <name>Warn about macros defined in the main file that are not used</name>
    <description>
    Warn about macros defined in the main file that are unused.  A macro is used if it
    is expanded or tested for existence at least once.  The preprocessor will also warn if the macro
    has not been used at the time it is redefined or undefined.

    Built-in macros, macros defined on the command line, and macros defined in include files are not
    warned about.

    Note: If a macro is actually used, but only used in skipped conditional blocks, then CPP will
    report it as unused. To avoid the warning in such a case, you might improve the scope of the
    macro's definition by, for example, moving it into the first skipped block.  Alternatively, you
    could provide a dummy use with something like:

            #if defined the_macro_causing_the_warning
            #endif
    </description>
    <internalKey>-Wunused-macros</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-parameter</key>
    <name>Warn when a function parameter is unused</name>
    <description>
    Warn whenever a function parameter is unused aside from its declaration.

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-parameter</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-result</key>
    <name>Warn if a caller of a function, marked with attribute warn_unused_result, does not use its return value</name>
    <description>
    Warn if a caller of a function marked with attribute "warn_unused_result" does not
    use its return value.
    </description>
    <internalKey>-Wunused-result</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-value</key>
    <name>Warn when an expression value is unused</name>
    <description>
    Warn whenever a statement computes a result that is explicitly not used. To suppress
    this warning cast the unused expression to void. This includes an expression-statement or the
    left-hand side of a comma expression that contains no side effects. For example, an expression
    such as x[i,j] will cause a warning, while x[(void)i,j] will not.
    </description>
    <internalKey>-Wunused-value</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-variable</key>
    <name>Warn when a variable is unused</name>
    <description>
    Warn whenever a local variable or non-constant static variable is unused aside from
    its declaration.

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-variable</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wuseless-cast</key>
    <name>Warn when an expression is casted to its own type</name>
    <description>
    Warn when an expression is casted to its own type
    </description>
    <internalKey>-Wuseless-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvarargs</key>
    <name>Warn upon questionable usage of the macros used to handle variable arguments like va_start</name>
    <description>
    Warn upon questionable usage of the macros used to handle variable arguments like va_start.
    </description>
    <internalKey>-Wvarargs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvariadic-macros</key>
    <name>Warn if variadic macros are used</name>
    <description>
    Warn if variadic macros are used in pedantic ISO C90 mode, or the GNU alternate syntax
    when in pedantic ISO C99 mode.
    </description>
    <internalKey>-Wvariadic-macros</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvector-operation-performance</key>
    <name>Warn when a vector operation is compiled outside the SIMD</name>
    <description>
    Warn if vector operation is not implemented via SIMD capabilities of the architecture.
    Mainly useful for the performance tuning. Vector operation can be implemented "piecewise", which
    means that the scalar operation is performed on every vector element; "in parallel", which means
    that the vector operation is implemented using scalars of wider type, which normally is more performance
    efficient; and "as a single scalar", which means that vector fits into a scalar type.
    </description>
    <internalKey>-Wvector-operation-performance</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvirtual-inheritance</key>
    <name>Warn when a class is defined with a virtual direct base class</name>
    <description>
    Warn when a class is defined with a virtual direct base class. Some coding rules disallow multiple
    inheritance, and this may be used to enforce that rule. The warning is inactive inside a system
    header file, such as the STL, so one can still use the STL. One may also define classes that
    indirectly use virtual inheritance.
    </description>
    <internalKey>-Wvirtual-inheritance</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvla</key>
    <name>Warn if a variable length array is used</name>
    <description>
    Warn if variable length array is used in the code.
    </description>
    <internalKey>-Wvla</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvla-larger-than</key>
    <name>Warn on uses of variable-length arrays where the size is either unbounded, or bounded by an argument that can be larger than n bytes</name>
    <description>
    If this option is used, the compiler will warn on uses of variable-length arrays
    where the size is either unbounded, or bounded by an argument that can be larger
    than n bytes. This is similar to how -Walloca-larger-than=n works, but with
    variable-length arrays.

    Note that GCC may optimize small variable-length arrays of a known value into
    plain arrays, so this warning may not get triggered for such arrays.

    This warning is not enabled by -Wall, and is only active when -ftree-vrp is active
    (default for -O2 and above).

    See also -Walloca-larger-than=n.
    </description>
    <internalKey>-Wvla-larger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvolatile-register-var</key>
    <name>Warn when a register variable is declared volatile</name>
    <description>
    Warn if a register variable is declared volatile. The volatile modifier does not
    inhibit all optimizations that may eliminate reads and/or writes to register variables.
    </description>
    <internalKey>-Wvolatile-register-var</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wwrite-strings</key>
    <name>Warn about deprecated conversion from string literals to 'char *'.</name>
    <description>
    When compiling C, give string constants the type "const char[length]" so that copying
    the address of one into a non-"const" "char *" pointer will get a warning.  These warnings will
    help you find at compile time code that can try to write into a string constant, but only if you
    have been very careful about using "const" in declarations and prototypes.  Otherwise, it will
    just be a nuisance. This is why we did not make -Wall request these warnings.

    When compiling C++, warn about the deprecated conversion from string literals to "char *".  This
    warning is enabled by default for C++ programs.
    </description>
    <internalKey>-Wwrite-strings</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wzero-as-null-pointer-constant</key>
    <name>Warn when a literal '0' is used as null pointer</name>
    <description>
    Warn when a literal '0' is used as null pointer
    </description>
    <internalKey>-Wzero-as-null-pointer-constant</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
</rules>
