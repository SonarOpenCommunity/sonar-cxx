<?xml version="1.0" encoding="ASCII"?>
<sqaleManager xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="cxx-model-project.xsd">
    <rules>
    <rule key="AssignmentAddressToInteger">
        <name>Assigning an address value to an integer (int/long/etc.) type is not portable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Assigning an address value to an integer (int/long/etc.) type is
      not portable.
    </description>
    </rule>
    <rule key="AssignmentIntegerToAddress">
        <name>Assigning an integer (int/long/etc) to a pointer is not portable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Assigning an integer (int/long/etc) to a pointer is not portable.
    </description>
    </rule>
    <rule key="autoVariables">
        <name>Assigning address of local auto-variable to a function parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Assigning address of local auto-variable to a function
      parameter.
    </description>
    </rule>
    <rule key="returnAddressOfAutoVariable">
        <name>Return of the address of an auto-variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Return of the address of an auto-variable.
    </description>
    </rule>
    <rule key="returnLocalVariable">
        <name>Returning pointer to local array variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning pointer to local array variable.
    </description>
    </rule>
    <rule key="returnReference">
        <name>Returning reference to auto variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning reference to auto variable.
    </description>
    </rule>
    <rule key="returnTempReference">
        <name>Returning reference to temporary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning reference to temporary.
    </description>
    </rule>
    <rule key="returnAutocstr">
        <name>Returning pointer to auto variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning pointer to auto variable.
    </description>
    </rule>
    <rule key="returnTempPointer">
        <name>Returning pointer to temporary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning pointer to temporary.
    </description>
    </rule>
    <rule key="autovarInvalidDeallocation">
        <name>Deallocating auto-variable is invalid</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Deallocating auto-variable is invalid.
    </description>
    </rule>
    <rule key="arrayIndexOutOfBounds">
        <name>Array index out of bounds</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Array index out of bounds.
    </description>
    </rule>
    <rule key="bufferAccessOutOfBounds">
        <name>Buffer access out-of-bounds</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Buffer access out-of-bounds.
    </description>
    </rule>
    <rule key="outOfBounds">
        <name>Index is out of bounds: Supplied size is larger than actual size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Index is out of bounds: Supplied size is larger than actual size.
    </description>
    </rule>
    <rule key="terminateStrncpy">
        <name>The buffer may not be zero-terminated after the call to strncpy()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The buffer may not be zero-terminated after the call to
      strncpy().
    </description>
    </rule>
    <rule key="negativeIndex">
        <name>Negative array index</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Negative array index is always out of bounds.
    </description>
    </rule>
    <rule key="insecureCmdLineArgs">
        <name>Buffer overrun possible for long cmd-line args</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Buffer overrun possible for long cmd-line args.
    </description>
    </rule>
    <rule key="pointerOutOfBounds">
        <name>Array pointer out of bounds</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Undefined behavior: pointer arithmetic result does not point
      into or just past the end of the array.
    </description>
    </rule>
    <rule key="arrayIndexThenCheck">
        <name>Array index is used before limits check</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Array index is used before limits check.
    </description>
    </rule>
    <rule key="noConstructor">
        <name>Class does not have a constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Class does not have a constructor.
    </description>
    </rule>
    <rule key="uninitVar">
        <name>Member variable is not initialized in the constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>cppcheck</repo>
        <description>
      Member variable is not initialized in the constructor.
    </description>
    </rule>
    <rule key="operatorEqVarError">
        <name>Member variable is not assigned a value in the assignment operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Member variable is not assigned a value in the assignment
      operator.
    </description>
    </rule>
    <rule key="unusedPrivateFunction">
        <name>Unused private function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Unused private function.
    </description>
    </rule>
    <rule key="memsetClass">
        <name>Invalid usage of memset|memmove|memcpy on classes</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Usage of the functions from the memset-family on classes should
      be avoided because it leads to undefined behaviour in a number of
      cases (e.g. when the class contains a virtual method). Use
      constructors or init-routines to initialize your members instead.
    </description>
    </rule>
    <rule key="operatorEq">
        <name>&apos;class::operator=&apos; should return &apos;class &amp;&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      &apos;class::operator=&apos; should return &apos;class &amp;&apos;.
    </description>
    </rule>
    <rule key="thisSubtraction">
        <name>Suspicious pointer subtraction</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Suspicious pointer subtraction
    </description>
    </rule>
    <rule key="operatorEqRetRefThis">
        <name>&apos;operator=&apos; should return reference to self</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      &apos;operator=&apos; should return reference to self.
    </description>
    </rule>
    <rule key="operatorEqToSelf">
        <name>&apos;operator=&apos; should check for assignment to self</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      &apos;operator=&apos; should check for assignment to self.
    </description>
    </rule>
    <rule key="exceptThrowInDestructor">
        <name>Throwing exception in destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Throwing exception in destructor.
    </description>
    </rule>
    <rule key="exceptDeallocThrow">
        <name>Throwing exception in invalid state</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Throwing exception in invalid state: a pointer points at deallocated
      memory.
    </description>
    </rule>
    <rule key="exceptRethrowCopy">
        <name>Throwing a copy of the caught exception instead of rethrowing the original exception</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Throwing a copy of the caught exception instead of rethrowing
      the original exception.
    </description>
    </rule>
    <rule key="catchExceptionByValue">
        <name>Exception should be caught by reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Exception should be caught by reference.
    </description>
    </rule>
    <rule key="assignIfError">
        <name>Mismatching assignment and comparison, comparison is always false</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Mismatching assignment and comparison, comparison is always
      false.
    </description>
    </rule>
    <rule key="comparisonError">
        <name>Expression is always false</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Expression is always false.
    </description>
    </rule>
    <rule key="multiCondition">
        <name>&apos;else if&apos; condition matches previous condition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      &apos;else if&apos; condition matches previous condition.
    </description>
    </rule>
    <rule key="memleak">
        <name>Memory leak</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Memory leak.
    </description>
    </rule>
    <rule key="resourceLeak">
        <name>Resource leak</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Resource leak.
    </description>
    </rule>
    <rule key="deallocDealloc">
        <name>Deallocating a deallocated pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Deallocating a deallocated pointer.
    </description>
    </rule>
    <rule key="deallocuse">
        <name>Dereferencing variable after it is deallocated / released</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dereferencing variable after it is deallocated / released.
    </description>
    </rule>
    <rule key="mismatchSize">
        <name>The given size is mismatching</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      The given size is mismatching.
    </description>
    </rule>
    <rule key="mismatchAllocDealloc">
        <name>Mismatching allocation and deallocation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Mismatching allocation and deallocation.
    </description>
    </rule>
    <rule key="memleakOnRealloc">
        <name>Common realloc mistake: variable nulled but not freed upon failure</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Common realloc mistake: variable nulled but not freed upon
      failure.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsasctime">
        <name>Avoid usage of the function &apos;asctime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;asctime&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;asctime_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionscrypt">
        <name>Avoid usage of the function &apos;crypt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;crypt&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;crypt_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsctermid">
        <name>Avoid usage of the function &apos;ctermid&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ctermid&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;ctermid_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsctime">
        <name>Avoid usage of the function &apos;ctime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ctime&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;ctime_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsecvt">
        <name>Avoid usage of the function &apos;ecvt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ecvt&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;ecvt_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsfcvt">
        <name>Avoid usage of the function &apos;fcvt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;fcvt&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;fcvt_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsfgetgrent">
        <name>Avoid usage of the function &apos;fgetgrent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;fgetgrent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;fgetgrent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsfgetpwent">
        <name>Avoid usage of the function &apos;fgetpwent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;fgetpwent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;fgetpwent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsfgetspent">
        <name>Avoid usage of the function &apos;fgetspent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;fgetspent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;fgetspent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgcvt">
        <name>Avoid usage of the function &apos;gcvt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gcvt&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;gcvt_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetgrent">
        <name>Avoid usage of the function &apos;getgrent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getgrent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getgrent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetgrgid">
        <name>Avoid usage of the function &apos;getgrgid&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getgrgid&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getgrgid_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetgrnam">
        <name>Avoid usage of the function &apos;getgrnam&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getgrnam&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getgrnam_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgethostbyaddr">
        <name>Avoid usage of the function &apos;gethostbyaddr&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gethostbyaddr&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;gethostbyaddr_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgethostbyname">
        <name>Avoid usage of the function &apos;gethostbyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gethostbyname&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;gethostbyname_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgethostbyname2">
        <name>Avoid usage of the function &apos;gethostbyname2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gethostbyname2&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;gethostbyname2_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgethostent">
        <name>Avoid usage of the function &apos;gethostent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gethostent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;gethostent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetlogin">
        <name>Avoid usage of the function &apos;getlogin&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getlogin&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getlogin_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetnetbyaddr">
        <name>Avoid usage of the function &apos;getnetbyaddr&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getnetbyaddr&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getnetbyaddr_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetnetbyname">
        <name>Avoid usage of the function &apos;getnetbyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getnetbyname&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getnetbyname_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetnetgrent">
        <name>Avoid usage of the function &apos;getnetgrent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getnetgrent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getnetgrent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetprotobyname">
        <name>Avoid usage of the function &apos;getprotobyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getprotobyname&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getprotobyname_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetpwent">
        <name>Avoid usage of the function &apos;getpwent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getpwent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getpwent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetpwnam">
        <name>Avoid usage of the function &apos;getpwnam&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getpwnam&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getpwnam_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetpwuid">
        <name>Avoid usage of the function &apos;getpwuid&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getpwuid&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getpwuid_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetrpcbyname">
        <name>Avoid usage of the function &apos;getrpcbyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getrpcbyname&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getrpcbyname_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetrpcbynumber">
        <name>Avoid usage of the function &apos;getrpcbynumber&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getrpcbynumber&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getrpcbynumber_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetrpcent">
        <name>Avoid usage of the function &apos;getrpcent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getrpcent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getrpcent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetservbyname">
        <name>Avoid usage of the function &apos;getservbyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getservbyname&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getservbyname_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetservbyport">
        <name>Avoid usage of the function &apos;getservbyport&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getservbyport&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getservbyport_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetservent">
        <name>Avoid usage of the function &apos;getservent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getservent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getservent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetspent">
        <name>Avoid usage of the function &apos;getspent&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getspent&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getspent_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgetspnam">
        <name>Avoid usage of the function &apos;getspnam&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getspnam&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;getspnam_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsgmtime">
        <name>Avoid usage of the function &apos;gmtime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gmtime&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;gmtime_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionslocaltime">
        <name>Avoid usage of the function &apos;localtime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;localtime&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;localtime_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsrand">
        <name>Avoid usage of the function &apos;rand&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;rand&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;rand_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsreaddir">
        <name>Avoid usage of the function &apos;readdir&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;readdir&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;readdir_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsstrtok">
        <name>Avoid usage of the function &apos;strtok&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;strtok&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;strtok_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionstempnam">
        <name>Avoid usage of the function &apos;tempnam&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;tempnam&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;tempnam_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionstmpnam">
        <name>Avoid usage of the function &apos;tmpnam&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;tmpnam&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;tmpnam_r&apos;.
    </description>
    </rule>
    <rule key="nonreentrantFunctionsttyname">
        <name>Avoid usage of the function &apos;ttyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ttyname&apos; is not reentrant. For threadsafe
      applications it is recommended to use the reentrant replacement
      function &apos;ttyname_r&apos;.
    </description>
    </rule>
    <rule key="nullPointer">
        <name>Possible null pointer dereference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Possible null pointer dereference.
    </description>
    </rule>
    <rule key="obsoleteFunctionsbcmp">
        <name>Avoid usage of the function &apos;bcmp&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;bcmp&apos; is obsolete. It is recommended that new
      applications use the &apos;memcmp&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsbcopy">
        <name>Avoid usage of the function &apos;bcopy&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;bcopy&apos; is obsolete. It is recommended that new
      applications use the &apos;memmove&apos; or &apos;memcpy&apos; functions.
    </description>
    </rule>
    <rule key="obsoleteFunctionsbsd_signal">
        <name>Avoid usage of the function &apos;bsd_signal&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;bsd_signal&apos; is obsolete. It is recommended that
      new applications use the &apos;sigaction&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsbzero">
        <name>Avoid usage of the function &apos;bzero&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;bzero&apos; is obsolete. It is recommended that new
      applications use the &apos;memset&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsecvt">
        <name>Avoid usage of the function &apos;ecvt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ecvt&apos; is obsolete. It is recommended that new
      applications use the &apos;sprintf&apos; function
    </description>
    </rule>
    <rule key="obsoleteFunctionsfcvt">
        <name>Avoid usage of the function &apos;fcvt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;fcvt&apos; is obsolete. It is recommended that new
      applications use the &apos;sprintf&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsftime">
        <name>Avoid usage of the function &apos;ftime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ftime&apos; is obsolete.
    </description>
    </rule>
    <rule key="obsoleteFunctionsgcvt">
        <name>Avoid usage of the function &apos;gcvt&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gcvt&apos; is obsolete. It is recommended that new
      applications use the &apos;sprintf&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsgetcontext">
        <name>Avoid usage of the function &apos;getcontext&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getcontext&apos; is obsolete. Due to portability issues
      with this function, applications are recommended to be rewritten to
      use POSIX threads.
    </description>
    </rule>
    <rule key="obsoleteFunctionsgethostbyaddr">
        <name>Avoid usage of the function &apos;gethostbyaddr&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gethostbyaddr&apos; is obsolete. It is recommended that
      new applications use the &apos;getnameinfo&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsgethostbyname">
        <name>Avoid usage of the function &apos;gethostbyname&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gethostbyname&apos; is obsolete. It is recommended that
      new applications use the &apos;getaddrinfo&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsgets">
        <name>Avoid usage of the function &apos;gets&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;gets&apos; is obsolete. It is recommended that
      new applications use the &apos;fgets&apos; function instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionsgetwd">
        <name>Avoid usage of the function &apos;getwd&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;getwd&apos; is obsolete. It is recommended that new
      applications use the &apos;getcwd&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsindex">
        <name>Avoid usage of the function &apos;index&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;index&apos; is obsolete. It is recommended to use the
      function &apos;strchr&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionsmakecontext">
        <name>Avoid usage of the function &apos;makecontext&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;makecontext&apos; is obsolete. Due to portability
      issues with this function, applications are recommended to be
      rewritten to use POSIX threads.
    </description>
    </rule>
    <rule key="obsoleteFunctionspthread_attr_getstackaddr">
        <name>Avoid usage of the function &apos;pthread_attr_getstackaddr&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;pthread_attr_getstackaddr&apos; is obsolete. It is
      recommended that new applications use the &apos;pthread_attr_getstack&apos;
      function.
    </description>
    </rule>
    <rule key="obsoleteFunctionspthread_attr_setstackaddr">
        <name>Avoid usage of the function &apos;pthread_attr_setstackaddr&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;pthread_attr_setstackaddr&apos; is obsolete. It is
      recommended that new applications use the &apos;pthread_attr_setstack&apos;
      function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsrindex">
        <name>Avoid usage of the function &apos;rindex&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;rindex&apos; is obsolete. It is recommended to use the
      function &apos;strrchr&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionsscalbln">
        <name>Avoid usage of the function &apos;scalb&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;scalb&apos; is obsolete. It is recommended to use
      either &apos;scalbln&apos;, &apos;scalblnf&apos; or &apos;scalblnl&apos; instead of this function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsswapcontext">
        <name>Avoid usage of the function &apos;swapcontext&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;swapcontext&apos; is obsolete. Due to portability
      issues with this function, applications are recommended to be
      rewritten to use POSIX threads.
    </description>
    </rule>
    <rule key="obsoleteFunctionsualarm">
        <name>Avoid usage of the function &apos;ualarm&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ualarm&apos; is obsolete. It is recommended to use
      either &apos;timer_create&apos;, &apos;timer_delete&apos;, &apos;timer_getoverrun&apos;,
      &apos;timer_gettime&apos;, or &apos;timer_settime&apos; instead of this function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsusleep">
        <name>Avoid usage of the function &apos;usleep&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;usleep&apos; is obsolete. It is recommended that new
      applications use the &apos;nanosleep&apos; or &apos;setitimer&apos; function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsvfork">
        <name>Avoid usage of the function &apos;vfork&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;vfork&apos; is obsolete. It is recommended to use the
      function &apos;fork&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionswcswcs">
        <name>Avoid usage of the function &apos;wcswcs&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;wcswcs&apos; is obsolete. It is recommended to use the
      function &apos;wcsstr&apos; instead.
    </description>
    </rule>
    <rule key="assignBoolToPointer">
        <name>Assigning bool value to pointer (converting bool value to address)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Assigning bool value to pointer (converting bool value to
      address).
    </description>
    </rule>
    <rule key="sprintfOverlappingData">
        <name>Undefined behavior: variable is used as parameter and destination in s[n]printf()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Undefined behavior: variable is used as parameter and
      destination in s[n]printf(). From Single UNIX Specification: &quot;If
      copying takes place between objects that overlap as a result of a call
      to sprintf() or snprintf(), the results are undefined&quot;.
    </description>
    </rule>
    <rule key="staticStringCompare">
        <name>Unnecessary comparison of static strings</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Unnecessary comparison of static strings.
    </description>
    </rule>
    <rule key="udivError">
        <name>Unsigned division. The result will be wrong</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Unsigned division. The result will be wrong.
    </description>
    </rule>
    <rule key="zerodiv">
        <name>Division by zero</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Division by zero.
    </description>
    </rule>
    <rule key="wrongmathcall">
        <name>Passing value to () leads to undefined result</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Passing value to () leads to undefined result.
    </description>
    </rule>
    <rule key="fflushOnInputStream">
        <name>fflush() called on input stream &quot;stdin&quot; may result in undefined behaviour</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      fflush() called on input stream &quot;stdin&quot; may result in undefined
      behaviour.
    </description>
    </rule>
    <rule key="functionConst">
        <name>Member function can be const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Technically the member function can be const.
    </description>
    </rule>
    <rule key="unusedScopedObject">
        <name>Instance destroyed immediately</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Instance destroyed immediately.
    </description>
    </rule>
    <rule key="sizeofwithsilentarraypointer">
        <name>Using sizeof for array given as function argument returns the size of pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Using sizeof for array given as function argument returns the
      size of pointer.
    </description>
    </rule>
    <rule key="sizeofwithnumericparameter">
        <name>Using sizeof with a numeric constant as function argument might not be what you intended</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Using sizeof with a numeric constant as function argument might
      not be what you intended.
    </description>
    </rule>
    <rule key="cstyleCast">
        <name>C-style pointer casting</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      C-style pointer casting.
    </description>
    </rule>
    <rule key="dangerousUsageStrtol">
        <name>Invalid radix in call to strtol or strtoul. Must be 0 or 2-36</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid radix in call to strtol or strtoul. Must be 0 or 2-36.
    </description>
    </rule>
    <rule key="passedByValue">
        <name>Function parameter should be passed by reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Function parameter should be passed by reference.
    </description>
    </rule>
    <rule key="constStatement">
        <name>Redundant code: Found a statement that begins with type constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Redundant code: Found a statement that begins with type constant.
    </description>
    </rule>
    <rule key="charArrayIndex">
        <name>Using char type as array index</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Using char type as array index.
    </description>
    </rule>
    <rule key="charBitOp">
        <name>When using char variables in bit operations, sign extension can generate unexpected results</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      When using char variables in bit operations, sign extension can
      generate unexpected results.
    </description>
    </rule>
    <rule key="variableScope">
        <name>The scope of the variable can be reduced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The scope of the variable can be reduced.
    </description>
    </rule>
    <rule key="strPlusChar">
        <name>Unusual pointer arithmetic</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Unusual pointer arithmetic.
    </description>
    </rule>
    <rule key="sizeofsizeof">
        <name>Calling sizeof for &apos;sizeof&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Calling sizeof for &apos;sizeof&apos;.
    </description>
    </rule>
    <rule key="sizeofCalculation">
        <name>Found calculation inside sizeof()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Found calculation inside sizeof().
    </description>
    </rule>
    <rule key="redundantAssignInSwitch">
        <name>Redundant assignment in switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Redundant assignment in switch.
    </description>
    </rule>
    <rule key="switchCaseFallThrough">
        <name>Switch falls through case without comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Switch falls through case without comment.
    </description>
    </rule>
    <rule key="selfAssignment">
        <name>Redundant assignment to itself</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Redundant assignment to itself.
    </description>
    </rule>
    <rule key="assignmentInAssert">
        <name>Assert statement modifies variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Assert statement modifies variable.
    </description>
    </rule>
    <rule key="invalidscanf">
        <name>scanf without field width limits can crash with huge input data</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      scanf without field width limits can crash with huge input data.
    </description>
    </rule>
    <rule key="incorrectLogicOperator">
        <name>Suspicious use of the &apos;||&apos; logic operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Logical disjunction always evaluates to true. Did you
      intend to use &amp;&amp; instead?
    </description>
    </rule>
    <rule key="memsetZeroBytes">
        <name>Effectless memset() call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      memset() called to fill 0 bytes.
    </description>
    </rule>
    <rule key="clarifyCalculation">
        <name>Clarify calculation precedence for + and ?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Clarify calculation precedence for + and ?
    </description>
    </rule>
    <rule key="clarifyCondition">
        <name>Suspicious condition (assignment+comparison)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Suspicious condition (assignment+comparison), it can be
      clarified with parentheses.
    </description>
    </rule>
    <rule key="incorrectStringCompare">
        <name>Mismatch of the string literal and legth argument for substr()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      String literal doesn&apos;t match length argument for substr().
    </description>
    </rule>
    <rule key="incrementboolean">
        <name>Suspicious use of the postfix &apos;++&apos; operator on a boolean</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The use of a variable of type bool with the ++ postfix operator
      is always true and deprecated by the C++ Standard.
    </description>
    </rule>
    <rule key="comparisonOfBoolWithInt">
        <name>Suspicious comparison of a boolean with an integer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of a boolean with an integer that is neither 1 nor 0.
    </description>
    </rule>
    <rule key="conditionAlwaysTrueFalse">
        <name>Condition is always true/false</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The condition evaluates always to true/false.
    </description>
    </rule>
    <rule key="duplicateIf">
        <name>Redundant &apos;if&apos;-expressions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Found duplicate if expressions.
    </description>
    </rule>
    <rule key="duplicateBranch">
        <name>Redundant &apos;if&apos; and &apos;else&apos; branches</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Found duplicate branches for if and else.
    </description>
    </rule>
    <rule key="duplicateExpression">
        <name>Same expression on both sides of &apos;&amp;&amp;&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Same expression on both sides of &apos;&amp;&amp;&apos;.
    </description>
    </rule>
    <rule key="duplicateBreak">
        <name>Consecutive return, break, continue, goto or throw statements are unnecessary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Consecutive return, break, continue, goto or throw statements
      are unnecessary.
    </description>
    </rule>
    <rule key="unsignedLessThanZero">
        <name>Checking if unsigned variable is less than zero</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Checking if unsigned variable is less than zero.
    </description>
    </rule>
    <rule key="unsignedPositive">
        <name>An unsigned variable can&apos;t be negative so it is unnecessary to test it</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      An unsigned variable can&apos;t be negative so it is unnecessary to
      test it.
    </description>
    </rule>
    <rule key="invalidIterator1">
        <name>Invalid iterator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid iterator.
    </description>
    </rule>
    <rule key="iterators">
        <name>Same iterator is used with two different containers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Same iterator is used with two different containers.
    </description>
    </rule>
    <rule key="mismatchingContainers">
        <name>Mismatching containers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Mismatching containers.
    </description>
    </rule>
    <rule key="eraseDereference">
        <name>Dereferenced iterator an already erased iterator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dereferenced iterator an already erased iterator.
    </description>
    </rule>
    <rule key="stlOutOfBounds">
        <name>When i==foo.size(), foo[i] is out of bounds</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      When i==foo.size(), foo[i] is out of bounds.
    </description>
    </rule>
    <rule key="erase">
        <name>Dangerous iterator usage after erase()-method</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dangerous iterator usage after erase()-method. After erase the
      iterator is invalid so dereferencing it or comparing it with another
      iterator is invalid.
    </description>
    </rule>
    <rule key="invalidIterator2">
        <name>Iterators may get invalid after push_back|push_front|insert</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Iterators may get invalid after push_back|push_front|insert.
    </description>
    </rule>
    <rule key="invalidPointer">
        <name>Invalid pointer after push_back / push_front</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid pointer after push_back / push_front.
    </description>
    </rule>
    <rule key="stlBoundries">
        <name>Dangerous container iterator compare using &lt; operator for container</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dangerous container iterator compare using &lt; operator for
      container.
    </description>
    </rule>
    <rule key="stlIfFind">
        <name>Suspicious condition. The result of find is an iterator, but it is not properly checked</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Suspicious condition. The result of find is an iterator, but it
      is not properly checked.
    </description>
    </rule>
    <rule key="stlIfStrFind">
        <name>Suspicious checking of string::find() return value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Inefficient usage of string::find in condition. string::find
      will return &apos;0&apos; if the string is found at position &apos;0&apos;. If this is
      what you want to check then string::compare is a faster alternative
      because it doesn&apos;t scan through the string.
    </description>
    </rule>
    <rule key="stlcstr">
        <name>Dangerous usage of c_str(). The returned value by c_str() is invalid after this call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dangerous usage of c_str(). The returned value by c_str() is
      invalid after this call.
    </description>
    </rule>
    <rule key="stlSize">
        <name>Prefer .empty() to .size() == 0 for emptiness checking</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Possible inefficient checking for emptiness. Using .empty()
      instead of .size() can be faster.
    </description>
    </rule>
    <rule key="redundantIfRemove">
        <name>Redundant checking of STL container element</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Redundant checking of STL container element.
    </description>
    </rule>
    <rule key="useAutoPointerCopy">
        <name>Be careful when using &apos;auto_ptr&apos; copy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Copy &apos;auto_ptr&apos; pointer to another do not create two equal
      objects since one has lost its ownership of the pointer.
    </description>
    </rule>
    <rule key="useAutoPointerContainer">
        <name>Don&apos;t store &apos;auto-ptr&apos; in a STL container</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      You can randomly lose access to pointers if you store &apos;auto_ptr&apos;
      pointers in a container because the copy-semantics of &apos;auto_ptr&apos; are
      not compatible with containers.
    </description>
    </rule>
    <rule key="useAutoPointerArray">
        <name>Usage of &apos;auto_ptr&apos; for pointers obtained with operator &apos;new[]&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Object pointed by an &apos;auto_ptr&apos; is destroyed using operator
      &apos;delete&apos;. Calling &apos;delete&apos; an an pointer obtained with &apos;new[]&apos; leads
      to undefined behaviour.
    </description>
    </rule>
    <rule key="uninitstring">
        <name>Dangerous usage of variable (strncpy doesn&apos;t always 0-terminate it)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dangerous usage of variable (strncpy doesn&apos;t always 0-terminate
      it).
    </description>
    </rule>
    <rule key="uninitdata">
        <name>Data is allocated but not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Data is allocated but not initialized.
    </description>
    </rule>
    <rule key="uninitvar">
        <name>Uninitialized variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Uninitialized variable.
    </description>
    </rule>
    <rule key="unusedFunction">
        <name>Unused function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function is never used.
    </description>
    </rule>
    <rule key="unusedVariable">
        <name>Unused variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Unused variable.
    </description>
    </rule>
    <rule key="unusedAllocatedMemory">
        <name>Variable is allocated memory that is never used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Variable is allocated memory that is never used.
    </description>
    </rule>
    <rule key="unreadVariable">
        <name>Unused value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Variable is assigned a value that is never used.
    </description>
    </rule>
    <rule key="unassignedVariable">
        <name>Variable is not assigned a value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Variable is not assigned a value.
    </description>
    </rule>
    <rule key="unusedStructMember">
        <name>Unused struct or union member</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Struct or union member is never used.
    </description>
    </rule>
    <rule key="postfixOperator">
        <name>Prefer prefix ++/-- operators for non-primitive types</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Pre-increment/decrement can be more efficient than
      post-increment/decrement. Post-increment/decrement usually involves
      keeping a copy of the previous value around and adds a little extra
      code.
    </description>
    </rule>
    <rule key="syntaxError">
        <name>Syntax error</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Cppcheck cannot tokenize the code correctly.
    </description>
    </rule>
    <rule key="cppcheckError">
        <name>Internal cppcheck error</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Analysis failed. If the code is valid then please report this
      failure.
    </description>
    </rule>
    <rule key="unnecessaryForwardDeclaration">
        <name>Redundant forward declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Forward declaration unnecessary, already declared.
    </description>
    </rule>
    <rule key="variableHidingEnum">
        <name>Variable hides enumerator with same name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Variable hides enumerator with same name.
    </description>
    </rule>
    <rule key="variableHidingTypedef">
        <name>Variable hides typedef with same name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Variable hides typedef with same name
    </description>
    </rule>
    <rule key="unnecessaryQualification">
        <name>Unnecessary qualification</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Extra qualification is unnecessary and considered an error by
      many compilers.
    </description>
    </rule>
    <rule key="missingInclude">
        <name>Missing include</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      An include file cannot be found.
    </description>
    </rule>
    <rule key="preprocessorErrorDirective">
        <name>Preprocessor directive error</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Preprocessor directive error.
    </description>
    </rule>
    <rule key="publicAllocationError">
        <name>Possible leak in public function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Possible leak in public function. The pointer is not deallocated before it is allocated.
    </description>
    </rule>
    <rule key="sizeArgumentAsChar">
        <name>The size argument is given as a char constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The size argument is given as a char constant.
    </description>
    </rule>
    <rule key="bufferNotZeroTerminated">
        <name>Buffer is not zero-terminated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      A buffer is not zero-terminated after a call to a function.
    </description>
    </rule>
    <rule key="initializerList">
        <name>Member variable is in wrong order in the initializer list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Member variable is in wrong order in the initializer list.
    </description>
    </rule>
    <rule key="possibleBufferAccessOutOfBounds">
        <name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Possible buffer overflow if strlen(source) is larger than or
      equal to sizeof(destination).
    </description>
    </rule>
    <rule key="returnAddressOfFunctionParameter">
        <name>Return the address of a function parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Return the address of a function parameter.
    </description>
    </rule>
    <rule key="secondAlwaysTrueFalseWhenFirstTrue">
        <name>Redundant condition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      When first comparison is true, the second comparison is always true.
    </description>
    </rule>
    <rule key="simplePatternError">
        <name>Found simple pattern inside call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Found simple pattern inside call.
    </description>
    </rule>
    <rule key="complexPatternError">
        <name>Found complex pattern inside call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Found complex pattern inside call.
    </description>
    </rule>
    <rule key="missingPercentCharacter">
        <name>Missing percent end character in pattern</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Missing percent end character in pattern.
    </description>
    </rule>
    <rule key="boostForeachError">
        <name>Invalid usage of BOOST_FOREACH</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      BOOST_FOREACH caches the end() iterator. It&apos;s undefined behavior
      if you modify the container.
    </description>
    </rule>
    <rule key="compareBoolExpressionWithInt">
        <name>Comparison of a boolean expression with an integer other than 0 or 1</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of a boolean expression with an integer other than 0
      or 1.
    </description>
    </rule>
    <rule key="coutCerrMisusage">
        <name>Invalid usage of output stream: &apos;&lt;&lt; std::cout&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid usage of output stream: &apos;&lt;&lt; std::cout&apos;.
    </description>
    </rule>
    <rule key="incorrectStringBooleanError">
        <name>Suspicious comparison of boolean with a string literal</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      A boolean comparison with the string literal is always true.
    </description>
    </rule>
    <rule key="redundantStrcpyInSwitch">
        <name>Redundant strcpy in switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Switch case fall-through. Redundant strcpy of a variable.
    </description>
    </rule>
    <rule key="stringCompare">
        <name>Comparison of identical string variables</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of identical string variables.
    </description>
    </rule>
    <rule key="stlcstrthrow">
        <name>The returned value by c_str() is invalid after throw call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      The returned value by c_str() is invalid after throw call.
    </description>
    </rule>
    <rule key="unreachableCode">
        <name>Statements following return, break, continue, goto or throw will never be executed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Statements following return, break, continue, goto or throw will
      never be executed.
    </description>
    </rule>
    <rule key="uselessCallsCompare">
        <name>It is inefficient to call &apos;str.find(str)&apos; as it always returns 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      It is inefficient to call &apos;str.find(str)&apos; as it always returns 0.
    </description>
    </rule>
    <rule key="uselessCallsSwap">
        <name>It is inefficient to swap a object with itself by calling &apos;str.swap(str)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      It is inefficient to swap a object with itself by calling
      &apos;str.swap(str)&apos;.
    </description>
    </rule>
    <rule key="uselessCallsSubstr">
        <name>Function &apos;substr&apos; useless call. Function create copy of the &apos;str&apos; object</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Useless call of function &apos;substr&apos; because it returns a copy of the object. Use operator= instead.
    </description>
    </rule>
    <rule key="wrongcctypecall">
        <name>Wrong usage of a function from the ctype-family</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Passing negative values to the functions of the ctype-family
      (isalnum|isalpha|isascii|is..) causes undefined behavior.
    </description>
    </rule>
    <rule key="debug">
        <name>Debug</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>cppcheck</repo>
        <description>
      Any kind of debug message
    </description>
    </rule>
    <rule key="doubleCloseDir">
        <name>Directory handle is closed twice</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Directory handle is closed twice.
    </description>
    </rule>
    <rule key="doubleFree">
        <name>Memory is freed twice</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Memory is freed twice.
    </description>
    </rule>
    <rule key="invalidPrintfArgType_s">
        <name>Invalid printf argument type (character pointer required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (character pointer required).
    </description>
    </rule>
    <rule key="invalidPrintfArgType_n">
        <name>Invalid printf argument type (integer pointer required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (integer pointer required).
    </description>
    </rule>
    <rule key="invalidPrintfArgType_p">
        <name>Invalid printf argument type (integer or pointer required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (integer or pointer required).
    </description>
    </rule>
    <rule key="invalidPrintfArgType_int">
        <name>Invalid printf argument type (integer required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (integer required).
    </description>
    </rule>
    <rule key="invalidPrintfArgType_sint">
        <name>Invalid printf argument type (signed integer required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (signed integer required).
    </description>
    </rule>
    <rule key="invalidPrintfArgType_float">
        <name>Invalid printf argument type (floating point number required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (floating point number required).
    </description>
    </rule>
    <rule key="invalidScanfArgType">
        <name>scanf argument no. 1: requires non-const pointers or arrays as arguments</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      scanf argument no. 1: requires non-const pointers or arrays as
      arguments.
    </description>
    </rule>
    <rule key="obsoleteFunctionsasctime">
        <name>Avoid usage of the function &apos;asctime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;asctime&apos; is obsolete. It is recommended to use the
      function &apos;strftime&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionsasctime_r">
        <name>Avoid usage of the function &apos;asctime_r&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;asctime_r&apos; is obsolete. It is recommended to use
      the function &apos;strftime&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionsctime">
        <name>Avoid usage of the function &apos;ctime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;ctime&apos; is obsolete. It is recommended to use the
      function &apos;strftime&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionsrand_r">
        <name>Avoid usage of the function &apos;rand_r&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;rand_r&apos; is obsolete. It is recommended to use the
      function &apos;rand&apos; instead.
    </description>
    </rule>
    <rule key="obsoleteFunctionstmpnam">
        <name>Avoid usage of the function &apos;tmpnam&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;tmpnam&apos; is obsolete. It is recommended to use
      either &apos;tmpfile&apos;, &apos;mkstemp&apos;, or &apos;mkdtemp&apos; instead for this function.
    </description>
    </rule>
    <rule key="obsoleteFunctionstmpnam_r">
        <name>Avoid usage of the function &apos;tmpnam_r&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;tmpnam_r&apos; is obsolete. It is recommended to use
      either &apos;tmpfile&apos;, &apos;mkstemp&apos;, or &apos;mkdtemp&apos; instead for this function.
    </description>
    </rule>
    <rule key="obsoleteFunctionsutime">
        <name>Avoid usage of the function &apos;utime&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The function &apos;utime&apos; is obsolete. It is recommended to use the
      function &apos;utimensat&apos; instead.
    </description>
    </rule>
    <rule key="wrongPrintfScanfArgNum">
        <name>Wrong number of parameters given to printf()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Wrong number of parameters given to printf().
    </description>
    </rule>
    <rule key="uninitMemberVar">
        <name>Member variable is not initialized in the constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Member variable is not initialized in the constructor.
    </description>
    </rule>
    <rule key="redundantCondition">
        <name>Redundant condition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      This condition will always have the same result.
    </description>
    </rule>
    <rule key="invalidPointerCast">
        <name>Invalid pointer casting</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      This casting is not portable due to different binary data representations on different platforms.
    </description>
    </rule>
    <rule key="virtualDestructor">
        <name>Base classes should have virtual destructors</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Class Base which is inherited by class Derived does not have a virtual destructor
    </description>
    </rule>
    <rule key="leakNoVarFunctionCall">
        <name>Memory leak across function calls</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Memory allocated inside the called function is not freed by the caller function.
    </description>
    </rule>
    <rule key="stlcstrReturn">
        <name>Redundant c_str()-conversion in functions return</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning the result of c_str() in a function that returns std::string is slow and redundant.
    </description>
    </rule>
    <rule key="stlcstrParam">
        <name>Redundant c_str()-conversion in parameter passing</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Passing the result of c_str() to a function that takes std::string as argument 0 is slow and redundant.
    </description>
    </rule>
    <rule key="StlMissingComparison">
        <name>Missing bounds check for extra iterator increment in loop</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Missing bounds check for extra iterator increment in loop. The iterator incrementing is suspicious - it is incremented at line &apos;line-number-1&apos; and then at line &apos;line-number-2&apos;
      The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end.
    </description>
    </rule>
    <rule key="strncatUsage">
        <name>Dangerous usage of strncat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append.
      strncat appends at max its 3rd parameter&apos;s amount of characters. The safe way to use strncat is to calculate remaining space in the buffer and use it as 3rd parameter.
    </description>
    </rule>
    <rule key="CastIntegerToAddressAtReturn">
        <name>Returning an integer in a function with pointer return type is not portable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning an integer in a function with pointer return type is not portable.
    </description>
    </rule>
    <rule key="IOWithoutPositioning">
        <name>Read and write operations without a call to a positioning function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour.
    </description>
    </rule>
    <rule key="bitwiseOnBoolean">
        <name>Boolean variable is used in bitwise operation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Boolean variable is used in bitwise operation.
    </description>
    </rule>
    <rule key="deallocret">
        <name>Returning/dereferencing variable after it is deallocated / released</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning/dereferencing variable after it is deallocated / released.
    </description>
    </rule>
    <rule key="invalidScanfFormatWidth">
        <name>wrong width for scanf parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Width &apos;parameter&apos; given in format string (no. &apos;symbol&apos; ) doesn&apos;t match destination buffer.
    </description>
    </rule>
    <rule key="leakconfiguration">
        <name>Function configuration is needed to establish if there is a leak or not</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>cppcheck</repo>
        <description>
      Function configuration is needed to establish if there is a leak or not.
    </description>
    </rule>
    <rule key="missingScanfFormatWidth">
        <name>wrong width for scanf parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Width &apos;parameter&apos; given in format string (no. &apos;symbol&apos; ) doesn&apos;t match destination buffer.
    </description>
    </rule>
    <rule key="moduloAlwaysTrueFalse">
        <name>Comparison of modulo result is predetermined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of modulo result is predetermined.
    </description>
    </rule>
    <rule key="pointerSize">
        <name>Using size of pointer variable instead of size of its data</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Using size of pointer variable instead of size of its data.
    </description>
    </rule>
    <rule key="possibleReadlinkBufferOverrun">
        <name>Function might return the full size of variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Function might return the full size of variable.
    </description>
    </rule>
    <rule key="readWriteOnlyFile">
        <name>Read operation on a file that was opened only for writing</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Read operation on a file that was opened only for writing.
    </description>
    </rule>
    <rule key="redundantBitwiseOperationInSwitch">
        <name>Redundant bitwise operation on variable in switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Redundant bitwise operation on variable in switch.
    </description>
    </rule>
    <rule key="suspiciousSemicolon">
        <name>Suspicious use of ; at the end of &apos;if/for/while&apos; statement</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Suspicious use of ; at the end of &apos;if/for/while&apos; statement.
    </description>
    </rule>
    <rule key="useClosedFile">
        <name>Used file that is not opened</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Used file that is not opened.
    </description>
    </rule>
    <rule key="useInitializationList">
        <name>member variable shall be initialized using constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don&apos;t explicitly write them to the initialization list.
      You could avoid assigning &apos;symbol&apos; a value by passing the value to the constructor in the initialization list.
    </description>
    </rule>
    <rule key="writeReadOnlyFile">
        <name>Write operation on a file that was opened only for reading</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Write operation on a file that was opened only for reading.
    </description>
    </rule>
    <rule key="clarifyStatement">
        <name>Check statement and clarify behavior</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>cppcheck</repo>
        <description>
      A statement like &apos;*A++;&apos; might not do what you intended. &apos;operator*&apos; is executed before postfix &apos;operator++&apos;. Thus, the dereference is meaningless. Did you intend to write &apos;(*A)++;&apos;?
    </description>
    </rule>
    <rule key="comparisonOfBoolWithInvalidComparator">
        <name>Comparison of a boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of a boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.
    </description>
    </rule>
    <rule key="functionStatic">
        <name>The member function &apos;funcname&apos; can be static</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The member function &apos;funcname&apos; can be static.
    </description>
    </rule>
    <rule key="incompleteArrayFill">
        <name>Array &apos;buffer&apos; is filled incompletely</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Array &apos;buffer&apos; is filled incompletely.
    </description>
    </rule>
    <rule key="invalidPrintfArgType_uint">
        <name>Invalid printf argument type (unsigned integer required)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid printf argument type (unsigned integer required)
    </description>
    </rule>
    <rule key="literalWithCharPtrCompare">
        <name>String literal compared with a variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      String literal compared with a variable.
    </description>
    </rule>
    <rule key="pointerLessThanZero">
        <name>A pointer can not be negative so it is either pointless or an error to check if it is</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      A pointer can not be negative so it is either pointless or an error to check if it is.
    </description>
    </rule>
    <rule key="pointerPositive">
        <name>A pointer can not be negative so it is either pointless or an error to check if it is not</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      A pointer can not be negative so it is either pointless or an error to check if it is not.
    </description>
    </rule>
    <rule key="redundantCopyLocalConst">
        <name>Use const reference for &apos;varname&apos; to avoid unnecessary data copying</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Use const reference for &apos;varname&apos; to avoid unnecessary data copying.
    </description>
    </rule>
    <rule key="redundantOperationInSwitch">
        <name>Redundant operation on &apos;varname&apos; in switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Redundant operation on &apos;varname&apos; in switch.
    </description>
    </rule>
    <rule key="shiftNegative">
        <name>Shifting by a negative value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Shifting by a negative value.
    </description>
    </rule>
    <rule key="unknownPattern">
        <name>Unknown pattern used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Unknown pattern used.
    </description>
    </rule>
    <rule key="uselessCallsEmpty">
        <name>Useless call of function &apos;empty()&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Useless call of function &apos;empty()&apos;. Did you intend to call &apos;clear()&apos; instead?
    </description>
    </rule>
    <rule key="uselessCallsRemove">
        <name>Return value of std::remove() ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Return value of std::remove() ignored.
    </description>
    </rule>
    <rule key="ConfigurationNotChecked">
        <name>
      Skipping configuration &apos;X&apos; since the value of &apos;X&apos; is unknown
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Skipping configuration &apos;X&apos; since the value of &apos;X&apos; is unknown. Use -D if you want to check it. You can use -U to skip it explicitly.
    </description>
    </rule>
    <rule key="toomanyconfigs">
        <name>
      Too many #ifdef configurations - cppcheck only checks 12 configurations
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Too many #ifdef configurations - cppcheck only checks 12 configurations. Use --force to check all configurations. For more details, use --enable=information.
    </description>
    </rule>
    <rule key="CastAddressToIntegerAtReturn">
        <name>Returning an address value in a function with integer return type is not portable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Returning an address value in a function with integer return type is not portable.
    </description>
    </rule>
    <rule key="comparisonOfBoolWithBoolError">
        <name>Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of a variable having boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.
    </description>
    </rule>
    <rule key="comparisonOfFuncReturningBoolError">
        <name>Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of a function returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.
    </description>
    </rule>
    <rule key="comparisonOfTwoFuncsReturningBoolError">
        <name>Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of two functions returning boolean value using relational (&lt;, &gt;, &lt;= or &gt;=) operator.
    </description>
    </rule>
    <rule key="copyCtorPointerCopying">
        <name>Value of pointer &apos;varname&apos;, which points to allocated memory, is copied in copy constructor instead of allocating new memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Value of pointer &apos;varname&apos;, which points to allocated memory, is copied in copy constructor instead of allocating new memory.
    </description>
    </rule>
    <rule key="invalidFree">
        <name>Invalid memory address freed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Invalid memory address freed.
    </description>
    </rule>
    <rule key="invalidLengthModifierError">
        <name>&apos;modifier&apos; in format string is a length modifier and cannot be used without a conversion specifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      &apos;modifier&apos; in format string is a length modifier and cannot be used without a conversion specifier.
    </description>
    </rule>
    <rule key="noCopyConstructor">
        <name>&apos;classname&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      &apos;classname&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.
    </description>
    </rule>
    <rule key="oppositeInnerCondition">
        <name>Opposite conditions in nested &apos;if&apos; blocks lead to a dead code block</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Opposite conditions in nested &apos;if&apos; blocks lead to a dead code block.
    </description>
    </rule>
    <rule key="redundantAssignment">
        <name>Variable &apos;var&apos; is reassigned a value before the old one has been used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Variable &apos;var&apos; is reassigned a value before the old one has been used.
    </description>
    </rule>
    <rule key="redundantCopyInSwitch">
        <name>Buffer &apos;var&apos; is being written before its old content has been used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Buffer &apos;var&apos; is being written before its old content has been used. &apos;break;&apos; missing?
    </description>
    </rule>
    <rule key="redundantNextPrevious">
        <name>Call to &apos;Token::func1()&apos; followed by &apos;Token::func2()&apos; can be simplified</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Call to &apos;Token::func1()&apos; followed by &apos;Token::func2()&apos; can be simplified.
    </description>
    </rule>
    <rule key="unsafeClassCanLeak">
        <name>Class &apos;classname&apos; is unsafe, &apos;varname&apos; can leak by wrong usage</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Class &apos;classname&apos; is unsafe, &apos;varname&apos; can leak by wrong usage.
    </description>
    </rule>
    <rule key="redundantCopy">
        <name>Buffer &apos;var&apos; is being written before its old content has been used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Buffer &apos;var&apos; is being written before its old content has been used.
    </description>
    </rule>
    <rule key="argumentSize">
        <name>
      Passing too small array as argument.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The array is too small, the function expects a bigger array.
    </description>
    </rule>
    <rule key="checkCastIntToCharAndBack">
        <name>
      Storing func_name() return value in char variable and then comparing with EOF.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Storing func_name() return value in char variable and then comparing with EOF.
    </description>
    </rule>
    <rule key="mallocOnClassError">
        <name>
      Bad memory allocation for class containing std::string.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Memory for class instance allocated with malloc(), but class contains a std::string.
    </description>
    </rule>
    <rule key="mallocOnClassWarning">
        <name>
      Memory for class instance allocated with malloc(), but class provides constructors.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Memory for class instance allocated with malloc(), but class provides constructors.
    </description>
    </rule>
    <rule key="mismatchingBitAnd">
        <name>
      Mismatching bitmasks.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Mismatching bitmasks. Result is always 0 (X = Y &amp; 0xf0; Z = X &amp; 0x1; =&gt; Z=0).
    </description>
    </rule>
    <rule key="missingIncludeSystem">
        <name>
      Included file not found.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Cannot find an included file, the code analysis may be inaccurate.
    </description>
    </rule>
    <rule key="stlBoundaries">
        <name>
      Dangerous iterator comparison using operator &lt;.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dangerous iterator comparison using operator&lt; on a STL container.
    </description>
    </rule>
    <rule key="tooBigSleepTime">
        <name>
      Invalid argument for usleep
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      The argument of usleep must be less than 1000000.
    </description>
    </rule>
    <rule key="uninitStructMember">
        <name>
      Uninitialized struct member
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Missing initialization for a struct member.
    </description>
    </rule>
    <rule key="uselessAssignmentPtrArg">
        <name>
      Effectless function parameter assignment.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Assignment of function parameter has no effect outside the function.
    </description>
    </rule>
    <rule key="varFuncNullUB">
        <name>
      Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.
    </description>
    </rule>
    <rule key="writeOutsideBufferSize">
        <name>
      Writing &apos;1&apos; bytes outside buffer size.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      Writing &apos;1&apos; bytes outside buffer size.
    </description>
    </rule>
    <rule key="wrongPipeParameterSize">
        <name>
      A buffer must have size of 2 integers if used as parameter of pipe().
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      A buffer must have size of 2 integers if used as parameter of pipe().
    </description>
    </rule>
    <rule key="class_X_Y">
        <name>Unhandles code</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      This code is not handled. You can use -I or --include to add handling of this code.
    </description>
    </rule>
    <rule key="derefInvalidIterator">
        <name>
      Possible dereference of an invalid iterator
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Possible dereference of an invalid iterator
    </description>
    </rule>
    <rule key="arithOperationsOnVoidPointer">
        <name>
      Undefined pointer calculation behaviour
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      When using void pointers in calculations, the behaviour is undefined.
    </description>
    </rule>
    <rule key="commaSeparatedReturn">
        <name>
      Usage of comma in return statements
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Dont use the comma in return statements: it can be easily be misread as a &apos;;&apos;.
    </description>
    </rule>
    <rule key="nanInArithmeticExpression">
        <name>
      Using NaN/Inf in a computation.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Using NaN/Inf in a computation.
    </description>
    </rule>
    <rule key="sizeofDereferencedVoidPointer">
        <name>
      Usage of &apos;sizeof&apos; on dereferenced void pointer.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      The behaviour of &apos;sizeof(void)&apos; is not covered by the ISO C standard.
    </description>
    </rule>
    <rule key="sizeofVoid">
        <name>
      Behaviour of &apos;sizeof(void)&apos; is undefined
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Behaviour of &apos;sizeof(void)&apos; is not covered by the ISO C standard.
    </description>
    </rule>
    <rule key="wrongPrintfScanfParameterPositionError">
        <name>
      printf: referencing parameter 2 while 1 arguments given.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      printf: referencing parameter 2 while 1 arguments given.
    </description>
    </rule>
    <rule key="obsoleteFunctionsctime_r">
        <name>
      Obsolete function &apos;ctime_r&apos; called
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Obsolete function &apos;ctime_r&apos; called. It is recommended to use the function &apos;strftime&apos; instead.
    </description>
    </rule>
    <rule key="duplInheritedMember">
        <name>
      Redefinition of a member variable in a subclass.
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      A subclass defines a member variable which is already defined in its parent class.
    </description>
    </rule>
    <rule key="invalidScanfArgType_int">
        <name>Mismatch in string format: &apos;unsigned int *&apos; vs &apos;DWORD *&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      The format string requires &apos;unsigned int *&apos; but the argument type is &apos;DWORD * {aka unsigned long *}&apos;
    </description>
    </rule>
    <rule key="invalidScanfArgType_float">
        <name>Mistmatch in string format: &apos;float *&apos; vs Unknown.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      %f in format string requires &apos;float *&apos; but the argument type is Unknown.
    </description>
    </rule>
    <rule key="invalidScanfArgType_s">
        <name>Mismatch in string format: &apos;char *&apos; vs Unknown.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>cppcheck</repo>
        <description>
      %s in format string requires a &apos;char *&apos; but the argument type is Unknown.
    </description>
    </rule>
    <rule key="comparisonFunctionIsAlwaysTrueOrFalse">
        <name>Suspicious variable comparison with isless()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Comparison of two identical variables with isless(varName,varName) evaluates always to false.
    </description>
    </rule>
    <rule key="zerodivcond">
        <name>Potential division by zero</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>cppcheck</repo>
        <description>
      Either the condition is useless or there is division by zero.
    </description>
    </rule>
    <rule key="1">
        <name>L0001: Unclosed Comment (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>End of file was reached with an open comment still unclosed. The Location of the open comment is shown.</description>
    </rule>
    <rule key="2">
        <name>L0002: Unclosed Quote</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An end of line was reached and a matching quote character (single or double) to an earlier quote character on the same line was not found.</description>
    </rule>
    <rule key="3">
        <name>L0003: #else without a #if</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A #else was encountered not in the scope of a #if, #ifdef or #ifndef.</description>
    </rule>
    <rule key="4">
        <name>L0004: Too many #if levels</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An internal limit was reached on the level of nesting of #if statements (including #ifdef and #ifndef).</description>
    </rule>
    <rule key="5">
        <name>L0005: Too many #endif&apos;s</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A #endif was encountered not in the scope of a #if or #ifdef or #ifndef.</description>
    </rule>
    <rule key="6">
        <name>L0006: Stack Overflow</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>One of the built-in non-extend-able stacks has been overextended. The possibilities are too many nested #if statements, #includes statements (including all recursive #include statements), static blocks (bounded by braces) or #define replacements.</description>
    </rule>
    <rule key="7">
        <name>L0007: Unable to open include file: FileName</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>FileName is the name of the include file which could not be opened.</description>
    </rule>
    <rule key="8">
        <name>L0008: Unclosed #if (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A #if (or #ifdef or #ifndef) was encountered without a corresponding #endif. Location is the location of the #if.</description>
    </rule>
    <rule key="9">
        <name>L0009: Too many #else&apos;s in #if (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A given #if contained a #else which in turn was followed by either another #else or a #elif. The error message gives the line of the #if statement that started the conditional that contained the aberration.</description>
    </rule>
    <rule key="10">
        <name>L0010: Expecting &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>String is the expected token. The expected token could not be found. This is commonly given when certain reserved words are not recognized. int __interrupt f(); will receive an Expecting &apos;;&apos; message at the f because it thinks you just declared __interrupt. The cure is to establish a new reserved word with +rw(__interrupt). Also, make sure you are using the correct compiler options file.</description>
    </rule>
    <rule key="11">
        <name>L0011: Excessive Size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The file name specified on a #include line had a length that exceeded FILENAME_MAX characters.</description>
    </rule>
    <rule key="12">
        <name>L0012: Need &lt; or &quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>After a #include is detected and after macro substitution is performed, a file specification of the form &lt;filename&gt; or &quot;filename&quot; is expected.</description>
    </rule>
    <rule key="13">
        <name>L0013: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A type adjective such as long, unsigned, etc. cannot be applied to the type which follows.</description>
    </rule>
    <rule key="14">
        <name>L0014: Symbol &apos;Symbol&apos; previously defined (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named object has been defined a second time. The location of the previous definition is provided. If this is a tentative definition (no initializer) then the message can be suppressed with the +fmd flag.</description>
    </rule>
    <rule key="15">
        <name>L0015: Symbol &apos;Symbol&apos; redeclared (TypeDiff) (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named symbol has been previously declared or defined in some other module (location given) with a type different from the type given by the declaration at the current location. The parameter TypeDiff provides further information on how the types differ.</description>
    </rule>
    <rule key="16">
        <name>L0016: Unrecognized name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A # directive is not followed by a recognizable word. If this is not an error, use the +ppw option.</description>
    </rule>
    <rule key="17">
        <name>L0017: Unrecognized name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-parameter is being declared where only parameters should be.</description>
    </rule>
    <rule key="18">
        <name>L0018: Symbol &apos;Symbol&apos; redeclared (TypeDiff) conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A symbol is being redeclared. The parameter TypeDiff provides further information on how the types differ. Location is the location of the previous definition.</description>
    </rule>
    <rule key="19">
        <name>L0019: Useless Declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A type appeared by itself without an associated variable, and the type was not a struct and not a union and not an enum. A double semi-colon can cause this as in:
    int x;;</description>
    </rule>
    <rule key="20">
        <name>L0020: Illegal use of =</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declaration was followed by an = sign.</description>
    </rule>
    <rule key="21">
        <name>L0021: Expected {</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer for an indefinite size array must begin with a left brace.</description>
    </rule>
    <rule key="22">
        <name>L0022: Illegal operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A unary operator was found following an operand and the operator is not a post operator.</description>
    </rule>
    <rule key="23">
        <name>L0023: Expected colon</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A ? operator was encountered but this was not followed by a : as was expected.</description>
    </rule>
    <rule key="24">
        <name>L0024: Expected an expression, found &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An operator was found at the start of an expression but it was not a unary operator.</description>
    </rule>
    <rule key="25">
        <name>L0025: Illegal constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Too many characters were encountered in a character constant (a constant bounded by &apos; marks).</description>
    </rule>
    <rule key="26">
        <name>L0026: Expected an expression, found &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression was not found where one was expected. The unexpected token is placed in the message.</description>
    </rule>
    <rule key="27">
        <name>L0027: Illegal character (0xhh)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An illegal character was found in the source code. The hex code is provided in the message. A blank is assumed. If you are using strange characters in identifier names you will get this message for which you may use the -ident option.</description>
    </rule>
    <rule key="28">
        <name>L0028: Redefinition of symbol &apos;Symbol&apos; Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The identifier preceding a colon was previously declared at the Location given as not being a label.</description>
    </rule>
    <rule key="30">
        <name>L0030: Expected a constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constant was expected but not obtained. This could be following a case keyword, an array dimension, bit field length, enumeration value, #if expression, etc.</description>
    </rule>
    <rule key="31">
        <name>L0031: Redefinition of symbol &apos;Symbol&apos; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A data object or function previously defined in this module is being redefined.</description>
    </rule>
    <rule key="32">
        <name>L0032: Field size (member &apos;Symbol&apos;) should not be zero</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The length of a field was given as non-positive, (0 or negative).</description>
    </rule>
    <rule key="33">
        <name>L0033: Illegal constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constant was badly formed as when an octal constant contains one of the digits 8 or 9.</description>
    </rule>
    <rule key="34">
        <name>L0034: Non-constant initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-constant initializer was found for a static data item.</description>
    </rule>
    <rule key="35">
        <name>L0035: Initializer has side-effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer with side effects was found for a static data item.</description>
    </rule>
    <rule key="36">
        <name>L0036: Redefining the storage class of symbol &apos;Symbol&apos; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An object&apos;s storage class is being changed.</description>
    </rule>
    <rule key="37">
        <name>L0037: Value of enumerator &apos;Symbol&apos; inconsistent (conflicts with Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An enumerator was inconsistently valued.</description>
    </rule>
    <rule key="38">
        <name>L0038: Offset of symbol &apos;Symbol&apos; inconsistent (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member of a class or struct appears in a different position (offset from the start of the structure) than an earlier declaration. This could be caused by array dimensions changing from one module to another.</description>
    </rule>
    <rule key="39">
        <name>L0039: Redefinition of symbol &apos;Symbol&apos; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A struct or union is being redefined.</description>
    </rule>
    <rule key="40">
        <name>L0040: Undeclared identifier &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within an expression, an identifier was encountered that had not previously been declared and was not followed by a left parenthesis. Name is the name of the identifier.</description>
    </rule>
    <rule key="41">
        <name>L0041: Redefinition of symbol &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A parameter of either a function or a macro is being repeated.</description>
    </rule>
    <rule key="42">
        <name>L0042: Expected a statement</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A statement was expected but a token was encountered that could not possibly begin a statement.</description>
    </rule>
    <rule key="43">
        <name>L0043: Vacuous type for variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A vacuous type was found such as the void type in a context that expected substance.</description>
    </rule>
    <rule key="44">
        <name>L0044: Need a switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A case or default statement occurred outside a switch.</description>
    </rule>
    <rule key="45">
        <name>L0045: Bad use of register</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable is declared as a register but its type is inconsistent with it being a register (such as a function).</description>
    </rule>
    <rule key="46">
        <name>L0046: Field type should be int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bit fields in a structure should be typed unsigned or int. If your compiler allows other kinds of objects, such as char, then simply suppress this message.</description>
    </rule>
    <rule key="47">
        <name>L0047: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unary minus requires an arithmetic operand.</description>
    </rule>
    <rule key="48">
        <name>L0048: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unary * or the left hand side of the ptr (-&gt;) operator requires a pointer operand.</description>
    </rule>
    <rule key="49">
        <name>L0049: Expected a type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Only types are allowed within prototypes. A prototype is a function declaration with a sequence of types within parentheses. The processor is at a state where it has detected at least one type within parentheses and so is expecting more types or a closing right parenthesis.</description>
    </rule>
    <rule key="50">
        <name>L0050: Attempted to take the address of a non-lvalue</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unary &amp; operator requires an lvalue (a value suitable for placement on the left hand side of an assignment operator).</description>
    </rule>
    <rule key="51">
        <name>L0051: Expected integral type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unary ~ expects an integral type (signed or unsigned char, short, int, or long).</description>
    </rule>
    <rule key="52">
        <name>L0052: Expected an lvalue</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>autodecrement (--) and autoincrement (++) operators require an lvalue (a value suitable for placement on the left hand side of an assignment operator). Remember that casts do not normally produce lvalues. Thus
    ++(char *)p;
    is illegal according to the ANSI standard. This construct is allowed by some compilers and is allowed if you use the +fpc option (Pointer Casts are lvalues).</description>
    </rule>
    <rule key="53">
        <name>L0053: Expected a scalar</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Autodecrement (--) and autoincrement (++) operators may only be applied to scalars (arithmetics and pointers) or to objects for which these operators have been defined.</description>
    </rule>
    <rule key="54">
        <name>L0054: Division by 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The constant 0 was used on the right hand side of the division operator (/) or the remainder operator (%).</description>
    </rule>
    <rule key="55">
        <name>L0055: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The context requires a scalar, function, array, or struct (unless -fsa).</description>
    </rule>
    <rule key="56">
        <name>L0056: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Add/subtract operator requires scalar types and pointers may not be added to pointers.</description>
    </rule>
    <rule key="57">
        <name>L0057: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bit operators ( &amp;, | and ^ ) require integral arguments.</description>
    </rule>
    <rule key="58">
        <name>L0058: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bad arguments were given to a relational operator; these always require two scalars and pointers can&apos;t be compared with integers (unless constant 0).</description>
    </rule>
    <rule key="59">
        <name>L0059: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The amount by which an item can be shifted must be integral.</description>
    </rule>
    <rule key="60">
        <name>L0060: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The value to be shifted must be integral.</description>
    </rule>
    <rule key="61">
        <name>L0061: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The context requires a Boolean. Booleans must be some form of arithmetic or pointer.</description>
    </rule>
    <rule key="62">
        <name>L0062: Incompatible types (TypeDiff) for operator &apos;:&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The 2nd and 3rd arguments to ? : must be compatible types.</description>
    </rule>
    <rule key="63">
        <name>L0063: Expected an lvalue</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Assignment expects its first operand to be an lvalue. Please note that a cast removes the lvaluedness of an expression.</description>
    </rule>
    <rule key="64">
        <name>L0064: Type mismatch (Context) (TypeDiff)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There was a mismatch in types across an assignment (or implied assignment, see Context). TypeDiff specifies the type difference.</description>
    </rule>
    <rule key="65">
        <name>L0065: Expected a member name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>After a dot (.) or pointer (-&gt;) operator a member name should appear.</description>
    </rule>
    <rule key="66">
        <name>L0066: Bad type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A void type was employed where it is not permitted. If a void type is placed in a prototype then it must be the only type within a prototype. (See error number 49.)</description>
    </rule>
    <rule key="67">
        <name>L0067: Can&apos;t cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Attempt to cast a non-scalar to an integral.</description>
    </rule>
    <rule key="68">
        <name>L0068: Can&apos;t cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Attempt to cast a non-arithmetic to a float.</description>
    </rule>
    <rule key="69">
        <name>L0069: Can&apos;t cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bad conversion involving incompatible structures or a structure and some other object.</description>
    </rule>
    <rule key="70">
        <name>L0070: Can&apos;t cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Attempt to cast to a pointer from an unusual type (non-integral).</description>
    </rule>
    <rule key="71">
        <name>L0071: Can&apos;t cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Attempt to cast to a type that does not allow conversions.</description>
    </rule>
    <rule key="72">
        <name>L0072: Bad option &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Was not able to interpret an option. The option is given in String.</description>
    </rule>
    <rule key="73">
        <name>L0073: Bad left operand</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The cursor is positioned at or just beyond either an -&gt; or a . operator. These operators expect an expression primary on their left. Please enclose any complex expression in this position within parentheses.</description>
    </rule>
    <rule key="74">
        <name>L0074: Address of Register</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to apply the address (&amp;) operator to a variable whose storage class was given as register.</description>
    </rule>
    <rule key="75">
        <name>L0075: Too late to change sizes (option &apos;String&apos;)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The size option was given after all or part of a module was processed. Make sure that any option to reset sizes of objects be done at the beginning of the first module processed or on the command line before any module is processed.</description>
    </rule>
    <rule key="76">
        <name>L0076: can&apos;t open file String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>String is the name of the file. The named file could not be opened for output. The file was destined to become a PC-lint/FlexeLint object module.</description>
    </rule>
    <rule key="77">
        <name>L0077: Address of bit-field cannot be taken</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of a bit-field cannot be taken. The rules of C only allow for taking the address of a whole byte (a whole char).</description>
    </rule>
    <rule key="78">
        <name>L0078: Symbol &apos;Symbol&apos; typedef&apos;ed at Location used in expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named symbol was defined in a typedef statement and is therefore considered a type. It was subsequently found in a context where an expression was expected.</description>
    </rule>
    <rule key="79">
        <name>L0079: Bad type for % operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The % operator should be used with some form of integer.</description>
    </rule>
    <rule key="80">
        <name>L0080: this use of ellipsis is not strictly ANSI</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The ellipsis should be used in a prototype only after a sequence of types not after a sequence of identifiers. Some compilers support this extension. If you want to use this feature suppress this message.</description>
    </rule>
    <rule key="81">
        <name>L0081: struct/union not permitted in equality comparison</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two struct&apos;s or union&apos;s are being compared with one of == or !=. This is not permitted by the ANSI standard. If your compiler supports this, suppress this message.</description>
    </rule>
    <rule key="82">
        <name>L0082: return &lt;exp&gt;; illegal with void function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The ANSI standard does not allow an expression form of the return statement with a void function. If you are trying to cast to void as in return (void)f(); and your compiler allows it, suppress this message.</description>
    </rule>
    <rule key="83">
        <name>L0083: Incompatible pointer types with subtraction</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two pointers being subtracted have indirect types which differ. You can get PC-lint/FlexeLint to ignore slight differences in the pointers by employing one or more of the -ep... options.</description>
    </rule>
    <rule key="84">
        <name>L0084: sizeof object is zero or object is undefined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A sizeof returned a 0 value. This could happen if the object were undefined or incompletely defined. Make sure a complete definition of the object is in scope when you use sizeof.</description>
    </rule>
    <rule key="85">
        <name>L0085: Array &apos;Symbol&apos; has dimension 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An array (named Symbol) was declared without a dimension in a context that required a non-zero dimension.</description>
    </rule>
    <rule key="86">
        <name>L0086: Structure &apos;Symbol&apos; has no data elements</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A structure was declared (in a C module) that had no data members. Though legal in C++ this is not legal C.</description>
    </rule>
    <rule key="87">
        <name>L0087: Expression too complicated for #ifdef or #ifndef</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>By the rules of C there should be only a single identifier following a #ifdef or a #ifndef. You may also supply a validly constructed C (or C++) comment.</description>
    </rule>
    <rule key="88">
        <name>L0088: Symbol &apos;Symbol&apos; is an array of empty elements</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An array was declared (in a C module) whose elements were each of 0 length. Though legal in C++ this is not permitted C.</description>
    </rule>
    <rule key="89">
        <name>L0089: Argument or option too long (&apos;String&apos;)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The length of an option (shown in String) exceeds an internal limit. Please try to decompose the option into something smaller. At this writing the limit is 610 characters.</description>
    </rule>
    <rule key="90">
        <name>L0090: Option &apos;String&apos; is only appropriate within a lint comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated option is not appropriate at the command or the .lnt level. For example if -unreachable is given on the command line you will get this message.</description>
    </rule>
    <rule key="91">
        <name>L0091: Line exceeds Integer characters (use +linebuf)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A line read from one of the input files is longer than anticipated. By default the line buffer size is 600 characters. Each time you use the +linebuf option you can double this size. The size can be doubled ad infinitum.</description>
    </rule>
    <rule key="92">
        <name>L0092: Negative array dimension or bit field length (Integer)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A negative array dimension or bit field length is not permitted.</description>
    </rule>
    <rule key="93">
        <name>L0093: New-line is not permitted within string arguments to macros</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A macro invocation contains a string that is split across more than one line. For example: A( &quot;Hello World&quot; );
    will trigger this message. Some compilers accept this construct and you can suppress this message with -e93 if this is your current practice. But it is more portable to place the string constant on one line. Thus
    A( &quot;Hello World&quot; );
    would be better.</description>
    </rule>
    <rule key="95">
        <name>L0095: Expected a macro parameter but instead found &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The # operator (or the non-standard extension to the # operator spelled #@) was found within a macro definition but was not immediately followed by a parameter of the macro as is required by the standards. Name identifies the token immediately to the right of the operator.</description>
    </rule>
    <rule key="96">
        <name>L0096: Unmatched left brace for String on Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The purpose of this message is to report the location of a left curly brace that is unmatched by a right curly brace. Such an unmatched left curly can be far removed from the point at which the unbalance was detected (often the end of the compilation unit). Providing the location of the left curly can be extremely helpful in determining the source of the imbalance.</description>
    </rule>
    <rule key="98">
        <name>L0098: Recovery Error (String)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A recovery error is issued when an inconsistent state was found while attempting to recover from a syntactic error. The String provided in the message serves as a clue to this inconsistent state. Since the presumptive cause of the error is an earlier error, priority should be placed on resolving the original error. This &quot;Recovery Error&quot; is meant only to provide additional information on the state of the parser.</description>
    </rule>
    <rule key="101">
        <name>L0101: Expected an identifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>While processing a function declarator, a parameter specifier was encountered that was not an identifier, whereas a prior parameter was specified as an identifier. This is mixing old-style function declarations with the new-style and is not permitted. For example
    void f(n,int m)
    will elicit this message.</description>
    </rule>
    <rule key="102">
        <name>L0102: Illegal parameter specification</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a function declarator, a parameter must be specified as either an identifier or as a type followed by a declarator.</description>
    </rule>
    <rule key="103">
        <name>L0103: Unexpected declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>After a prototype, only a comma, semi-colon, right parenthesis or a left brace may occur. This error could occur if you have omitted a terminating character after a declaration or if you are mixing old-style parameter declarations with new-style prototypes.</description>
    </rule>
    <rule key="104">
        <name>L0104: Conflicting types</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two consecutive conflicting types were found such as int followed by double. Remove one of the types!</description>
    </rule>
    <rule key="105">
        <name>L0105: Conflicting modifiers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two consecutive conflicting modifiers were found such as far followed by near. Remove one of the modifiers!</description>
    </rule>
    <rule key="106">
        <name>L0106: Illegal constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A string constant was found within a preprocessor expression as in
    #if ABC == &quot;abc&quot;
    Such expressions should be integral expressions.</description>
    </rule>
    <rule key="107">
        <name>L0107: Label &apos;Symbol&apos; (Location) not defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The Symbol at the given Location appeared in a goto but there was no corresponding label.</description>
    </rule>
    <rule key="108">
        <name>L0108: Invalid context</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A continue or break statement was encountered without an appropriate surrounding context such as a for, while, or do loop or, for the break statement only, a surrounding switch statement.</description>
    </rule>
    <rule key="109">
        <name>L0109: The combination &apos;short long&apos; is not standard, &apos;long&apos; is assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some compilers support the non-standard sequence short long. This message reports, as an error, that this sequence is being used. If you are required to use the construct then simply suppress this message. As the message indicates, that type will be presumed to be long.</description>
    </rule>
    <rule key="110">
        <name>L0110: Attempt to assign to void</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to assign a value to an object designated (possibly through a pointer) as void.</description>
    </rule>
    <rule key="111">
        <name>L0111: Assignment to const object</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An object declared as const was assigned a value. This could arise via indirection. For example, if p is a pointer to a const int then assigning to *p will raise this error.</description>
    </rule>
    <rule key="113">
        <name>L0113: Inconsistent enum declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The sequence of members within an enum (or their values) is inconsistent with that of another enum (usually in some other module) having the same name.</description>
    </rule>
    <rule key="114">
        <name>L0114: Inconsistent structure declaration for tag &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The sequence of members within a structure (or union) is inconsistent with another structure (usually in some other module) having the same name.</description>
    </rule>
    <rule key="115">
        <name>L0115: Struct/union not defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A reference to a structure or a union was made that required a definition and there is no definition in scope. For example, a reference to p-&gt;a where p is a pointer to a struct that had not yet been defined in the current module.</description>
    </rule>
    <rule key="116">
        <name>L0116: Inappropriate storage class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A storage class other than register was given in a section of code that is dedicated to declaring parameters. The section is that part of a function preceding the first left brace.</description>
    </rule>
    <rule key="117">
        <name>L0117: Inappropriate storage class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A storage class was provided outside any function that indicated either auto or register. Such storage classes are appropriate only within functions.</description>
    </rule>
    <rule key="118">
        <name>L0118: Too few arguments for prototype</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The number of arguments provided for a function was less than the number indicated by a prototype in scope.</description>
    </rule>
    <rule key="119">
        <name>L0119: Too many arguments for prototype</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The number of arguments provided for a function was greater than the number indicated by a prototype in scope.</description>
    </rule>
    <rule key="120">
        <name>L0120: Initialization without braces of dataless type &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There was an attempt to initialize a nested object (e.g., an array element) without braces. Additionally, that object type possesses no data members. class A { public: void f(); }; class B { public: A a; int k; } ; A a[4] = { {}, {}, {}, {} }; // OK B b = { , 34 }; // Error 120</description>
    </rule>
    <rule key="121">
        <name>L0121: Attempting to initialize an object of undefined type &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The initialization of an object was attempted where that object type has no visible definition. For example: class Undefined u = { 5 };</description>
    </rule>
    <rule key="122">
        <name>L0122: Digit (Char) too large for radix</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated character was found in a constant beginning with zero. For example, 08 is accepted by some compilers to represent 8 but it should be 010 or plain 8.</description>
    </rule>
    <rule key="123">
        <name>L0123: Macro &apos;Symbol&apos; defined with arguments at Location this is just a warning</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The name of a macro defined with arguments was subsequently used without a following &apos;(&apos;. This is legal but may be an oversight. It is not uncommon to suppress this message (with -e123), because some compilers allow, for example, the macro max() to coexist with a variable max.</description>
    </rule>
    <rule key="124">
        <name>L0124: Pointer to void not allowed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer to void was used in a context that does not permit void. This includes subtraction, addition and the relationals (&gt; &gt;= &lt; &lt;=).</description>
    </rule>
    <rule key="125">
        <name>L0125: Too many storage class specifiers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>More than one storage class specifier (static, extern, typedef, register or auto) was found. Only one is permitted.</description>
    </rule>
    <rule key="126">
        <name>L0126: Inconsistent structure definition &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named structure (or union or enum) was inconsistently defined across modules. The inconsistency was recognized while processing a lint object module. Line number information was not available with this message. Alter the structures so that the member information is consistent.</description>
    </rule>
    <rule key="127">
        <name>L0127: L0110: Illegal constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An empty character constant (&apos;&apos;) was found.</description>
    </rule>
    <rule key="128">
        <name>L0128: Pointer to function not allowed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer to a function was found in an arithmetic context such as subtraction, addition, or one of the relationals (&gt; &gt;= &lt; &lt;=).</description>
    </rule>
    <rule key="129">
        <name>L0129: declaration expected, identifier &apos;Symbol&apos; ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a context in which a declaration was expected an identifier was found. Moreover, the identifier was not followed by &apos;(&apos; or a &apos;[&apos;</description>
    </rule>
    <rule key="130">
        <name>L0130: Expected integral type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The expression in a switch statement must be some variation of an int (possibly long or unsigned) or an enum.</description>
    </rule>
    <rule key="131">
        <name>L0131: syntax error in call of macro &apos;Symbol&apos; at location Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when a macro with arguments (function-like macro) is invoked and an incorrect number of arguments is provided. Location is the location of the start of the macro call. This can be useful because an errant macro call can extend over many lines.</description>
    </rule>
    <rule key="132">
        <name>L0132: Expected function definition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declaration with identifiers between parentheses is the start of an old-style function definition (K&amp;R style). This is normally followed by optional declarations and a left brace to signal the start of the function body. Either replace the identifier(s) with type(s) or complete the function with a function body.</description>
    </rule>
    <rule key="133">
        <name>L0133: Too many initializers for aggregate &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a brace-enclosed initializer, there are more items than there are elements of the aggregate.</description>
    </rule>
    <rule key="134">
        <name>L0134: Missing initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer was expected but only a comma was present.</description>
    </rule>
    <rule key="135">
        <name>L0135: comma assumed in initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A comma was missing between two initializers. For example: int a[2][2] = { { 1, 2 } { 3, 4 } }; is missing a comma after the first right brace (}).</description>
    </rule>
    <rule key="136">
        <name>L0136: Illegal macro name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The ANSI standard restricts the use of certain names as macros. defined is on the restricted list.</description>
    </rule>
    <rule key="137">
        <name>L0137: constant &apos;Symbol&apos; used twice within switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated constant was used twice as a case within a switch statement. Currently only enumerated types are checked for repeated occurrence.</description>
    </rule>
    <rule key="138">
        <name>L0138: Can&apos;t add parent &apos;Symbol&apos; to strong type String; creates loop</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to add a strong type parent to a typedef type. The attempt is either explicit (with the -strong option) or implicit with the use of a typedef to a known strong type. This attempt would have caused a loop in the strong parent relationship. Such loops are simply not tolerated.</description>
    </rule>
    <rule key="139">
        <name>L0139: Can&apos;t take sizeof function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is an attempt to take the sizeof a function.</description>
    </rule>
    <rule key="140">
        <name>L0140: Type appears after modifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Microsoft modifiers such as far, _near, __huge, _pascal, etc. etc. modify the declarator to its immediate right. It therefore should not appear before the type. For example, you should write int pascal f(void); rather than pascal int f(void);. Note that const and volatile differ from the Microsoft modifiers. They may appear before or after the type. After reporting the error an attempt is made to process the modifiers as the programmer probably intended.</description>
    </rule>
    <rule key="141">
        <name>L0141: The following option has too many elements: &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated option (given by &apos;String&apos;) is too big. It most likely consists of an itemized list that has too many items. You should decompose the large option into two or more smaller options that in sum are equivalent to the one large option.</description>
    </rule>
    <rule key="142">
        <name>L0142: case constant &apos;0&apos; used previously in this switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>case constant &apos;0&apos; used previously in this switch</description>
    </rule>
    <rule key="143">
        <name>L0143: Erroneous option: String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An option contained information that was inconsistent with itself or with an earlier option. The String provided in the message explains more fully what the problem is.</description>
    </rule>
    <rule key="144">
        <name>L0144: Non-existent return value for symbol &apos;Symbol&apos;, compare with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to use a non-existent return value of the named function (identified by Symbol). It was previously decided that the function did not return a value or was declared with void.</description>
    </rule>
    <rule key="145">
        <name>L0145: Type expected before operator, void assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a context in which a type is expected no type is found. Rather, an operator &apos;*&apos; or &apos;&amp;&apos; was encountered. The keyword void was assumed to have preceded this operator.</description>
    </rule>
    <rule key="146">
        <name>L0146: Assuming a binary constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constant of the form 0b... was encountered. This was taken to be a binary constant. For example, 0b100 represents the value 4. If your compiler supports binary constants you may suppress this message.</description>
    </rule>
    <rule key="147">
        <name>L0147: sizeof takes just one argument</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression of the form sizeof(a,b) was detected. A second argument is non standard and has been used by some compilers to denote an option to the sizeof operator. If your compiler has a use for the second argument then suppress this message.</description>
    </rule>
    <rule key="148">
        <name>L0148: member &apos;Symbol&apos; previously declared at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member was previously declared within the same structure or union. Although a redeclaration of a function may appear benign it is just not permitted by the rules of the language. One of the declarations should be removed.</description>
    </rule>
    <rule key="149">
        <name>L0149: C++ construct &apos;String&apos; found in C code</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An illegal construct was found in C code. It looked as though it might be suitable for C++. The quoted string identifies the construct further.</description>
    </rule>
    <rule key="150">
        <name>L0150: Token &apos;String&apos; unexpected String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An unexpected token was encountered. The action taken, if any, is identified by the second message parameter.</description>
    </rule>
    <rule key="151">
        <name>L0151: Token &apos;Name&apos; inconsistent with abstract type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a context in which an abstract type is allowed such as within a cast or after a sizeof, and after starting to parse the abstract type, an identifier was found. For example:
    x = (int y) z;</description>
    </rule>
    <rule key="152">
        <name>L0152: Lob base file &apos;file name&apos; missing</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated file has been specified as the base of lob production via the option -lobbase(). On output, this message is given if the lob base is missing. The situation is correctable by simply producing the missing lob output. This will not be a problem given the appropriate dependencies in the make file. On input, the most likely cause of this message is an out-of-date base file. A hash code within the lob file being read, did not match a similar code already embedded within the base. The input lob file should be considered in error and should be regenerated.</description>
    </rule>
    <rule key="153">
        <name>L0153: Could not create temporary file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is produced when generating a lob output file based upon some lob base file. When the lob file is produced, it is first written to a temporary. The temporary is generated by the C library function tmpnam().</description>
    </rule>
    <rule key="154">
        <name>L0154: Could not evaluate type &apos;String&apos;, int assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>String in the message is the second argument to either a printf_code option or a scanf_code option. When used, it was to be evaluated as a type. Unfortunately the type could not be identified.</description>
    </rule>
    <rule key="155">
        <name>L0155: Ignoring { }&apos;ed sequence within an expression, 0 assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some compilers support what looks like a compound statement as a C/C++ expression. For example to define the absolute value of an integer which guarantees that it will be read only once you may use: #define abs(a) { int b = a; b &gt;= 0 ? b : -b; } The last expression in the list is the result. To syntactically support the construct without running amuck we recognize the sequence and issue this message. If you want to use the facility just suppress the message.</description>
    </rule>
    <rule key="156">
        <name>L0156: Braced initializer for scalar type &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An example of an initializer that will draw this complaint is as follows. int s[] = { { 1 } }; After the compiler has seen the first curly it is expecting to see a number (or other numeric expression). Compilers that strictly adhere to the ISO C and C++ Standards will flag this as ill-formed code.
    Note that it is legal (but somewhat arcane) to employ a left curly at the top-level when initializing an object of scalar type. For example, the following is well-formed: int i = { 0 }; // OK; initialize scalar i with 0. char *t = { &quot;bar&quot; }; // OK; initialize scalar t with a pointer to // a statically allocated array. Also note: as the example above implies, this message can apply to pointers to arrays of char; it does not apply to arrays.</description>
    </rule>
    <rule key="157">
        <name>L0157: No data may follow an incomplete array</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An incomplete array is allowed within a struct of a C99 or C++ program but no data is allowed to appear after this array. For example: struct A { int x; int a[]; int b; }; This diagnostic is issued when the &apos;b&apos; is seen.</description>
    </rule>
    <rule key="158">
        <name>L0158: Assignment to variable &apos;Symbol&apos; (Location) increases capability</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment has been made to a variable that increases capability. A typical capability increase is to remove const protection as in the following example: int *p; const int *q; p = q; // Error 158 If a capability increase is seen in situations other than an assignment or if the variable is not available, Warning 605 is issued. Please see the description of that message for further information concerning capability increase. See also Informational messages 1776 and 1778 in Section 13.8 C++ Informational Messages.</description>
    </rule>
    <rule key="159">
        <name>L0159: enum following a type is non-standard</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Normally two different types are not permitted within the same type specification; this will ordinarily result in Error 104. However, some compilers support &apos;sized&apos; enumerations wherein a scalar type can precede the enum keyword. E.g. char enum color { red, green, blue }; When the second type is an enum we do not issue a 104 but emit Error 159 instead. By suppressing this message (with -e159) such constructs will be supported.</description>
    </rule>
    <rule key="160">
        <name>L0160: The sequence &apos;( {&apos; is non standard and is taken to introduce a GNU statement expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Lint encountered the sequence &apos;( {&apos; in a context where an expression (possibly a sub-expression) is expected. int n = ({ // Error 160 here int y = foo (); int z; if (y &gt; 0) z = y; else z = - y; z; }) // Now n has the last value of z. The primary intention of this message is to alert the user to the non-standard nature of this construct. The typical response is to suppress the message and go on. But a few caveats are in order.
    Programmers who intend to work only with C code with the GNU extensions may safely disable this diagnostic but C++ users should think twice. This is partly for the reasons given in GCC&apos;s documentation (see the section entitled &quot;Statements and Declarations in Expressions&quot;) and partly because the meaning of &apos;( {&apos; will change in G++ when its maintainers implement Initializer Lists (a new core language feature that is expected to appear in the 2010 version of the ISO C++ Standard).</description>
    </rule>
    <rule key="161">
        <name>L0161: Repeated use of parameter &apos;Symbol&apos; in parameter list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The name of a function parameter was repeated. For example: void f( int n, int m, int n ) {} will cause this message to be issued. Names of parameters for a given function must all be different.</description>
    </rule>
    <rule key="165">
        <name>L0165: An [unscoped] emuration cannot be forward-declared (int is assumed)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An [unscoped] enumeration cannot be forward-declared [without an
       enum-base] (int is assumed) -- This message is issued at the
       point of a forward-declaration of an enumeration like so:
     
               enum E; // Error
     
       This is prohibited by ISO C and ISO C++98.  In C++0x, we can
       modify this example to be well-formed by explicitly indicating
       the underlying integral type; example:
     
               enum E : unsigned short; // Ok
     
       If you are not using C++0x and/or your compiler supports the
       construct you may simply suppress this message with a -e165.</description>
    </rule>
    <rule key="166">
        <name>L0166: Function defined within a function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function definition was found within the body of another function&apos;s definition. Such a construct is almost certainly an error.</description>
    </rule>
    <rule key="170">
        <name>L0170: Explicit type-specifier required for symbol &apos;Symbol&apos;, int assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration did not have an explicit type as required by C99
       or C++.  int was assumed.  This could easily happen if an
       intended comma was replaced by a semicolon.  For example, if
       instead of typing:
     
           double       radius,
                        diameter;
     
       the programmer had typed:
     
           double       radius;
                        diameter;</description>
    </rule>
    <rule key="171">
        <name>L0171: Ellipsis requires at least one parameter-declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declaration was seen with &apos;...&apos; but no parameter-declaration before it, as required by the ISO C syntax.
       This diagnostic is not given for C++ code.</description>
    </rule>
    <rule key="200">
        <name>L0200: Internal Error, subcode=xxxx</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Internal error occured - subcode is part of message. This inconsistency should be brought to the attention of Gimpel Software</description>
    </rule>
    <rule key="301">
        <name>L0301: Stack overflow</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There was a stack overflow while processing declarations. Approximately 50 nested declarators were found. For example, if a &apos;/&apos; followed by 50 consecutive &apos;*&apos;s were to introduce a box-like comment and if the &apos;/&apos; were omitted, then this message would be produced.</description>
    </rule>
    <rule key="302">
        <name>L0302: Exceeded Available Memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Main memory has been exhausted.</description>
    </rule>
    <rule key="303">
        <name>L0303: String too long (try +macros)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A single #define definition or macro invocation exceeded an internal limit (of 4096 characters). As the diagnostic indicates the problem can be corrected with an option.</description>
    </rule>
    <rule key="304">
        <name>L0304: Corrupt object file, code Integer, symbol=String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A PC-lint/FlexeLint object file is apparently corrupted. Please delete the object module and recreate it using the -oo option. The special code identifier number as well as a list of symbol names are optionally suffixed to the message as an aid in diagnosing the problem by technical support.</description>
    </rule>
    <rule key="305">
        <name>L0305: Unable to open module &apos;file name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>file name is the name of the file. The named module could not be opened for reading. Perhaps you misspelled the name.</description>
    </rule>
    <rule key="306">
        <name>L0306: Previously encountered module &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>FileName is the name of the module. The named module was previously encountered. This is probably a user blunder.</description>
    </rule>
    <rule key="307">
        <name>L0307: Can&apos;t open indirect file &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>FileName is the name of the indirect file. The named indirect file (ending in .lnt) could not be opened for reading.</description>
    </rule>
    <rule key="308">
        <name>L0308: Can&apos;t write to standard out</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>stdout was found to equal NULL. This is most unusual.</description>
    </rule>
    <rule key="309">
        <name>L0309: #error ...</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The #error directive was encountered. The ellipsis reflects the original line. Normally processing is terminated at this point. If you set the fce (continue on #error) flag, processing will continue.</description>
    </rule>
    <rule key="310">
        <name>L0310: Declaration too long: &apos;String...&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A single declaration was found to be too long for an internal buffer (about 2000 characters). This occurred when attempting to write out the declaration using the -o... option. The first 30 characters of the declaration is given in String. Typically this is caused by a very long struct whose substructures, if any, are untagged. First identify the declaration that is causing the difficulty. If a struct or union, assign a tag to any unnamed substructures or subunion. A typedef can also be used to reduce the size of such a declaration.</description>
    </rule>
    <rule key="312">
        <name>L0312: Lint Object Module has obsolete or foreign version id: Integer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A lint object module was produced with a prior or different version of PC-lint/FlexeLint. Delete the.lob file and recreate it using your new version of PC-lint/FlexeLint.</description>
    </rule>
    <rule key="313">
        <name>L0313: Too many files</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The number of files that PC-lint/FlexeLint can process has exceeded an internal limit. The FlexeLint user may recompile his system to increase this limit. Look for symbol FSETLEN in custom.h. Currently, the number of files is limited to 4096.</description>
    </rule>
    <rule key="314">
        <name>L0314: Previously used .lnt file: FileName</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indirect file named was previously encountered. If this was not an accident, you may suppress this message.</description>
    </rule>
    <rule key="315">
        <name>L0315: Exceeded message limit (see -limit)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The maximum number of messages was exceeded. Normally there is no limit unless one is imposed by the -limit(n) option.</description>
    </rule>
    <rule key="316">
        <name>L0316: Error while writing to file &quot;file name&quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given file could not be opened for output.</description>
    </rule>
    <rule key="317">
        <name>L0317:File encoding, String, not currently supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Lint detected a byte order mark at the beginning of a file which indicated the file is encoded in the given format. As of this writing, the only formats supported to any extent are ASCII and UTF-8 (for which Lint presumes ASCII encoding).</description>
    </rule>
    <rule key="321">
        <name>L0321: Declaration stack overflow</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An overflow occurred in the stack used to contain array, pointer, function or reference modifiers when processing a declarator.</description>
    </rule>
    <rule key="322">
        <name>L0322: Unable to open include file FileName</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>FileName is the name of the include file which could not be opened. Directory search is controlled by options: -i +fdi and the INCLUDE environment variable. This is a suppressible fatal message. If option -e322 is used, Error message 7 will kick in. A diagnostic will be issued but processing will continue.</description>
    </rule>
    <rule key="323">
        <name>L0323: Token String too long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In attempting to save a token for later reuse, a fixed size buffer was exceeded (governed by the size M_TOKEN).</description>
    </rule>
    <rule key="324">
        <name>L0324: Too many symbols Integer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Too many symbols were encountered. An internal limit was reached.</description>
    </rule>
    <rule key="325">
        <name>L0325: Cannot re-open file &apos;file name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In the case of a large number of nested includes, files in the outer fringe need to be closed before new ones are opened. These outer files then need to be re-opened. An error occurred when attempting to re-open such a file.</description>
    </rule>
    <rule key="326">
        <name>L0326: String &apos;String ...&apos; too long, exceeds Integer characters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A string (first 40 characters provided in the message) exceeds some internal limit (provided in the message). There is no antidote to this condition in the form of an option. FlexeLint customers may recompile with a redefinition of either M_STRING (maximum string) or M_NAME (maximum name). To override the definition in custom.h we suggest recompiling with an appropriate -dvar=value option assuming your compiler supports the option.</description>
    </rule>
    <rule key="328">
        <name>L0328: Bypass header &apos;Name&apos; follows a different header sequence than in module &apos;String&apos; which includes File1 where the current module includes File2</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when a header is #include&apos;d that had previously been designated as bypass and it has been determined that this header follows a different header include sequence than in some other module. The name of the other module is given by the second parameter of this message. In order not to bury the programmer under a ton of header names, we have made an effort to determine the precise point where the two modules went their separate ways. The first include file difference occurred when that other module included the header identified by File1, whereas the current module was attempting to include the header identified by File2. Each Filei is a pair of parameters of the form &apos;String&apos; (Location) where the location is the point of the #include.
    For example: Module x.cpp: #include &quot;alpha.h&quot; #include &quot;delta.h&quot; #include &quot;beta.h&quot; #include &quot;gamma.h&quot;
    Module y.cpp: #include &quot;alpha.h&quot; #include &quot;beta.h&quot; #include &quot;gamma.h&quot; When the include of &quot;beta.h&quot; occurs in module y.cpp (and if beta.h has been designated as bypass), there will be a Fatal Error 328 that the header sequence of module &apos;x.cpp&apos; differs from the current module in that the former module included &apos;delta.h&apos; at a point where the current module included &apos;beta.h&apos;.
    It was necessary to make this message a fatal error since attempting to bypass headers that do not follow a consistent header sequence is an act of folly. It is possible to continue on after the 328 in hopes of picking up more inconsistencies in other modules. This can be done using the +fce (Continue-on-Error) flag.</description>
    </rule>
    <rule key="333">
        <name>L0333: Not allowed to open file &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;forbidden&apos; file was opened. Opening such a file is considered a security violation by a hosted implementation.</description>
    </rule>
    <rule key="401">
        <name>L0401: symbol &apos;Symbol&apos; not previously declared static at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated Symbol declared static was previously declared without the static storage class. This is technically a violation of the ANSI standard. Some compilers will accept this situation without complaint and regard the Symbol as static.</description>
    </rule>
    <rule key="402">
        <name>L0402: static function &apos;Symbol&apos; (Location) not defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named Symbol was declared as a static function in the current module and was referenced but was not defined (in the module).</description>
    </rule>
    <rule key="403">
        <name>L0403: static symbol &apos;Symbol&apos; has unusual type modifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some type modifiers such as _export are inconsistent with the static storage class.</description>
    </rule>
    <rule key="404">
        <name>L0404: struct not completed within file &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A struct (or union or enum) definition was started within a header file but was not completed within the same header file.</description>
    </rule>
    <rule key="405">
        <name>L0405: #if not closed off within file &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An #if construct was begun within a header file (name given) but was not completed within that header file. Was this intentional?</description>
    </rule>
    <rule key="406">
        <name>L0406: Comment not closed off within file &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A comment was begun within a header file (name given) but was not completed within that header file. Was this intentional?</description>
    </rule>
    <rule key="407">
        <name>L0407: Inconsistent use of tag &apos;Symbol&apos; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A tag specified as a union, struct or enum was respecified as being one of the other two in the same module. For example: struct tag *p; union tag *q;
    will elicit this message.</description>
    </rule>
    <rule key="408">
        <name>L0408: Type mismatch with switch expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The expression within a case does not agree exactly with the type within the switch expression. For example, an enumerated type is matched against an int.</description>
    </rule>
    <rule key="409">
        <name>L0409: Expecting a pointer or array</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression of the form i[...] was encountered where i is an integral expression. This could be legitimate depending on the subscript operand. For example, if i is an int and a is an array then i[a] is legitimate but unusual. If this is your coding style, suppress this message.</description>
    </rule>
    <rule key="410">
        <name>L0410: size_t not what was expected from fzl and/or fzu, using &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is issued if you had previously attempted to set the type of sizeof by use of the options +fzl, -fzl, or -fzu, and a later size_t declaration contradicts the setting. This usually means you are attempting to lint programs for another system using header files for your own system. If this is the case we suggest you create a directory housing header files for that foreign system, alter size_t within that directory, and lint using that directory.</description>
    </rule>
    <rule key="411">
        <name>L0411: ptrdiff_t not what was expected from fdl option, using &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is issued if you had previously attempted to set the type of pointer differences by use of the fdl option and a later ptrdiff_t declaration contradicts the setting. See suggestion in Error Message 410.</description>
    </rule>
    <rule key="412">
        <name>L0412: Ambiguous format specifier &apos;%X&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The format specifier %X when used with one of the scanf family, is ambiguous. With Microsoft C it means %lx whereas in ANSI C it has the meaning of %x. This ambiguous format specification has no place in any serious C program and should be replaced by one of the above.</description>
    </rule>
    <rule key="413">
        <name>L0413: Likely use of null pointer &apos;Symbol&apos; in [left/right] argument to operator &apos;String&apos; Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>From information gleaned from earlier statements, it appears certain that a null pointer (a pointer whose value is 0) has been used in a context where null pointers are inappropriate. These include: Unary *, pointer increment (++) or decrement, addition of pointer to numeric, and subtraction of two pointers. In the case of binary operators, one of the words &apos;left&apos; or &apos;right&apos; is used to designate which operand is null. Symbol identifies the pointer variable that may be null.</description>
    </rule>
    <rule key="414">
        <name>L0414: Possible division by 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The second argument to either the division operator (/) or the modulus operator (%) may be zero. Information is taken from earlier statements including assignments, initialization and tests.</description>
    </rule>
    <rule key="415">
        <name>L0415: access of out-of-bounds pointer (&apos;Integer&apos; beyond end of data) by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An out-of-bounds pointer was accessed. String designates the operator. The parameter &apos;Integer&apos; gives some idea how far out of bounds the pointer may be. It is measured in units given by the size of the pointed to object. The value is relative to the last item of good data and therefore should always be greater than zero. For example: int a[10]; a[10] = 0;
    results in an overflow message containing the phrase &apos;1 beyond end of data&apos;.</description>
    </rule>
    <rule key="416">
        <name>L0416: creation of out-of-bounds pointer (&apos;Integer&apos; beyond end of data) by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An out-of-bounds pointer was created. See message 415 for a description of the parameters Integer and String. For example: int a[10];
    ... f( a + 11 );
    Here, an illicit pointer value is created and is flagged as such by PC-lint/FlexeLint. Note that the pointer a+10 is not considered by PC-lint/FlexeLint to be the creation of an out-of-bounds pointer. This is because ANSI C explicitly allows pointing just beyond an array. Access through a+10, however, as in *(a+10) or the more familiar a[10], would be considered erroneous but in that case message 415 would be issued.</description>
    </rule>
    <rule key="417">
        <name>L0417: integral constant &apos;String&apos; has precision Number which is longer than long long int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The longest possible integer is by default 8 bytes (see the +fll flag and then the -sll# option). An integral constant was found to be even larger than such a quantity. For example: 0xFFFF0000FFFF0000F. String is the token in error.</description>
    </rule>
    <rule key="418">
        <name>L0418: Passing null pointer to function &apos;Symbol&apos;, Context Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A NULL pointer is being passed to a function identified by Symbol. The argument in question is given by Context. The function is either a library function designed not to receive a NULL pointer or a user function dubbed so via the option -function.</description>
    </rule>
    <rule key="419">
        <name>L0419: Apparent data overrun for function &apos;Symbol&apos;, argument Integer exceeds argument Integer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is for data transfer functions such as memcpy, strcpy, fgets, etc. when the size indicated by the first cited argument (or arguments) exceeds the size of the buffer area cited by the second. The message may also be issued for user functions via the -function option.</description>
    </rule>
    <rule key="420">
        <name>L0420: Apparent access beyond array for function &apos;Symbol&apos;, argument Integer exceeds Integer Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for several library functions (such as fwrite, memcmp, etc.) wherein there is an apparent attempt to access more data than exist. For example, if the length of data specified in the fwrite call exceeds the size of the data specified. The function is specified by Symbol and the arguments are identified by argument number.</description>
    </rule>
    <rule key="421">
        <name>L0421: Caution -- function &apos;Symbol&apos; is considered dangerous</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued (by default) for the built-in function gets. This function is considered dangerous because there is no mechanism to ensure that the buffer provided as first argument will not overflow. A well known computer virus (technically a worm) was created based on this defect. Through the -function option, the user may designate other functions as dangerous.</description>
    </rule>
    <rule key="422">
        <name>L0422: Passing to function &apos;Symbol&apos; a negative value (Integer), Context Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integral value that appears to be negative is being passed to a function that is expecting only positive values for a particular argument. The message contains the name of the function (Symbol), the questionable value (Integer) and the argument number (Context). The function may be a standard library function designed to accept only positive values such as malloc or memcpy (third argument), or may have been identified by the user as such through the -function or -sem options.
    The negative integral value may in fact be unsigned. Thus: void *malloc( unsigned ); void f() { int n = -1; int *p; p = malloc(n); // Warning 422 p = malloc( (unsigned) n ); // Warning 422 }
    will result in the warnings indicated. Note that casting the expression does not inhibit the warning.
    There is a slight difference in behavior on 32-bit systems versus 16-bit systems. If long is the same size as int (as in 32-bit systems) the warning is issued based upon the sign bit. If long is larger than an int (as is true on typical 16-bit systems) the warning is issued if the value was a converted negative as in the examples above. It is not issued if an unsigned int has the high-order bit set. This is because it is not unreasonable to malloc more that 32,176 bytes in a 16-bit system.</description>
    </rule>
    <rule key="423">
        <name>L0423: Creation of memory leak in assignment to variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment was made to a pointer variable (designated by Symbol) which appeared to already be holding the address of an allocated object which had not been freed. The allocation of memory which is not freed is considered a memory leak.</description>
    </rule>
    <rule key="424">
        <name>L0424: Inappropriate deallocation (Name1) for &apos;Name2&apos; data.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message indicates that a deallocation (free(), delete, or delete[]) as specified by String1 is inappropriate for the data being freed. [12, Item 5]
    The kind of data (specified by String2) is one or more of: malloc, new, new[], static, auto, member, modified or constant. These have the meanings as described below:
    malloc data is data obtained from a call to malloc, calloc or realloc. new and new[] data is data derived from calls to new. static data is either static data within a function or external data. auto data is non-static data in a function. member data is a component of a structure (and hence can&apos;t be independently freed). modified data is the result of applying pointer arithmetic to some other pointer. E.g. p = malloc(100); free( p+1 ); // warning
    p+1 is considered modified. constant data is the result of casting a constant to a pointer. E.g. int *p = (int *) Ox80002; free(p); // warning</description>
    </rule>
    <rule key="425">
        <name>L0425: &apos;Message&apos; in processing semantic &apos;String&apos; at token &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is issued when a syntax error is encountered while processing a Semantic option (-sem). The &apos;Message&apos; depends upon the error. The first &apos;String&apos; represents the portion of the semantic being processed. The second &apos;String&apos; denotes the token being scanned when the error is first noticed.</description>
    </rule>
    <rule key="426">
        <name>L0426: Call to function &apos;Symbol&apos; violates semantic &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This Warning message is issued when a user semantic (as defined by -sem) is violated. &apos;String&apos; is the subportion of the semantic that was violated. For example: //lint -sem( f, 1n &gt; 10 &amp;&amp; 2n &gt; 10 ) void f( int, int ); ... f( 2, 20 );
    results in the message:
    Call to function &apos;f(int, int)&apos; violates semantic &apos;(1n&gt;10)&apos;</description>
    </rule>
    <rule key="427">
        <name>L0427: // comment terminates in \</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A one-line comment terminates in the back-slash escape sequence. This means that the next line will be absorbed in the comment (by a standards-conforming compiler -- not all compilers do the absorption, so beware). It is much safer to end the line with something other than a back-slash. Simply tacking on a period will do. If you really intend the next line to be a comment, the line should be started with its own double slash (//).</description>
    </rule>
    <rule key="428">
        <name>L0428: negative subscript (Integer) in operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A negative integer was added to an array or to a pointer to an allocated area (allocated by malloc, operator new, etc.) This message is not given for pointers whose origin is unknown since a negative subscript is, in general, legal.
    The addition could have occurred as part of a subscript operation or as part of a pointer arithmetic operation. The operator is denoted by String. The value of the integer is given by Integer.</description>
    </rule>
    <rule key="429">
        <name>L0429: Custodial pointer &apos;Symbol&apos; (Location) has not been freed or returned</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer of auto storage class was allocated storage which was neither freed nor returned to the caller. This represents a &quot;memory leak&quot;. A pointer is considered custodial if it uniquely points to the storage area. It is not considered custodial if it has been copied. Thus: int *p = new int[20]; // p is a custodial pointer int *q = p; // p is no longer custodial p = new int[20]; // p again becomes custodial q = p + 0; // p remains custodial
    Here p does not lose its custodial property by merely participating in an arithmetic operation.
    A pointer can lose its custodial property by passing the pointer to a function. If the parameter of the function is typed pointer to const or if the function is a library function, that assumption is not made. For example p = malloc(10); strcpy (p, &quot;hello&quot;);
    Then p still has custody of storage allocated.
    It is possible to indicate via semantic options that a function will take custody of a pointer.</description>
    </rule>
    <rule key="430">
        <name>L0430: Character &apos;@&apos;, taken to specify variable location, is not standard C/C++</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Many compilers for embedded systems have a declaration syntax that specifies a location in place of an initial value for a variable. For example: int x @0x2000;
    specifies that variable x is actually location 0x2000. This message is a reminder that this syntax is non-standard (although quite common). If you are using this syntax on purpose, suppress this message.</description>
    </rule>
    <rule key="431">
        <name>L0431: Missing identifier for template parameter number Integer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A template object parameter (as opposed to a type parameter) was not provided with an identifier. Was this an oversight?</description>
    </rule>
    <rule key="432">
        <name>L0432: Suspicious argument to malloc</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The following pattern was detected:
    malloc( strlen(e+1) )
    where e is some expression. This is suspicious because it closely resembles the commonly used pattern:
    malloc( strlen(e)+1 )
    If you really intended to use the first pattern then an equivalent expression that will not raise this error is:
    malloc( strlen(e)-1 )</description>
    </rule>
    <rule key="433">
        <name>L0433: Allocated area not large enough for pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An allocation was assigned to a pointer whose reach extends beyond the area that was allocated. This would usually happen only with library allocation routines such as malloc and calloc. For example:
    int *p = malloc(1);
    This message is also provided for user-declared allocation functions. For example, if a user&apos;s own allocation function is provided with the following semantic:
    -sem(ouralloc,@P==malloc(1n))
    We would report the same message. Please note that it is necessary to designate that the returned area is freshly allocated (ala malloc).
    This message is always given in conjunction with the more general Informational Message 826.</description>
    </rule>
    <rule key="434">
        <name>L0434: White space ignored between back-slash and new-line</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>According to the C and C++ standards, any back-slash followed immediately by a new-line results in the deletion of both characters. For example: #define A \ 34
    defines A to be 34. If a blank or tab intervenes between the back-slash and the new-line then according to a strict interpretation of the standard you have defined A to be a back-slash. But this blank is invisible to the naked eye and hence could lead to confusion. Worse, some compilers silently ignore the white-space and the program becomes non-portable.
    You should never deliberately place a blank at the end of a line and any such blanks should be removed. If you really need to define a macro with a terminal back-slash you can use a comment as in: #define A \ /* commentary */</description>
    </rule>
    <rule key="435">
        <name>L0435: integral constant &apos;String&apos; has precision Integer, use +fll to enable long long&quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integer constant was found that had a precision that was too large for a long but would fit within a long long. Yet the +fll flag that enables the long long type was not set.
    Check the sizes that you specified for long (-sl#) and for long long (-sll#) and make sure they are correct. Turn on +fll if your compiler supports long long. Otherwise use smaller constants.</description>
    </rule>
    <rule key="436">
        <name>L0436: Apparent preprocessor directive in invocation of macro &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function like macro was invoked whose arguments extended for multiple lines which included preprocessor statements. This is almost certainly an error brought about by a missing right parenthesis.
    By the rules of Standard C the preprocessing directive is absorbed into the macro argument but then will not subsequently get executed. For this reason some compilers treat the apparent preprocessor directive as a directive. This is logical but not portable. It is therefore best to avoid this construct.</description>
    </rule>
    <rule key="437">
        <name>L0437: Passing struct &apos;Symbol&apos; to ellipsis</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A struct is being passed to a function at a parameter position identified by an ellipsis. For example: void g() { struct A { int a; } x; void f( int, ... ); f( 1, x ); ... } This is sufficiently unusual that it is worth pointing out on the likely hood that this is unintended. The situation becomes more severe in the case of a Non-POD struct [10]. In this case the behavior is considered undefined.</description>
    </rule>
    <rule key="438">
        <name>L0438: Last value assigned to variable &apos;Symbol&apos; not used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A value had been assigned to a variable that was not subsequently used. The message is issued either at a return statement or at the end of a block when the variable goes out of scope. For example, consider the following function: void f( int n ) { int x = 0, y = 1; if( n &gt; 0 ) { int z; z = x + y; if( n &gt; z ) { x = 3; return; } z = 12; } } Here we can report that x was assigned a value that had not been used by the time the return statement had been encountered. We also report that the most recently assigned value to z is unused at the point that z goes out of scope. See message 838 in Section 13.4 C Informational Messages and flags -fiw and -fiz in Sections 2.3.6 Initialization-is-considered-a-Write flag (-fiw) and 2.3.7 Initialization-by-Zero-is-considered-a-Write flag (-fiz) .
    This message is suppressed if the variable&apos;s address is assigned to a pointer (or, equivalently, the variable is used to directly initialize a reference to non-const).</description>
    </rule>
    <rule key="440">
        <name>L0440: for clause irregularity: variable &apos;Symbol&apos; tested in 2nd expression does not match &apos;Symbol&apos; modified in 3rd</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A for clause has a suspicious structure. The loop variable, as determined by an examination of the 3rd for clause expression, does not match the variable that is tested in the 2nd for clause expression. For example: for( i = 0; i &lt; 10; j++ ) ... would draw this complaint since the &apos;i&apos; of the 2nd expression does not match the &apos;j&apos; of the third expression.</description>
    </rule>
    <rule key="441">
        <name>L0441: for clause irregularity: loop variable &apos;Symbol&apos; not found in 2nd for expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The loop variable is determined by an examination of the 3rd for clause expression. A loop variable was found (and its name is given in the message) but it did not appear as one of the accessed symbols of the condition expression (the 2nd for expression). For example: for( p = a; *p; j++ ) ... would draw this complaint since the 2nd expression does not contain the &apos;j&apos; of the third expression.</description>
    </rule>
    <rule key="442">
        <name>L0442: for clause irregularity: testing direction inconsistent with increment direction</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A for clause was encountered that appeared to have a parity problem. For example: for( i = 0; i &lt; 10; i&lt;/name&gt;&lt;description&gt; ) ... Here the test for i less than 10 seems inconsistent with the 3rd expression of the for clause which decreases the value of i. This same message would be given if i were being increased by the 3rd expression and was being tested for being greater than some value in the 2nd expression.</description>
    </rule>
    <rule key="443">
        <name>L0443: for clause irregularity: variable &apos;Symbol&apos; initialized in 1st expression does not match &apos;Symbol&apos; modified in 3rd</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A for clause has a suspicious structure. The loop variable, as determined by an examination of the 3rd for clause expression, does not match the variable that is initialized in the 1st expression. For example: for( ii = 0; i &lt; 10; i++ ) ... would draw this complaint since the &apos;ii&apos; of the 1st expression does not match the &apos;i&apos; of the third expression.</description>
    </rule>
    <rule key="444">
        <name>L0444: for clause irregularity: pointer &apos;Symbol&apos; incremented in 3rd expression is tested for NULL in 2nd expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The following kind of situation has been detected: for( ... ; p == NULL; p++ ) ... A loop variable being incremented or decremented would not normally be checked to see if it is NULL. This is more likely a programmer error.</description>
    </rule>
    <rule key="445">
        <name>L0445: reuse of for loop variable &apos;Symbol&apos; at &apos;Location&apos; could cause chaos</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A for loop nested within another for loop employed the same loop variable. For example: for( i = 0; i &lt; 100; i++ ) { ... for( i = 0; i &lt; n; i++ ) { ... } }</description>
    </rule>
    <rule key="446">
        <name>L0446: side effect in initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer containing a side effect can be potentially troublesome. For example, given the code:

           void f( int i )
               {
               int a[2] = {i++, i++};
               }
               
       The values of the array elements are unspecified because the order of evaluation is unspecified by the C standard.</description>
    </rule>
    <rule key="447">
        <name>L0447: Extraneous whitespace ignored in include directive for file &apos;FileName&apos;; opening file &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A named file was found to contain either leading or trailing whitespace in the #include directive. While legal, the ISO Standards allow compilers to define how files are specified or the header is identified, including the appearance of whitespace characters immediately after the &lt; or opening &quot; or before the &gt; or closing &quot;. Since filenames tend not to contain leading or trailing whitespace, Lint ignores the (apparently) extraneous characters and processes the directive as though the characters were never given. The use of a -efile option on either String for this message will cause Lint to process #include&apos;s with whitespace intact.</description>
    </rule>
    <rule key="448">
        <name>L0448: Likely access of pointer pointing Integer bytes past nul character by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Accessing past the terminating nul character is often an indication of a programmer error. For example: char buf[20]; strcpy( buf, &quot;a&quot; ); char c = buf[4]; // legal but suspect. Although buf has 20 characters, after the strcpy, there would be only two that the programmer would normally be interested in.</description>
    </rule>
    <rule key="449">
        <name>L0449: Pointer variable &apos;Symbol&apos; previously deallocated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer variable (designated in the message) was freed or deleted in an earlier statement.</description>
    </rule>
    <rule key="451">
        <name>L0451: Header file &apos;FileName&apos; repeatedly included but does not have a standard include guard</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The file named in the message has already been included in the current module. Moreover it has been determined that this header does not have a standard include guard. A standard include guard has the form #ifndef Name #define Name ... #endif with nothing but comments before and after this sequence and nothing but comments between the #ifndef and the #define Name.
    This warning may also be accompanied by a 537 (repeated include header). Message 537 is often suppressed because if you are working with include guards, it is not a helpful message. However, the message 451 should be left on in order to check the consistency of the include guards themselves.
    See also Elective Note 967 in Section 13.5 C Elective Notes.</description>
    </rule>
    <rule key="452">
        <name>L0452: typedef Symbol &apos;Symbol&apos; redeclared (TypeDiff) conflicts with Location&quot;,</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A typedef symbol is being declared to be a different type. This can be legal, especially with multiple modules, but is not good programming practice. It inteferes with program legibility.</description>
    </rule>
    <rule key="453">
        <name>L0453: Function &apos;Symbol&apos;, previously designated pure, String &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A semantic option designated that the named function, Symbol, is pure (lacking non-local side-effects; see the pure semantic in Section 4. Semantics ). However, an impurity was detected. Such impurities include calling a function through a function pointer, accessing a volatile variable, modifying a static variable or calling a function whose purity PC-lint/FlexeLint cannot verify. String describes which of these reasons apply and Name shows the related variable or function, as appropriate.
    Despite the inconsistency reported, the function will continue to be regarded as pure.</description>
    </rule>
    <rule key="454">
        <name>L0454: A thread mutex has been locked but not unlocked</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A return point in a function has been reached such that a mutex lock that had been previously set has not been unlocked. E.g., //lint -sem( lock, thread_lock ) void f( int x ) { lock(); if( x &lt; 0 ) return; // Warning 454 ...</description>
    </rule>
    <rule key="455">
        <name>L0455: A thread mutex that had not been locked is being unlocked</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to an unlock() function was made that was not preceded by a balancing lock(). It is assumed that every mutex lock() function must be balanced by exactly one unlock() function, no more, no less. For example: //lint -sem( lock, thread_lock ) //lint -sem( unlock, thread_unlock ) void f( bool x ) { lock(); /* something */; unlock(); /* something else */ unlock(); // Warning 455 }</description>
    </rule>
    <rule key="456">
        <name>L0456: Two execution paths are being combined with different mutex lock states</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It is the purpose of this message to make absolutely certain that every lock has a corresponding unlock in the same unbroken sequence of code in the same function.
    Execution paths can be combined at the end of an if statement, switch statement, or the beginning of while, for and do statements, a label (target of goto), etc. In all these cases we check to make sure that the mutex lock states are the same. For example: //lint -sem( lock, thread_lock ) void f( bool x ) { if( x ) lock(); // Warning 456 issued here ... It could be argued that if an unlock() call would appear under control of the very same bool x in the example above then all would be well. And if this is your coding style you are free to turn this message off. But errors in mutex locking have such horrible programming consequences as to suggest especially strong measures to assure code correctness. We recommend, for example: //lint -sem( lock, thread_lock ) //lint -sem( unlock, thread_unlock ) void f( bool x ) { if( x ) { lock(); /* something */; unlock(); } else { /* something */ } } If the &apos;something&apos; that is being executed is sufficiently complex, then it can be made into a function.</description>
    </rule>
    <rule key="457">
        <name>L0457: Function &apos;Symbol1&apos; of thread &apos;Symbol2&apos; has an unprotected write access to variable &apos;Symbol3&apos; which is used by function &apos;Symbol4&apos; of thread &apos;Symbol5&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable (Symbol3) was modified by function (Symbol1) of thread (Symbol2) outside of any recognized mutex lock. It was also accessed by a function (Symbol4) of a second thread (Symbol5). The latter access may or may not have been protected. If unprotected, a second message will be issued with the roles of Symbol1 and Symbol4 interchanged.</description>
    </rule>
    <rule key="458">
        <name>L0458: Function &apos;Symbol1&apos; of thread &apos;Symbol2&apos; has an unprotected read access to variable &apos;Symbol3&apos; which is modified by function &apos;Symbol4&apos; of thread &apos;Symbol5&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable identified in the message was accessed (non-modifying) by a function (Symbol1) of thread (Symbol2) outside of any recognized mutex lock. It was also modified by a function (Symbol4) in a second thread (Symbol5). The modification may or may not have been protected. If unprotected, Warning 457 will also be issued.</description>
    </rule>
    <rule key="459">
        <name>L0459: Function &apos;Symbol&apos; whose address was taken has an unprotected access to variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is activated only when it appears that the program has more than one thread. See Section 8. Multi-thread Support to determine what those conditions might be.
    If a function&apos;s address is taken, we presume that we are unable to determine statically all the locations from which the function may be called and so we presume that any and all threads can call this function and so the function needs to have protected access to every static variable that it might touch.
    There are several remedies to such a message. If multiple threads can indeed access this function, then place a mutex lock in the function. If there already is a mutex lock and we don&apos;t recognize it, then set the thread_protected semantic for the function. If only one thread really accesses this function or if the access is guaranteed to be benign, then, after making sure this condition is commented in the code, use the same thread_protected semantic for the function.</description>
    </rule>
    <rule key="460">
        <name>L0460: Thread &apos;Symbol&apos; has unprotected call to thread unsafe function &apos;Symbol&apos; which is also called by thread &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The second symbol in the message represents a function that was designated as being thread_unsafe through the -sem option. It was being called in an unprotected region of a thread whose root function is the first symbol in the message. Another thread is also accessing this function and this thread is identified by the third parameter of the message.
    Calls to thread unsafe functions need to be protected by mutex locks if they are to be employed by more than one thread.</description>
    </rule>
    <rule key="461">
        <name>L0461: Thread &apos;Symbol&apos; has unprotected call to function &apos;Symbol&apos; of group &apos;Name&apos; while thread &apos;Symbol&apos; calls function &apos;Symbol&apos; of the same group</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is similar to Warning 460 in that a thread (identified in the message as the first Symbol) is making a call on a function (the second Symbol) which had been deduced (through options) as being thread unsafe. Like message 460 there is another thread that is also doing some calling. In this case the other thread is not calling the same function as the first but one which has been placed within the same group (identified by the third parameter) as the first function. See Section 8. Multi-thread Support to obtain further information on thread unsafe function groups and options to determine them.</description>
    </rule>
    <rule key="462">
        <name>L0462: Thread &apos;Symbol&apos; calling function &apos;Symbol&apos; is inconsistent with the &apos;String&apos; semantic</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first Symbol in the message identifies a thread. The second Symbol identifies a function called directly or indirectly by the thread. The String argument specifies a semantic that had been attributed to the function. It should have one of the following forms:
    thread_not thread_not( list ) thread_only( list )
    If the second form is given, it means that the thread appears on the list. If the 3rd form is given it means that the thread was not on the list.</description>
    </rule>
    <rule key="464">
        <name>L0464: Buffer argument will be copied into itself</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This is issued when we encounter a function argument expression used in such a way that there will be an attempt to copy its contents onto itself. E.g. sprintf( s, &quot;%s&quot;, s );</description>
    </rule>
    <rule key="483">
        <name>L0483: boolean value in switch expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>organization has expressed the perspective, if the expression of a switch-statement is boolean in nature, if-else should be used instead.</description>
    </rule>
    <rule key="484">
        <name>L0484: Stringize operator followed by macro parameter followed by pasting operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Due to order of evaluation issues, the mixing of stringizing and pasting operators, particularly when appearing in the order # parameter ##, results in unspecified behavior.</description>
    </rule>
    <rule key="485">
        <name>L0485: Duplicate initialization of object element</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is
       given upon an inconsistent use of designated initializers (used for specific fields of arrays or structures).  It is possible for an element of such an aggregate to be initialized twice either through the use of two separate designators or through a designator and the conventional sequential initialization process.
       In either case the end result is not specified and the construction is usually a sign of a logic error.</description>
    </rule>
    <rule key="501">
        <name>L0501: Expected signed type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The unary minus operator was applied to an unsigned type. The resulting value is a positive unsigned quantity and may not be what was intended.</description>
    </rule>
    <rule key="502">
        <name>L0502: Expected unsigned type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unary ~ being a bit operator would more logically be applied to unsigned quantities rather than signed quantities.</description>
    </rule>
    <rule key="503">
        <name>L0503: Boolean argument to relational</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Normally a relational would not have a Boolean as argument. An example of this is a &lt; b &lt; c which is technically legal but does not produce the same result as the mathematical expression which it resembles.</description>
    </rule>
    <rule key="504">
        <name>L0504: Unusual shift operation (String)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Either the quantity being shifted or the amount by which a quantity is to be shifted was derived in an unusual way such as with a bit-wise logical operator, a negation, or with an unparenthesized expression. If the shift value is a compound expression that is not parenthesized, parenthesize it.</description>
    </rule>
    <rule key="505">
        <name>L0505: Redundant left argument to comma</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The left argument to the comma operator had no side effects in its top-most operator and hence is redundant.</description>
    </rule>
    <rule key="506">
        <name>L0506: Constant value Boolean</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A Boolean, i.e., a quantity found in a context that requires a Boolean such as an argument to &amp;&amp; or || or an if() or while() clause or ! was found to be a constant and hence will evaluate the same way each time.</description>
    </rule>
    <rule key="507">
        <name>L0507: Size incompatibility</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast was made to an integral quantity from a pointer and according to other information given or implied it would not fit. For example a cast to an unsigned int was specified and information provided by the options indicate that a pointer is are larger than an int.</description>
    </rule>
    <rule key="508">
        <name>L0508: extern used with definition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function definition was accompanied with an extern storage class. extern is normally used with declarations rather than with definitions. At best the extern is redundant. At worst you may trip up a compiler.</description>
    </rule>
    <rule key="509">
        <name>L0509: extern used with definition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A data object was defined with a storage class of extern. This is technically legal in ANSI and you may want to suppress this message. However, it can easily trip up a compiler and so the practice is not recommended at this time.</description>
    </rule>
    <rule key="510">
        <name>L0510: File extension &apos;String&apos; reserved for future versions of this product</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>File name extensions that are not those recognized as implying C++ source code or indirect files for lint or pre-compiled headers for lint or lint object modules or project files are assumed to be C source code.
       If we recognize a new file extension in some future version of lint it can be beneficial to warn about the use of this file extension in any earlier version of lint.
       One reason for this is to aid in the transition between versions of the product. During this transition period a new file extension may be provided unintentionally to a former version of the product resulting in surprising behavior.</description>
    </rule>
    <rule key="511">
        <name>L0511: Size incompatibility</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast was made from an integral type to a pointer and the size of the quantity was too large to fit into the pointer. For example if a long is cast to a pointer and if options indicate that a long ise larger than a pointer, this warning would be reported.</description>
    </rule>
    <rule key="512">
        <name>L0512: Symbol &apos;Symbol&apos; previously used as static (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The Symbol name given is a function name that was declared as static in some other module (the location of that declaration is provided). The use of a name as static in one module and external in another module is legal but suspect.</description>
    </rule>
    <rule key="514">
        <name>L0514: Unusual use of a Boolean</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An argument to an arithmetic operator (+ - / * %) or a bit-wise logical operator (| &amp; ^) was a Boolean. This can often happen by accident as in:
    if( flags &amp; 4 == 0 )
    where the ==, having higher precedence than &amp;, is done first (to the puzzlement of the programmer).</description>
    </rule>
    <rule key="515">
        <name>L0515: Symbol &apos;Symbol&apos; has arg. count conflict (Integer vs. Integer) with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An inconsistency was found in the number of actual arguments provided in a function call and either the number of formal parameters in its definition or the number of actual arguments in some other function call. See the +fva option to selectively suppress this message.</description>
    </rule>
    <rule key="516">
        <name>L0516: Symbol &apos;Symbol&apos; has arg. type conflict (no. Integer -- TypeDiff) with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An inconsistency was found in the type of an actual argument in a function call with either the type of the corresponding formal parameter in the function definition or the type of an actual argument in another call to the same function or with the type specified for the argument in the function&apos;s prototype. The call is not made in the presence of a prototype. See options -ean, -eau, -eas and -eai for selective suppression of some kinds of type differences. If the conflict involves types char or short then you may want to consider using the +fxc or +fxs option.</description>
    </rule>
    <rule key="517">
        <name>L0517: defined not K&amp;R</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The defined function (not a K&amp;R construct) was employed and the K&amp;R preprocessor flag (+fkp) was set. Either do not set the flag or do not use defined.</description>
    </rule>
    <rule key="518">
        <name>L0518: Expected &apos;(&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>sizeof type is not strict C. sizeof(type) or sizeof expression are both permissible.</description>
    </rule>
    <rule key="519">
        <name>L0519: Size incompatibility</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to cast a pointer to a pointer of unequal size. This could occur for example in a P model where pointers to functions require 4 bytes whereas pointers to data require only 2. This error message can be circumvented by first casting the pointer to an integral quantity (int or long) before casting to a pointer.</description>
    </rule>
    <rule key="520">
        <name>L0520: Highest operator or function lacks side-effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first expression of a for clause should either be one of the privileged operators: assignment, increment, decrement or call to an impure function or one modifying its argument(s).</description>
    </rule>
    <rule key="521">
        <name>L0521: Highest operator or function lacks side-effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The third expression of a for clause should either be one of the privileged operators: assignment, increment, decrement or call to an impure function or one modifying its argument(s).</description>
    </rule>
    <rule key="522">
        <name>L0522: Highest operator or function lacks side-effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If a statement consists only of an expression, it should either be one of the privileged operators: assignment, increment, decrement or call to an impure function or one modifying its argument(s). For example if operator * is the built-in operator, the statement *p++; draws this message but p++; does not. This is because the highest operator is &apos;*&apos; which has no side effects.
    The definition of pure and impure functions and function calls which have side effects are given in the discussion of the pure semantic in section 4. Semantics</description>
    </rule>
    <rule key="524">
        <name>L0524: Loss of precision (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is a possible loss of a fraction in converting from a float to an integral quantity. Use of a cast will suppress this message.</description>
    </rule>
    <rule key="525">
        <name>L0525: Negative indentation from Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The current line was found to be negatively indented (i.e., not indented as much) from the indicated line. The latter corresponds to a clause introducing a control structure and statements and other control clauses and braces within its scope are expected to have no less indentation. If tabs within your program are other than 8 blanks you should use the -t option.</description>
    </rule>
    <rule key="526">
        <name>L0526: &apos;Symbol&apos; (Location) not defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named external was referenced but not defined and did not appear declared in any library header file nor did it appear in a Library Module. This message is suppressed for unit checkout (-u option). Please note that a declaration, even one bearing prototype information is not a definition. See the glossary at the beginning of this chapter. If the Symbol is a library symbol, make sure that it is declared in a header file that you&apos;re including. Also make sure that the header file is regarded by PC-lint/FlexeLint as a Library Header file. Alternatively, the symbol may be declared in a Library Module.</description>
    </rule>
    <rule key="527">
        <name>L0527: Unreachable code at token Symbol</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A portion of the program cannot be reached.</description>
    </rule>
    <rule key="528">
        <name>L0528: Symbol &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named static variable or static function was not referenced in the module after having been declared.</description>
    </rule>
    <rule key="529">
        <name>L0529: Symbol &apos;Symbol&apos; (Location) not subsequently referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named variable was declared but not referenced in a function.</description>
    </rule>
    <rule key="530">
        <name>L0530: Symbol &apos;Symbol&apos; (Location) not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An auto variable was used before it was initialized.</description>
    </rule>
    <rule key="531">
        <name>L0531: Field size too large for &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The size given for a bit field of a structure exceeds the size of an int.</description>
    </rule>
    <rule key="532">
        <name>L0532: Return mode of function &apos;Symbol&apos; inconsistent with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration (or a definition) of a function implies a different return mode than a previous statement. (The return mode of a function has to do with whether the function does, or does not, return a value). A return mode is determined from a declaration by seeing if the function returns void or, optionally, by observing whether an explicit type is given. See the fdr flag for a further explanation of this. See also the fvr and fvo flags.</description>
    </rule>
    <rule key="533">
        <name>L0533: function &apos;Symbol&apos; should (not) return a value (see Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A return statement within a function (or lack of a return at the end of the function) implies a different return mode than a previous statement at Location (The return mode of a function has to do with whether the function does, or does not, return a value.)</description>
    </rule>
    <rule key="534">
        <name>L0534: Ignoring return value of function &apos;Symbol&apos; (compare with Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function that returns a value is called just for side effects as, for example, in a statement by itself or the left-hand side of a comma operator. Try: (void) function(); to call a function and ignore its return value. See also the fvr, fvo and fdr flags.</description>
    </rule>
    <rule key="537">
        <name>L0537: Repeated include file &apos;FileName&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The file whose inclusion within a module is being requested has already been included in this compilation. The file is processed normally even if the message is given. If it is your standard practice to repeat included files then simply suppress this message.</description>
    </rule>
    <rule key="538">
        <name>L0538: Excessive size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The size of an array equals or exceeds 64K bytes.</description>
    </rule>
    <rule key="539">
        <name>L0539: Did not expect positive indentation from Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The current line was found to be positively indented from a clause that did not control the line in question. For example: if( n &gt; 0 ) x = 3; y = 4;
    will result in this warning being issued for y = 4;. The Location cited will be that of the if clause.</description>
    </rule>
    <rule key="540">
        <name>L0540: Excessive size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A string initializer required more space than what was allocated.</description>
    </rule>
    <rule key="541">
        <name>L0541: Excessive size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The size of a character constant specified with \xddd or \xhhh equaled or exceeded 2**b where b is the number of bits in a byte (established by the -sb option). The default is -sb8.</description>
    </rule>
    <rule key="542">
        <name>L0542: Excessive size for bit field</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to assign a value into a bit field that appears to be too small. The value to be assigned is either another bit field larger than the target, or a numeric value that is simply too large. You may cast the value to the generic unsigned type to suppress the error.
    You may get this message unexpectedly if the base of the bit field is an int. For example: struct { int b : 1 } s; s.b = 1; /* Warning - - requires 0 or -1 */
    The solution in this case is to use &apos;unsigned&apos; rather than &apos;int&apos; in the declaration of b.</description>
    </rule>
    <rule key="544">
        <name>L0544: endif or else not followed by EOL</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The preprocessor directive #endif should be followed by an end-of-line. Some compilers specifically allow commentary to follow the #endif. If you are following that convention simply turn this error message off.</description>
    </rule>
    <rule key="545">
        <name>L0545: Suspicious use of &amp;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to take the address of an array name. At one time such an expression was officially illegal (K&amp;R C [1]), was not consistently implemented, and was, therefore, suspect. However, the expression is legal in ANSI C and designates a pointer to an array. For example, given
    int a[10]; int (*p) [10];
    Then a and &amp;a, as pointers, both represent the same bit pattern, but whereas a is a pointer to int, &amp;a is a pointer to array 10 of int. Of the two only &amp;a may be assigned to p without complaint. If you are using the &amp; operator in this way, we recommend that you disable this message.</description>
    </rule>
    <rule key="546">
        <name>L0546: Suspicious use of &amp;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to take the address of a function name. Since names of functions by themselves are promoted to address, the use of the &amp; is redundant and could be erroneous.</description>
    </rule>
    <rule key="547">
        <name>L0547: Redefinition of symbol &apos;Symbol&apos; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated symbol had previously been defined (vis #define)to some other value.</description>
    </rule>
    <rule key="548">
        <name>L0548: else expected</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A construct of the form if(e); was found which was not followed by an else. This is almost certainly an unwanted semi-colon as it inhibits the if from having any effect.</description>
    </rule>
    <rule key="549">
        <name>L0549: Suspicious cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast was made from a pointer to some enumerated type or from an enumerated type to a pointer. This is probably an error. Check your code and if this is not an error, then cast the item to an intermediate form (such as an int or a long) before making the final cast.</description>
    </rule>
    <rule key="550">
        <name>L0550: Symbol &apos;Symbol&apos; (Location) not accessed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable (local to some function) was not accessed. This means that the value of a variable was never used. Perhaps the variable was assigned a value but was never used. Note that a variable&apos;s value is not considered accessed by autoincrementing or autodecrementing unless the autoincrement/decrement appears within a larger expression which uses the resulting value. The same applies to a construct of the form: var += expression. If an address of a variable is taken, its value is assumed to be accessed. An array, struct or union is considered accessed if any portion thereof is accessed.</description>
    </rule>
    <rule key="551">
        <name>L0551: Symbol &apos;Symbol&apos; (Location) not accessed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable (declared static at the module level) was not accessed though the variable was referenced. See the explanation under message 550 (above) for a description of &quot;access&quot;.</description>
    </rule>
    <rule key="552">
        <name>L0552: Symbol &apos;Symbol&apos; (Location) not accessed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An external variable was not accessed though the variable was referenced. See the explanation under message 550 above for a description of &quot;access&quot;.</description>
    </rule>
    <rule key="553">
        <name>L0553: Undefined preprocessor variable &apos;Name&apos;, assumed 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated variable had not previously been defined within a #define statement and yet it is being used in a preprocessor condition of the form #if or #elif. Conventionally all variables in preprocessor expressions should be pre-defined. The value of the variable is assumed to be 0.</description>
    </rule>
    <rule key="555">
        <name>L0555: #elif not K&amp;R</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The #elif directive was used and the K&amp;R preprocessor flag (+fkp) was set. Either do not set the flag or do not use #elif.</description>
    </rule>
    <rule key="556">
        <name>L0556: indented #</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A preprocessor directive appeared indented within a line and the K&amp;R preprocessor flag (+fkp) was set. Either do not set the flag or do not indent the #.</description>
    </rule>
    <rule key="557">
        <name>L0557: unrecognized format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The format string supplied to printf, fprintf, sprintf, scanf, fscanf, or sscanf was not recognized. It is neither a standard format nor is it a user-defined format (see printf_code and scanf_code).</description>
    </rule>
    <rule key="558">
        <name>L0558: Too few arguments for format (Integer missing)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The number of arguments supplied to printf, sprintf, fprintf, scanf, fscanf or sscanf was inconsistent with the number expected as a result of analyzing the format string.</description>
    </rule>
    <rule key="559">
        <name>L0559: size of argument number Integer inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given argument (to printf, sprintf, or fprintf) was inconsistent with that which was anticipated as the result of analyzing the format string. Argument counts begin at 1 and include file, string and format specifications. For example,
    sprintf( buffer, &quot;%f&quot;, 371 )
    will show an error in argument number 3 because constant 371 is not floating point.</description>
    </rule>
    <rule key="560">
        <name>L0560: argument no. Integer should be a pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given argument (to one of the scanf or printf family of functions) should be a pointer. For the scanf family, all arguments corresponding to a format specification should be pointers to areas that are to be modified (receive the results of scanning). For the printf family, arguments corresponding to %s or %n also need to be pointers.
    Argument counts begin at 1 and include file, string and format specifications. For example
    scanf( &quot;%f&quot;, 3.5 )
    will generate the message that argument no. 2 should be a pointer.</description>
    </rule>
    <rule key="561">
        <name>L0561: (arg. no. Integer) indirect object inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given argument (to scanf, sscanf, or fscanf) was a pointer to an object that was inconsistent with that which was anticipated as the result of analyzing the format string. Argument counts begin at 1 and include file, string and format specifications. For example if n is declared as int then:
    scanf( &quot;%c&quot;, &amp;n )
    will elicit this message for argument number 2.</description>
    </rule>
    <rule key="562">
        <name>L0562: Ellipsis (...) assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a function prototype a comma was immediately followed by a right parenthesis. This is taken by some compilers to be equivalent to an ellipsis (three dots) and this is what is assumed by PC-lint/FlexeLint. If your compiler does not accept the ellipsis but makes this assumption, then you should suppress this message.</description>
    </rule>
    <rule key="563">
        <name>L0563: Label &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The Symbol at the cited Location appeared as a label but there was no statement that referenced this label.</description>
    </rule>
    <rule key="564">
        <name>L0564: variable &apos;Symbol&apos; depends on order of evaluation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named variable was both modified and accessed in the same expression in such a way that the result depends on whether the order of evaluation is left-to-right or right-to-left. One such example is: n + n++ since there is no guarantee that the first access to n occurs before the increment of n. Other, more typical cases, are given in the manual. Volatile variables are also checked for repeated use in an expression.</description>
    </rule>
    <rule key="565">
        <name>L0565: tag &apos;Symbol&apos; not previously seen, assumed file-level scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named tag appeared in a prototype or in an inner block and was not previously seen in an outer (file-level) scope. The ANSI standard is dubious as to how this tag could link up with any other tag. For most compilers this is not an error and you can safely suppress the message. On the other hand, to be strictly in accord with ANSI C you may place a small stub of a declaration earlier in the program. For example:
    struct name;
    is sufficient to reserve a place for name in the symbol table at the appropriate level.</description>
    </rule>
    <rule key="566">
        <name>L0566: Inconsistent or redundant format char &apos;Char&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for format specifiers within formats for the printf/scanf family of functions. The indicated character Char found in a format specifier was inconsistent or redundant with an earlier character found in the same format specifier. For example a format containing &quot;%ls&quot; will yield this error with the character &apos;s&apos; indicated. This is because the length modifier is designed to be used with integral or float conversions and has no meaning with the string conversion. Such characters are normally ignored by compilers.</description>
    </rule>
    <rule key="567">
        <name>L0567: Expected a numeric field before char &apos;Char&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for format specifiers within formats for the printf/scanf family of functions. A numeric field or asterisk was expected at a particular point in the scanning of the format. For example: %-d requests left justification of a decimal integer within a format field. But since no field width is given, the request is meaningless.</description>
    </rule>
    <rule key="568">
        <name>L0568: nonnegative quantity is never less than zero.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Comparisons of the form:
    u &gt;= 0 0 &lt;= u u &lt; 0 0 &gt; u
    are suspicious if u is an unsigned quantity or a quantity judged to be never less then 0. See also message 775.</description>
    </rule>
    <rule key="569">
        <name>L0569: Loss of information (Context) (Integer bits to Integer bits)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) was made from a constant to an integral variable that is not large enough to hold the constant. Examples include placing a hex constant whose bit requirement is such as to require an unsigned int into a variable typed as int. The number of bits given does not count the sign bit.</description>
    </rule>
    <rule key="570">
        <name>L0570: Loss of sign (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) is being made from a negative constant into an unsigned quantity. Casting the constant to unsigned will remove the diagnostic but is this what you want. If you are assigning all ones to an unsigned, remember that ~0 represents all ones and is more portable than -1.</description>
    </rule>
    <rule key="571">
        <name>L0571: Suspicious Cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Usually this warning is issued for casts of the form:
    (unsigned) ch
    where ch is declared as char and char is signed. Although the cast may appear to prevent sign extension of ch, it does not. Following the normal promotion rules of C, ch is first converted to int which extends the sign and only then is the quantity cast to unsigned. To suppress sign extension you may use:
    (unsigned char) ch
    Otherwise, if sign extension is what you want and you just want to suppress the warning in this instance you may use:
    (unsigned) (int) ch
    Although these examples have been given in terms of casting a char they will also be given whenever this cast is made upon a signed quantity whose size is less than the casted type. Examples include signed bit fields (a possibility in the new standard), expressions involving char, and expressions involving short when this type is smaller than int or a direct cast of an int to an unsigned long (if int&apos;s is smaller than long). This message is not issued for constants or for expressions involving bit operations.</description>
    </rule>
    <rule key="572">
        <name>L0572: Excessive shift value (precision Integer shifted right by Integer)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A quantity is being shifted to the right whose precision is equal to or smaller than the shifted value. For example,
    ch &gt;&gt; 10
    will elicit this message if ch is typed char and where char is less than 10 bits wide (the usual case). To suppress the message you may cast the shifted quantity to a type whose length is at least the length of the shift value.</description>
    </rule>
    <rule key="573">
        <name>L0573: Signed-unsigned mix with divide</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>one of the operands to / or % was signed and the other unsigned; moreover the signed quantity could be negative. For example:
    u / n
    where u is unsigned and n is signed will elicit this message whereas:
    u / 4
    will not, even though 4 is nominally an int. It is not a good idea to mix unsigned quantities with signed quantities in any case (a 737 will also be issued) but, with division, a negative value can create havoc. For example, the innocent looking:
    n = n / u
    will, if n is -2 and u is 2, not assign -1 to n but will assign some very large value.
    To resolve this problem, either cast the integer to unsigned if you know it can never be less than zero or cast the unsigned to an integer if you know it can never exceed the maximum integer.</description>
    </rule>
    <rule key="574">
        <name>L0574: Signed-unsigned mix with relational</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The four relational operators are: &gt; &gt;= &lt; &lt;=
    One of the operands to a relational operator was signed and the other unsigned; also, the signed quantity could be negative. For example:
    if( u &gt; n ) ...
    where u is unsigned and n is signed will elicit this message whereas:
    if( u &gt; 12 ) ...
    will not (even though 12 is officially an int it is obvious that it is not negative). It is not a good idea to mix unsigned quantities with signed quantities in any case (a 737 will also be issued) but, with the four relationals, a negative value can produce obscure results. For example, if the conditional:
    if( n &lt; 0 ) ...
    is true then the similar appearing:
    u = 0; if( n &lt; u ) ...
    is false because the promotion to unsigned makes n very large.
    To resolve this problem, either cast the integer to unsigned if you know it can never be less than zero or cast the unsigned to an int if you know it can never exceed the maximum int.</description>
    </rule>
    <rule key="575">
        <name>L0575: enumeration constant exceeds range for integers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>For many compilers the value of an enumeration constant is limited to those values that can fit within a signed or unsigned int.</description>
    </rule>
    <rule key="577">
        <name>L0577: Mixed memory model (option &apos;String&apos;)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated option requested a change to the memory model after part or all of another module was processed. The memory model option should be specified before any module is processed. The most common cause of this error is specifying the memory model after having specified the standard library. This would be a natural error to make if the standard library file were specified via a LINT environment variable.</description>
    </rule>
    <rule key="578">
        <name>L0570: Declaration of symbol &apos;Symbol&apos; hides symbol &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A local symbol has the identical name as a global symbol ( or possibly another local symbol). This could be dangerous. Was this deliberate? It is usually best to rename the local symbol.</description>
    </rule>
    <rule key="579">
        <name>L0579: parameter preceding ellipsis has invalid type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When an ellipsis is used, the type preceding the ellipsis should not be a type that would undergo a default promotion such as char, short or float. The reason is that many compilers&apos; variable argument schemes (using stdarg.h) will break down.</description>
    </rule>
    <rule key="580">
        <name>L0580: Redeclaration of function &apos;Symbol&apos; (hiding Location) causes loss of prototype</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration of a function within a block hides a declaration in an outer scope in such a way that the inner declaration has no prototype and the outer declaration does. A common misconception is that the resulting declaration is a composite of both declarations but this is only the case when the declarations are in the same scope not within nested scopes. If you don&apos;t care about prototypes you may suppress this message. You will still receive other type-difference warnings.</description>
    </rule>
    <rule key="581">
        <name>L0581: Option &apos;String&apos; is obsolete and should no longer be used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued whenever we encounter an option that appears to do more harm than good. &apos;String&apos; is the option in question.</description>
    </rule>
    <rule key="582">
        <name>L0582: esym (or emacro) name &apos;String&apos; should not contain &apos;(&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The name provided to esym should not contain a (. For example, to suppress message 534 when calling f(int) use the option -esym(534,f) even if f is overloaded.</description>
    </rule>
    <rule key="583">
        <name>L0583: Comparing type &apos;Type&apos; with EOF</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The message is issued when some form of character is compared against the EOF macro. EOF is normally defined to be -1. For example: while( (ch = getchar()) != EOF ) ... If ch is defined to be an int all is well. If however it is defined to be some form of char, then trouble might ensue. If ch is an unsigned char then it can never equal EOF. If ch is a signed char then you could get a premature termination because some data character happened to be all ones.
    Note that getchar returns an int. The reason it returns an int and not a char is because it must be capable of returning 257 different values (256 different characters plus EOF, assuming an 8-bit character). Once this value is assigned to a char only 256 values are then possible -- a clear loss of information.</description>
    </rule>
    <rule key="584">
        <name>L0584: Trigraph sequence (??Char) detected</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued whenever a trigraph sequence is detected and the trigraph processing has been turned off (with a -ftg). If this is not within a string (or character) constant then the trigraph sequence is ignored. This is useful if your compiler does not process trigraph sequences and you want linting to mirror compilation. Outside of a string we issue the Warning but we do translate the sequence since it cannot make syntactic sense in its raw state.</description>
    </rule>
    <rule key="585">
        <name>L0585: The sequence (??Char) is not a valid Trigraph sequence</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is issued whenever a pair of &apos;?&apos; characters is seen within a string (or character) constant but that pair is not followed by a character which would make the triple a valid Trigraph sequence. Did the programmer intend this to be a Trigraph sequence and merely err? Even if no Trigraph were intended, it can easily be mistaken by the reader of the code to be a Trigraph. Moreover, what assurances do we have that in the future the invalid Trigraph might not become a valid Trigraph and change the meaning of the string? To protect yourself from such an event you may place a backslash between the &apos;?&apos; characters. Alternatively you may use concatenation of string constants. For example: pattern = &quot;(???) ???-????&quot;; // warning 585 pattern = &quot;(?\?\?) ?\?\?-?\?\?\?&quot;; // no warning #define Q &quot;?&quot; pattern = &quot;(&quot; Q Q Q &quot;) &quot; Q Q Q &quot;-&quot; Q Q Q Q // no warning</description>
    </rule>
    <rule key="586">
        <name>L0586: String &apos;Name&apos; is deprecated. String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The Name has been deprecated by some use of the deprecate option. See Section 2.5.7 -deprecate. The first String is one of the allowed categories of deprecation. The trailing String is part of the deprecate option and should explain why the facility has been deprecated.</description>
    </rule>
    <rule key="587">
        <name>L0587: Predicate &apos;String&apos; can be pre-determined and always evaluates to String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The predicate, identified by the first String, (one of greater than, greater than or equal, less than, less than or equal, equal, or not equal), cannot possibly be other than what is indicated by the second String parameter. For example: unsigned u; ... if( (u &amp; 0x10) == 0x11 ) ... would be greeted with the message that &apos;==&apos; always evaluates to &apos;False&apos;.</description>
    </rule>
    <rule key="588">
        <name>L0580: Predicate &apos;String&apos; will always evaluate to String unless an overflow occurs</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The predicate, identified by the first String, cannot possibly be other than what is indicated by the second String parameter unless an overflow occurred. For example: unsigned u; ... if( (u + 2) != 1 ) ... would be greeted with the message that &apos;!=&apos; always evaluates to &apos;True&apos;. See also Message 587.</description>
    </rule>
    <rule key="589">
        <name>L0588: Predicate &apos;String&apos; will always evaluate to String assuming standard division semantics</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The predicate, identified by the first String parameter, cannot possibly be other than what is indicated by the second String parameter assuming standard signed integer division semantics. For example: int n; ... if( n % 2 == 2 ) ... would be greeted with the message that &apos;==&apos; always evaluates to &apos;False&apos;.
    By standard integer division semantics we mean truncation toward zero so that, for example, -1/4 has quotient 0 and remainder -1 and not quotient -1, remainder 3. Although the current C standard [4] has endorsed this, the current C++ standard [10] regards integer division involving negative numbers to be &apos;implementation defined&apos;.
    See also Message 587.</description>
    </rule>
    <rule key="590">
        <name>L0590: Predicate &apos;String&apos; will always evaluate to String assuming standard shift semantics</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The predicate, identified by the first String parameter, cannot possibly be other than what is indicated by the second String parameter assuming standard signed integer shift semantics. For example: int n; ... if( (5 &lt;&lt; n) &lt; 0 ) ... would be greeted with the message that the less-than always evaluates to &apos;False&apos;. It is true that if you shift 5 left by 29 bits (or 31 bits) you will have in many cases (probably most cases) a negative number but this is not guaranteed. According to the C Standard [4], shifting a positive signed integer (5 in this case) left by a number of places (n in this case) is only valid if the type can accommodate 5*(2**n). This is equivalent to not shifting a one into or through the sign bit.
    As another example: int n; ... if( (n &gt;&gt; 5) &gt;= 0 ) ... would always be regarded as true. This is because shifting a negative number to the right yields results that are implementation defined.
    See also Message 587.</description>
    </rule>
    <rule key="591">
        <name>L0591: Variable &apos;Symbol&apos; depends on the order of evaluation; it is used/modified through function &apos;Symbol&apos; via calls: String&quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated variable (given by the first Symbol) was involved in an expression that contained a call of a function (given by the second Symbol) that would use or modify the variable. Further, the order of evaluation of the two is not determinable. For example: extern int n; void f() { n++; } int g() { f(); return 1; } int h() { return n + g(); } // Warning 591 The above code, on the second pass, will elicit the following warning: Warning 591: Variable &apos;n&apos; depends on the order of evaluation; it is modified through function &apos;g(void)&apos; via calls: g() =&gt; f() If the function g() is called and then n is added, you will obtain a different result than if n were first evaluated and then the call made.
    The programmer should generally rewrite these expressions so that the compiler is constrained to use the intended order. For example if the programmer wanted to use the n prior to the call on g() it can alter h() to the following: int h() { int k = n; return k + g(); } This analysis requires two passes; the first pass builds the necessary call trees.</description>
    </rule>
    <rule key="592">
        <name>L0592: Non-literal format specifier used without arguments</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A printf/scanf style function received a non-literal format specifier without trailing arguments. For example: char msg[100]; ... printf( msg ); This can easily be rewritten to the relatively safe: char msg[100]; ... printf( &quot;%s&quot;, msg ); The danger lies in the fact that msg can contain hidden format codes. If msg is read from user input, then in the first example, a naive user could cause a glitch or a crash and a malicious user might exploit this to undermine system security. Since the unsafe form can easily be transformed into the safe form the latter should always be used.</description>
    </rule>
    <rule key="593">
        <name>L0593: Custodial pointer &apos;Symbol&apos; (Location) possibly not freed or returned</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This is the &apos;possible&apos; version of message 429. A pointer of auto storage class was allocated storage and not all paths leading to a return statement or to the end of the function contained either a free or a return of the pointer. Hence there is a potential memory leak. For example: void f( int n ) { int *p = new int; if( n ) delete p; } // message 593 In this example an allocation is made and, if n is 0, no delete will have been made.
    Please see message 429 for an explanation of &quot;custodial&quot; and ways of regulating when pointer variables retain custody of allocations.</description>
    </rule>
    <rule key="598">
        <name>L0598: Excessive shift value (precision Integer shifted left by Integer)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A quantity is being shifted to the left by a value greater than or equal to the precision of that quantity or by a negative value. For example,

         i &lt;&lt; 32

       will elicit this message if i is typed int and where int is 32 bits wide or less (the usual case). Such shift results in undefined behavior.
       To suppress the message you may cast the shifted quantity to a type whose length is at least the length of the shift value.</description>
    </rule>
    <rule key="601">
        <name>L0601: Expected a type for symbol Symbol, int assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration did not have an explicit type. int was assumed. Was this a mistake? This could easily happen if an intended comma was replaced by a semicolon. For example, if instead of typing: double radius, diameter; the programmer had typed: double radius; diameter; this message would be raised.</description>
    </rule>
    <rule key="602">
        <name>L0602: Comment within comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The sequence /* was found within a comment. Was this deliberate? Or was a comment end inadvertently omitted? If you want PC-lint/FlexeLint to recognize nested comments you should set the Nested Comment flag using the +fnc option. Then this warning will not be issued. If it is your practice to use the sequence: /* /* */
    then use -e602.</description>
    </rule>
    <rule key="603">
        <name>L0603: Symbol &apos;Symbol&apos; (Location) not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of the named symbol is being passed to a function where the corresponding parameter is declared as pointer to const. This implies that the function will not modify the object. If this is the case then the original object should have been initialized sometime earlier.</description>
    </rule>
    <rule key="604">
        <name>L0604: Returning address of auto variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of the named symbol is being passed back by a function. Since the object is an auto and since the duration of an auto is not guaranteed past the return, this is most likely an error. You may want to copy the value into a global variable and pass back the address of the global or you might consider having the caller pass an address of one of its own variables to the callee.</description>
    </rule>
    <rule key="605">
        <name>L0605: Increase in pointer capability (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is typically caused by assigning a (pointer to const) to an ordinary pointer. For example: int *p; const int *q; p = q; /* 605 */ The message will be inhibited if a cast is used as in:
    p = (int *) q;
    An increase in capability is indicated because the const pointed to by q can now be modified through p. This message can be given for the volatile qualifier as well as the const qualifier and may be given for arbitrary pointer depths (pointers to pointers, pointers to arrays, etc.).
    If the number of pointer levels exceeds one, things get murky in a hurry. For example: const char ** ppc; char ** pp; pp = ppc; /* 605 - clearly not safe */ ppc = pp; /* 605 - looks safe but it&apos;s not */ It was not realized by the C community until very recently that assigning pp to ppc was dangerous. The problem is that after the above assignment, a pointer to a const char can be assigned indirectly through ppc and accessed through pp which can then modify the const char.
    The message speaks of an &quot;increase in capability&quot; in assigning to ppc, which seems counter intuitive because the indirect pointer has less capability. However, assigning the pointer does not destroy the old one and the combination of the two pointers represents a net increase in capability.
    The message may also be given for function pointer assignments when the prototype of one function contains a pointer of higher capability than a corresponding pointer in another prototype. There is a curious inversion here whereby a prototype of lower capability translates into a function of greater trust and hence greater capability (a Trojan Horse). For example, let
    void warrior( char * );
    be a function that destroys its argument. Consider the function:
    void Troy( void (*horse)(const char *) );
    Troy() will call horse() with an argument that it considers precious believing the horse() will do no harm. Before compilers knew better and believing that adding in a const to the destination never hurt anything, earlier compilers allowed the Greeks to pass warrior() to Troy and the rest, as they say, is history.</description>
    </rule>
    <rule key="606">
        <name>L0606: Non-ANSI escape sequence: &apos;\String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An escape sequence occurred, within a character or string literal, that was not on the approved list which is:
    \&apos; \&quot; \? \\ \a \b \f \n \r \t \v
    \octal-digits \xhex-digits</description>
    </rule>
    <rule key="607">
        <name>L0607: Parameter &apos;Symbol&apos; of macro found within string</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated name appeared within a string or character literal within a macro and happens to be the same as the name of a formal parameter of the macro as in:
    #define mac(n) printf( &quot;n = %d,&quot;, n );
    Is this a coincidence? The ANSI standard indicates that the name will not be replaced but since many C compilers do replace such names the construction is suspect. Examine the macro definition and if you do not want substitution, change the name of the parameter. If you do want substitution, set the +fps flag (Parameter within String) and suppress the message with -e607.</description>
    </rule>
    <rule key="608">
        <name>L0608: Assigning to an array parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment is being made to a parameter that is typed array. For the purpose of the assignment, the parameter is regarded as a pointer. Normally such parameters are typed as pointers rather than arrays. However if this is your coding style you should suppress this message.</description>
    </rule>
    <rule key="609">
        <name>L0609: Suspicious pointer conversion</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment is being made between two pointers which differ in size (one is far and the other is near) but which are otherwise compatible.</description>
    </rule>
    <rule key="610">
        <name>L0610: Suspicious pointer combination</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Pointers of different size (one is far and the other is near) are being compared, subtracted, or paired (in a conditional expression). This is suspicious because normally pointers entering into such operations are the same size.</description>
    </rule>
    <rule key="611">
        <name>L0611: Suspicious cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Either a pointer to a function is being cast to a pointer to an object or vice versa. This is regarded as questionable by the ANSI standard. If this is not a user error, suppress this warning.</description>
    </rule>
    <rule key="612">
        <name>L0612: Expected a declarator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration contained just a storage class and a type. This is almost certainly an error since the only time a type without a declarator makes sense is in the case of a struct, union or enum but in that case you wouldn&apos;t use a storage class.</description>
    </rule>
    <rule key="613">
        <name>L0613: Possible use of null pointer &apos;Symbol&apos; in [left/right] argument to operator &apos;String&apos; Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>From information gleaned from earlier statements, it is possible that a null pointer (a pointer whose value is 0) can be used in a context where null pointers are inappropriate. Such contexts include: Unary *, pointer increment (++) or decrement(--), addition of pointer to numeric, and subtraction of two pointers. In the case of binary operators, one of the words &apos;left&apos; or &apos;right&apos; is used to designate which operand is null. Symbol identifies the pointer variable that may be NULL. See also messages 413 and 794.</description>
    </rule>
    <rule key="614">
        <name>L0614: auto aggregate initializer not constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer for an auto aggregate normally consists of a collection of constant-valued expressions. Some compilers may, however, allow variables in this context in which case you may suppress this message.</description>
    </rule>
    <rule key="615">
        <name>L0615: auto aggregate initializer has side effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is similar to 614. Auto aggregates (arrays, structures and union) are normally initialized by a collection of constant-valued expressions without side-effects. A compiler could support side-effects in which case you might want to suppress this message.</description>
    </rule>
    <rule key="616">
        <name>L0616: control flows into case/default</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It is possible for flow of control to fall into a case statement or a default statement from above. Was this deliberate or did the programmer forget to insert a break statement? If this was deliberate then place a comment immediately before the statement that was flagged as in:
    case &apos;a&apos;: a = 0; /* fall through */ case &apos;b&apos;: a++;
    Note that the message will not be given for a case that merely follows another case without an intervening statement. Also, there must actually be a possibility for flow to occur from above.</description>
    </rule>
    <rule key="617">
        <name>L0617: String is both a module and an include file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named file is being used as both an include file and as a module. Was this a mistake? Unlike Error 306 (repeated module) this is just a warning and processing of the file is attempted.</description>
    </rule>
    <rule key="618">
        <name>L0618: Storage class specified after a type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A storage class specifier (static, extern, typedef, register or auto) was found after a type was specified. This is legal but deprecated. Either place the storage class specifier before the type or suppress this message.</description>
    </rule>
    <rule key="619">
        <name>L0619: Loss of precision (Context) (Pointer to Pointer)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A far pointer is being assigned to a near pointer either in an assignment statement or an implied assignment such as an initializer, a return statement, or passing an argument in the presence of a prototype (Context indicates which). Such assignments are a frequent source of error when the actual segment is not equal to the default data segment. If you are sure that the segment of the far pointer equals the default data segment you should use a cast to suppress this message.</description>
    </rule>
    <rule key="620">
        <name>L0620: Suspicious constant (L or one?)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constant ended in a lower-case letter &apos;l&apos;. Was this intended to be a one? The two characters look very similar. To avoid misinterpretations, use the upper-case letter &apos;L&apos;.</description>
    </rule>
    <rule key="621">
        <name>L0621: Identifier clash (Symbol &apos;Name&apos; with Symbol &apos;Name&apos; at String)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The two symbols appeared in the same name space but are identical to within the first count characters set by option -idlen(count,option). See -idlen.</description>
    </rule>
    <rule key="622">
        <name>L0622: Size of argument no. Integer inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The argument to scanf, fscanf or sscanf, where position is given by Integer, was a pointer whose size did not match the format. For example,
    int far *p; scanf( &quot;%d&quot;, p );
    will draw this warning (in the default memory model).</description>
    </rule>
    <rule key="623">
        <name>L0623: redefining the storage class of symbol &apos;Symbol&apos; (TypeDiff) conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An inter-module symbol was a typedef symbol in one module and an ordinary symbol in another module. This is legal but potentially confusing. Is this what the programmer intended?</description>
    </rule>
    <rule key="624">
        <name>L0624: typedef &apos;Symbol&apos; redeclared (TypeDiff) (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A symbol was declared in a typedef differently in two different modules. This is technically legal but is not a wise programming practice.</description>
    </rule>
    <rule key="625">
        <name>L0625: auto symbol &apos;Symbol&apos; has unusual type modifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some type modifiers such as far, near, fortran are inappropriate for auto variables.</description>
    </rule>
    <rule key="626">
        <name>L0626: argument no. Integer inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The argument to a printf (or fprintf or sprintf) was inconsistent with the format. Although the size of the quantity was appropriate the type was not. You might consider casting the quantity to the correct type. You could also suppress this message, as more flagrant violations are picked up with warning 559.</description>
    </rule>
    <rule key="627">
        <name>L0627: (arg. no. Integer) indirect object inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The type of an argument to scanf (or fscanf or sscanf) was inappropriate to the format. However, the argument was a pointer and it pointed to a quantity of the expected size.</description>
    </rule>
    <rule key="628">
        <name>L0628: no argument information provided for function &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named function was called but there was no argument information supplied. Argument information can come from a prototype or from a function definition. This usually happens when an old-style function declaration indicates that the function is in a library but no prototype is given for the function nor is any argument information provided in a standard library file. This message is suppressed if you are producing a lint object module because presumably the object module will be compared with a library file at some later time.</description>
    </rule>
    <rule key="629">
        <name>L0629: static class for function &apos;Symbol&apos; is non standard</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static class was found for a function declaration within a function. The static class is only permitted for functions in declarations that have file scope (i.e., outside any function). Either move the declaration outside the function or change static to extern; if the second choice is made, make sure that a static declaration at file scope also exists before the extern declaration. Though technically the construct is not portable, many compilers do tolerate it. If you suppress the message, PC-lint/FlexeLint will treat it as a proper function declaration.</description>
    </rule>
    <rule key="630">
        <name>L0630: ambiguous reference to symbol &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If the +fab flag is set, then if two structures containing the same member name (not necessarily different kinds of structures) are embedded in the same structure and a reference to this member name omits one of the intervening (disambiguating) names, this warning is emitted.</description>
    </rule>
    <rule key="631">
        <name>L0631: tag &apos;Symbol&apos; defined differently at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The struct, union or enum tag Symbol was defined differently in different scopes. This is not necessarily an error since C permits the redefinition, but it can be a source of subtle error. It is not generally a programming practice to be recommended.</description>
    </rule>
    <rule key="632">
        <name>L0632: Assignment to strong type &apos;Name&apos; in context: Context</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, Context indicates which) violates a Strong type check as requested by a -strong(A... option.</description>
    </rule>
    <rule key="633">
        <name>L0633: Assignment from a strong type &apos;Name&apos; in context: Context</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, Context indicates which) violates a Strong type check as requested by a -strong(X... option.</description>
    </rule>
    <rule key="634">
        <name>L0634: Strong type mismatch (type &apos;Symbol&apos;) in equality or conditional</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An equality operation (== or !=) or a conditional operation (? :) violates a Strong type check as requested by a -strong(J... option. This message would have been suppressed using flags &quot;Je&quot;.</description>
    </rule>
    <rule key="635">
        <name>L0635: resetting strong parent of type &apos;Symbol&apos;, old parent == type &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The strong parent of the given Symbol is being reset. This is being done with a -parent option or by a typedef. Note that this may not necessarily be an error; you are being alerted to the fact that the old link is being erased.</description>
    </rule>
    <rule key="636">
        <name>L0636: ptr to strong type &apos;Name&apos; versus another type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Pointers are being compared and there is a strong type clash below the first level. For example,
    /*lint -strong(J,INT) */ typedef int INT; INT *p; int *q;
    if( p == q ) /* Warning 636 */
    will elicit this warning. This message would have been suppressed using flags &quot;Je&quot; or &quot;Jr&quot; or both.</description>
    </rule>
    <rule key="637">
        <name>L0637: Expected index type &apos;Symbol&apos; for strong type &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This is the message you receive when an inconsistency with the -index option is recognized. A subscript is not the stipulated type (the first type mentioned in the message) nor equivalent to it within the hierarchy of types.</description>
    </rule>
    <rule key="638">
        <name>L0638: Strong type mismatch for type &apos;Name&apos; in relational</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A relational operation ( &gt;= &lt;= &gt; &lt; ) violates a Strong type check as requested by a -strong(J... option. This message would have been suppressed using flags &quot;Jr&quot;.</description>
    </rule>
    <rule key="639">
        <name>L0639: Strong type mismatch for type &apos;Name&apos; in binary operation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A binary operation other than an equality or a relational operation violates a Strong type check as requested by a -strong(J... option. This message would have been suppressed using flags &quot;Jo&quot;.</description>
    </rule>
    <rule key="640">
        <name>L0640: Expected strong type &apos;Name&apos; in Boolean context</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A Boolean context expected a type specified by a -strong(B... option.</description>
    </rule>
    <rule key="641">
        <name>L0641: Converting enum to int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An enumeration type was used in a context that required a computation such as an argument to an arithmetic operator or was compared with an integral argument. This warning will be suppressed if you use the integer model of enumeration (+fie) but you will lose some valuable type-checking in doing so. An intermediate policy is to simply turn off this warning. Assignment of int to enum will still be caught.
    This warning is not issued for a tagless enum without variables. For example
    enum {false,true};
    This cannot be used as a separate type. PC-lint/FlexeLint recognizes this and treats false and true as arithmetic constants.</description>
    </rule>
    <rule key="642">
        <name>L0642: Format char &apos;Char&apos; not supported by wsprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This means that you are using an option of the form: -printf(w... and you are using a format character not supported by the Microsoft Windows function wsprintf. If you are not really using wsprintf but are using the w flag to get far pointers you should turn this message off.</description>
    </rule>
    <rule key="643">
        <name>L0643: Loss of precision in pointer cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A far pointer was cast to a near pointer. Such casts have had disastrous consequences for Windows programmers. If you really need to make such a cast, you can do it in stages. If you cast to a long first (i.e., some integral type that can hold the pointer) and then into a shorter value, we don&apos;t complain.</description>
    </rule>
    <rule key="644">
        <name>L0644: Variable &apos;Symbol&apos; (Location) may not have been initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An auto variable was not necessarily assigned a value before use.</description>
    </rule>
    <rule key="645">
        <name>L0645: Symbol &apos;Symbol&apos; (Location) may not have been initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An auto variable was conditionally assigned a value before being passed to a function expecting a pointer to a const object. See Warning 603 for an explanation of the dangers of such a construct.</description>
    </rule>
    <rule key="646">
        <name>L0646: case/default within Kind loop; may have been misplaced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A case or default statement was found within a for, do, or while loop. Was this intentional? At the very least, this reflects poor programming style.</description>
    </rule>
    <rule key="647">
        <name>L0647: Suspicious truncation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when it appears that there may have been an unintended loss of information during an operation involving int or unsigned int the result of which is later converted to long. It is issued only for systems in which int is smaller than long. For example:
    (long) (n &lt;&lt; 8)
    might elicit this message if n is unsigned int, whereas
    (long) n &lt;&lt; 8
    would not. In the first case, the shift is done at int precision and the high order 8 bits are lost even though there is a subsequent conversion to a type that might hold all the bits. In the second case, the shifted bits are retained.
    The operations that are scrutinized and reported upon by this message are: shift left, multiplication, and bit-wise complementation. Addition and subtraction are covered by Informational message 776.&lt;/description&gt;&lt;/rule&gt;
    The conversion to long may be done explicitly with a cast as shown or implicitly via assignment, return, argument passing or initialization.
    The message can be suppressed by casting. You may cast one of the operands so that the operation is done in full precision as is given by the second example above. Alternatively, if you decide there is really no problem here (for now or in the future), you may cast the result of the operation to some form of int. For example, you might write:
    (long) (unsigned) (n &lt;&lt; 8)
    In this way PC-lint/FlexeLint will know you are aware of and approve of the truncation.</description>
    </rule>
    <rule key="648">
        <name>L0648: Overflow in computing constant for operation: String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Arithmetic overflow was detected while computing a constant expression. For example, if int is 16 bits then 200 * 200 will result in an overflow. String gives the operation that caused the overflow and may be one of: addition, unsigned addition, multiplication, unsigned multiplication, negation, shift left, unsigned shift left, subtraction, or unsigned sub.
    To suppress this message for particular constant operations you may have to supply explicit truncation. For example, if you want to obtain the low order 8 bits of the integer 20000 into the high byte of a 16-bit int, shifting left would cause this warning. However, truncating first and then shifting would be OK. The following code illustrates this where int is 16 bits. 20000u &lt;&lt; 8; /* 648 */ (0xFF &amp; 20000u) &lt;&lt; 8; /* OK */ If you truncate with a cast you may make a signed expression out of an unsigned. For example, the following receives a warning (for 16 bit int).
    (unsigned char) OxFFFu &lt;&lt; 8 /* 648 */
    because the unsigned char is promoted to int before shifting. The resulting quantity is actually negative. You would need to revive the unsigned nature of the expression with
    (unsigned) (unsigned char) OxFFF &lt;&lt; 8 /* OK */</description>
    </rule>
    <rule key="649">
        <name>L0649: Sign fill during constant shift</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>During the evaluation of a constant expression a negative integer was shifted right causing sign fill of vacated positions. If this is what is intended, suppress this error, but be aware that sign fill is implementation-dependent.</description>
    </rule>
    <rule key="650">
        <name>L0650: Constant out of range for operator String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a comparison operator or equality test (or implied equality test as for a case statement), a constant operand is not in the range specified by the other operand. For example, if 300 is compared against a char variable, this warning will be issued. Moreover, if char is signed (and 8 bits) you will get this message if you compare against an integer greater than 127. The problem can be fixed with a cast. For example:
    if( ch == 0xFF ) ... if( (unsigned char) ch == 0xFF ) ...
    If char is signed (+fcu has not been set) the first receives a warning and can never succeed. The second suppresses the warning and corrects the bug.
    PC-lint/FlexeLint will take into account the limited precision of some operands such as bit-fields and enumerated types. Also, PC-lint/FlexeLint will take advantage of some computations that limit the precision of an operand. For example,
    if( (n &amp; 0xFF) &gt;&gt; 4 == 16 ) ...
    will receive this warning because the left-hand side is limited to 4 bits of precision.</description>
    </rule>
    <rule key="651">
        <name>L065: Potentially confusing initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer for a complex aggregate is being processed that contains some subaggregates that are bracketed and some that are not. ANSI recommends either &quot;minimally bracketed&quot; initializers in which there are no interior braces or &quot;fully bracketed&quot; initializers in which all interior aggregates are bracketed.</description>
    </rule>
    <rule key="652">
        <name>L0652: #define of symbol &apos;Symbol&apos; declared previously at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A macro is being defined for a symbol that had previously been declared. For example:
    int n; #define n N
    will draw this complaint. Prior symbols checked are local and global variables, functions and typedef symbols, and struct, union and enum tags. Not checked are struct and union member.</description>
    </rule>
    <rule key="653">
        <name>L0653: Possible loss of fraction</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When two integers are divided and assigned to a floating point variable the fraction portion is lost. For example, although
    double x = 5 / 2;
    appears to assign 2.5 to x it actually assigns 2.0. To make sure you don&apos;t lose the fraction, cast at least one of the operands to a floating point type. If you really wish to do the truncation, cast the resulting divide to an integral (int or long) before assigning to the floating point variable.</description>
    </rule>
    <rule key="654">
        <name>L0654: Option String obsolete; use -width(W,I)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The option -w is now used to set the warning level and should no longer be used to specify the width of error messages. Instead use -width with the same arguments as before to set the width. To set the warning level to 3, for example, use the option -w3, not -w(3).</description>
    </rule>
    <rule key="655">
        <name>L0655: bit-wise operation uses (compatible) enum&apos;s</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A bit-wise operator (one of &apos;|&apos;, &apos;&amp;&apos; or &apos;^&apos;) is used to combine two compatible enumerations. The type of the result is considered to be the enumeration. This is considered a very minor deviation from the strict model and you may elect to suppress this warning.</description>
    </rule>
    <rule key="656">
        <name>L0656: Arithmetic operation uses (compatible) enum&apos;s</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An arithmetic operator (one of &apos;+&apos;, or &apos;-&apos;) is used to combine two compatible enumerations. The type of the result is considered to be the enumeration. This is considered a very minor deviation from the strict model and you may elect to suppress this warning.</description>
    </rule>
    <rule key="657">
        <name>L0657: Unusual (nonportable) anonymous struct or union</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A struct or union declaration without a declarator was taken to be anonymous. However, the anonymous union supported by C++ and other dialects of C require untagged union&apos;s. Tagged unions and tagged or untagged structs are rarely supported, as anonymous.</description>
    </rule>
    <rule key="658">
        <name>L0658: Anonymous union assumed (use flag +fan)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A union without a declarator was found. Was this an attempt to define an anonymous union? If so, anonymous unions should be activated with the +fan flag. This flag is activated automatically for C++.</description>
    </rule>
    <rule key="659">
        <name>L0659: Nothing follows &apos;}&apos; on line within struct/union/enum declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A struct/union/class/enum definition occurred and the closing &apos;}&apos; was not followed on the same line by another token. It looks suspicious. Missing semi-colons after such definitions can be a source of strange and mysterious messages. If you intentionally omitted the semi-colon then simply place the token which follows on the same line as the &apos;}&apos;. At the very least follow the &apos;}&apos; with a comment.</description>
    </rule>
    <rule key="660">
        <name>L0660: Option &apos;String&apos; requests removing an extent that is not on the list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A number of options use the &apos;-&apos; prefix to remove and &apos;+&apos; to add elements to a list. For example to add (the most unusual) extension .C++ to designate C++ processing of files bearing that extension, a programmer should employ the option: +cpp(.C++) However, if a leading &apos;-&apos; is employed (a natural mistake) this warning will be emitted.</description>
    </rule>
    <rule key="661">
        <name>L0661: possible access of out-of-bounds pointer (&apos;Integer&apos; beyond end of data) by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An out-of-bounds pointer may have been accessed. See message 415 for a description of the parameters Integer and String. For example: int a[10]; if( n &lt;= 10 ) a[n] = 0;
    Here the programmer presumably should have written n&lt;10. This message is similar to messages 415 and 796 but differs from them by the degree of probability.</description>
    </rule>
    <rule key="662">
        <name>L0662: possible creation of out-of-bounds pointer (&apos;Integer&apos; beyond end of data) by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An out-of-bounds pointer may have been created. See message 415 for a description of the parameters Integer and String. For example: int a[10]; if( n &lt;= 20 ) f( a + n );
    Here, it appears as though an illicit pointer is being created, but PC-lint/FlexeLint cannot be certain. See also messages 416 and 797.</description>
    </rule>
    <rule key="663">
        <name>L0663: Suspicious array to pointer conversion</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning occurs in the following kind of situation: struct x { int a; } y[2]; ... y-&gt;a ...
    Here, the programmer forgot to index the array but the error normally goes undetected because the array reference is automatically and implicitly converted to a pointer to the first element of the array. If you really mean to access the first element use y[0].a.</description>
    </rule>
    <rule key="664">
        <name>L0664: Left side of logical OR (||) or logical AND (&amp;&amp;) does not return</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An exiting function was found on the left hand side of an operator implying that the right hand side would never be executed. For example: if( (exit(0),n == 0) || n &gt; 2 ) ...
    Since the exit function does not return, control can never flow to the right hand operator.</description>
    </rule>
    <rule key="665">
        <name>L0665: Unparenthesized parameter Integer in macro &apos;Symbol&apos; is passed an expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression was passed to a macro parameter that was not parenthesized. For example: #define mult(a,b) (a*b) ... mult( 100, 4 + 10 )
    Here the programmer is beguiled into thinking that the 4+10 is taken as a quantity to be multiplied by 100 but instead results in: 100*4+10 which is quite different. The recommended remedy ([22, ?20.4]) is to parenthesize such parameters as in:
    #define mult(a,b) ((a)*(b))
    The message is not arbitrarily given for any unparenthesized parameter but only when the actual macro argument sufficiently resembles an expression and the expression involves binary operators. The priority of the operator is not considered except that it must have lower priority than the unary operators. The message is not issued at the point of macro definition because it may not be appropriate to parenthesize the parameter. For example, the following macro expects that an operator will be passed as argument. It would be an error to enclose op in parentheses.
    #define check(x,op,y) if( ((x) op (y)) == 0 ) print( ... )</description>
    </rule>
    <rule key="666">
        <name>L0666: Expression with side effects passed to repeated parameter Integer of macro &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A repeated parameter within a macro was passed an argument with side-effects. For example: #define ABS(x) ((x) &lt; 0 ? -(x) : (x))
    ... ABS( n++ )
    Although the ABS macro is correctly defined to specify the absolute value of its argument, the repeated use of the parameter x implies a repeated evaluation of the actual argument n++. This results in two increments to the variable n. [22, ?20.6] Any expression containing a function call is also considered to have side-effects.</description>
    </rule>
    <rule key="667">
        <name>L0667: Inconsistent use of qualifiers for symbol &apos;Symbol&apos; (type &apos;Type&apos; vs. &apos;Type&apos;) conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration for the identified Symbol is inconsistent with a prior declaration for the same symbol. There was a nominal difference in the declaration but owing to the memory model chosen there was no real difference. For example, in large model, one declaration declares external symbol alpha to be a far pointer and another declaration omits the memory model specification.</description>
    </rule>
    <rule key="668">
        <name>L0668: Possibly passing a null pointer to function &apos;Symbol&apos;, Context Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A NULL pointer is possibly being passed to a function identified by Symbol. The argument in question is given by Context. The function is either a library function designed not to receive a NULL pointer or a user function dubbed so via the option -function.</description>
    </rule>
    <rule key="669">
        <name>L0669: Possible data overrun for function &apos;Symbol&apos;, argument Integer exceeds argument Integer Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is for data transfer functions such as memcpy, strcpy, fgets, etc. when the size indicated by the first cited argument (or arguments) can possibly exceed the size of the buffer area cited by the second. The message may also be issued for user functions via the -function option.</description>
    </rule>
    <rule key="670">
        <name>L0670: Possible access beyond array for function &apos;Symbol&apos;, argument Integer exceeds Integer Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for several library functions (such as fwrite, memcmp, etc) wherein there is a possible attempt to access more data than exist. For example, if the length of data specified in the fwrite call exceeds the size of the data specified. The function is specified by Symbol and the arguments are identified by argument number.</description>
    </rule>
    <rule key="671">
        <name>L0671: Possibly passing to function &apos;Symbol&apos; a negative value (Integer), Context Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integral value that may possibly be negative is being passed to a function that is expecting only positive values for a particular argument. The message contains the name of the function (Symbol), the questionable value (Integer) and the argument number (Context). The function may be a standard library function designed to accept only positive values such as malloc or memcpy (third argument), or may have been identified by the user as such through the -function or -sem options. See message 422 for an example and further explanation.</description>
    </rule>
    <rule key="672">
        <name>L0672: Possible memory leak in assignment to pointer &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment was made to a pointer variable (designated by Symbol) which may already be holding the address of an allocated object which had not been freed. The allocation of memory which is not freed is considered a &apos;memory leak&apos;. The memory leak is considered &apos;possible&apos; because only some lines of flow will result in a leak.</description>
    </rule>
    <rule key="673">
        <name>L0673: Possibly inappropriate deallocation (Name1) for &apos;Name2&apos; data.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message indicates that a deallocation (free(), delete, or delete[]) as specified by String1 may be inappropriate for the data being freed. The kind of data is one or more of: malloc, new, new[], static, auto, member, modified or constant. The word &apos;Possibly&apos; is used in the message to indicate that only some of the lines of flow to the deallocation show data inconsistent with the allocation.</description>
    </rule>
    <rule key="674">
        <name>L0674: Returning address of auto through variable &apos;Symbol&apos;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The value held by a pointer variable contains the address of an auto variable. It is normally incorrect to return the address of an item on the stack because the portion of the stack allocated to the returning function is subject to being obliterated after return.</description>
    </rule>
    <rule key="675">
        <name>L0675: No prior semantics associated with &apos;Name&apos; in option &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The -function option is used to transfer semantics from its first argument to subsequent arguments. However it was found that the first argument Name did not have semantics.</description>
    </rule>
    <rule key="676">
        <name>L0676: Possibly negative subscript (Integer) in operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integer whose value was possibly negative was added to an array or to a pointer to an allocated area (allocated by malloc, operator new, etc.) This message is not given for pointers whose origin is unknown since a negative subscript is in general legal.</description>
    </rule>
    <rule key="677">
        <name>L0677: sizeof used within preprocessor statement.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Whereas the use of sizeof during preprocessing is supported by a number of compilers it is not a part of the ANSI C or C++ standard.</description>
    </rule>
    <rule key="678">
        <name>L0678: Member &apos;Symbol&apos; field length (Integer) too small for enum precision (Integer)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A bit field was found to be too small to support all the values of an enumeration (that was used as the base of the bit field). For example: enum color { red, green, yellow, blue }; struct abc { enum color c:2; };
    Here, the message is not given because the four enumeration values of color will just fit within 2 bits. However, if one additional color is inserted, Warning 678 will be issued informing the programmer of the undesirable and dangerous condition.</description>
    </rule>
    <rule key="679">
        <name>L0679: Suspicious Truncation in arithmetic expression combining with pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when it appears that there may have been an unintended loss of information during an operation involving integrals prior to combining with a pointer whose precision is greater than the integral expression. For example: //lint -sp8 pointers are 8 bytes //lint -si4 integers are 4 bytes char *f( char *p, int n, int m ) { return p + (n + m); // warning 679 }
    By the rules of C/C++, the addition n+m is performed independently of its context and is done at integer precision. Any overflow is ignored even though the larger precision of the pointer could easily accommodate the overflow. If, on the other hand the expression were: p+n+m, which parses as (p+n)+m, no warning would be issued.
    If the expression were p + n * m then, to suppress the warning, a cast is needed. If long were the same size as pointers you could use the expression:
    return p + ((long) n * m);</description>
    </rule>
    <rule key="680">
        <name>L0680: Suspicious Truncation in arithmetic expression converted to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An arithmetic expression was cast to pointer. Moreover, the size of the pointer is greater than the size of the expression. In computing the expression, any overflow would be lost even though the pointer type would be able to accommodate the lost information. To suppress the message, cast one of the operands to an integral type large enough to hold the pointer. Alternatively, if you are sure there is no problem you may cast the expression to an integral type before casting to pointer. See messages 647, 776, 790 and 679.</description>
    </rule>
    <rule key="681">
        <name>L0681: Loop is not entered</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The controlling expression for a loop (either the expression within a while clause or the second expression within a for clause) evaluates initially to 0 and so it appears as though the loop is never entered.</description>
    </rule>
    <rule key="682">
        <name>L0682: sizeof applied to a parameter &apos;Symbol&apos; whose type is a sized array</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If a parameter is typed as an array it is silently promoted to pointer. Taking the size of such an array will actually yield the size of a pointer. Consider, for example:
    unsigned f( char a[100] ) { return sizeof(a); }
    Here it looks as though function f() will return the value 100 but it will actually return the size of a pointer which is usually 4.</description>
    </rule>
    <rule key="683">
        <name>L0683: function &apos;Symbol&apos; #define&apos;d</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued whenever the name of a function with some semantic association is defined as a macro. For example:
    #define strlen mystrlen
    will raise this message. The problem is that the semantics defined for strlen will then be lost. Consider this message an alert to transfer semantics from strlen to mystrlen, using -function(strlen, mystrlen) The message will be issued for built-in functions (with built-in semantics) or for user-defined semantics. The message will not be issued if the function is defined to be a function with a similar name but with underscores either appended or prepended or both. For example:
    #define strlen __strlen
    will not produce this message. It will produce Info 828 instead.</description>
    </rule>
    <rule key="684">
        <name>L0684: Passing address of auto variable &apos;Symbol&apos; into caller space</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of an auto variable was passed via assignment into a location specified by the caller to the function. For example: void f( int *a[] ) { int n; a[1] = &amp;n; }
    Here the address of an auto variable (n) is being passed into the second element of the array passed to the function f. This looks suspicious because upon return the array will contain a pointer to a variable whose lifetime is over. It is possible that this is benign since it could be that the caller to f() is merely passing in a working space to be discarded upon return. If this is the case, you can suppress the message for function f() using the option
    -efunc(684,f).
    See also Warning 604.</description>
    </rule>
    <rule key="685">
        <name>L0685: Relational operator &apos;String,&apos; always evaluates to &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first String is one of &apos;&gt;&apos;, &apos;&gt;=&apos;, &apos;&lt;&apos; or &apos;&lt;=&apos; and identifies the relational operator. The second string is one of &apos;True&apos; or &apos;False,0&gt;&apos;. The message is given when an expression is compared to a constant and the precision of the expression indicates that the test will always succeed or always fail. For example, char ch; ... if( ch &gt;= -128 ) ...
    In this example, the precision of char ch is 8 bits signed (assuming the fcu flag has been left in the OFF state) and hence it has a range of values from -128 to 127 inclusive. Hence the test is always True.
    Note that, technically, ch is promoted to int before comparing with the constant. For the purpose of this comparison we consider only the underlying precision. As another example, if u is an unsigned int then
    if( (u &amp; 0xFF) &gt; 0xFF ) ...
    will also raise a 685 because the expression on the left hand side has an effective precision of 16 bits.</description>
    </rule>
    <rule key="686">
        <name>L0686: Option &apos;String&apos; is suspicious because of &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An option is considered suspicious for one of a variety of reasons. The reason is designated by a reason code that is specified by Name. At this writing, the only reason code is &apos;unbalanced quotes&apos;.</description>
    </rule>
    <rule key="687">
        <name>L0687: Suspicious use of comma operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A comma operator appeared unbraced and unparenthesized in a statement following an if, else, while or for clause. For example: if( n &gt; 0 ) n = 1, n = 2; Thus the comma could be mistaken for a semi-colon and hence be the source of subtle bugs.
    If the statement is enclosed in curly braces or if the expression is enclosed in parentheses, the message is not issued.</description>
    </rule>
    <rule key="688">
        <name>L0688: Cast used within a preprocessor conditional statement</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast was used within a preprocessor conditional statement such as #if or #elif. As an example you may have written: #define VERSION 11.3 ... #if (int) VERSION == 11 ... #endif Such casts are not allowed by the various C and C++ standards.</description>
    </rule>
    <rule key="689">
        <name>L0689: Apparent end of comment ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The pair of characters &apos;*/&apos; was found not within a comment. As an example: void f( void*/*comment*/ ); This is taken to be the equivalent of: void f( void* ); That is, an implied blank is inserted between the &apos;*&apos; and the &apos;/&apos;. To avoid this message simply place an explicit blank between the two characters.</description>
    </rule>
    <rule key="690">
        <name>L0690: Possible access of pointer pointing Integer bytes past nul character by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Accessing past the terminating nul character is often an indication of a programmer error. For example: char buf[20]; char c; strcpy( buf, &quot;a&quot; ); if( i &lt; 20 ) c = buf[i]; // legal but suspect. See also Warning 448 in Section 13.3 and Info 836 in Section 13.4</description>
    </rule>
    <rule key="691">
        <name>L0691: Suspicious use of backslash</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The backslash character has been used in a way that may produce unexpected results. Typically this would occur within a macro such as: #define A b \ // comment The coder might be thinking that the macro definition will be continued on to the next line. The standard indicates, however, that the newline will not be dropped in the event of an intervening comment. This should probably be recoded as: #define A b /* comment */ \</description>
    </rule>
    <rule key="692">
        <name>L0692: Decimal character &apos;Char&apos; follows octal escape sequence &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A String was found that contains an &apos;8&apos; or &apos;9&apos; after an octal escape sequence with no more than two octal digits, e.g. &quot;\079&quot; contains two characters: Octal seven (ASCII BEL) followed by &apos;9&apos;. The casual reader of the code (and perhaps even the programmer) could be fooled into thinking this is a single character. If this is what the programmer intended he can also render this as &quot;\07&quot; &quot;9&quot; so that there can be no misunderstanding.
    On the other hand, &quot;\1238&quot; will not raise a message because it is assumed that the programmer knows that octal escape sequences cannot exceed four characters (including the initial backslash).</description>
    </rule>
    <rule key="693">
        <name>L0693: Hexadecimal digit &apos;Char&apos; immediately after &apos;String&apos; is suspicious in string literal.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A String was found that looks suspiciously like (but is not) a hexadecimal escape sequence; rather, it is a null character followed by letter &quot;x&quot; followed by some hexadecimal digit, e.g.: &quot;\0x62&quot; was found where the programmer probably meant to type &quot;\x62&quot;. If you need precisely this sequence you can use: &quot;\0&quot; &quot;x62&quot; and this warning will not be issued.</description>
    </rule>
    <rule key="694">
        <name>L0694: The type of constant &apos;String&apos; (precision Integer) is dialect dependent</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A decimal integer constant that requires all the bits of an unsigned long for its representation has a type that depends on the dialect of C or C++ implemented by the compiler you are using. For example, the constant 3000000000 requires 32 bits for its representation. If longs are 32 bits, then the constant is judged to be unsigned long in C90, long long in C99 and undefined in C++.
    You can remove the ambiguity by applying a clarifying suffix. If you intend this to be unsigned use the &apos;U&apos; suffix. If you intend this to be a long long use the &apos;LL&apos; suffix. If the latter and you are using C++ then turn on the +fll flag.</description>
    </rule>
    <rule key="695">
        <name>L0695: Inline function &apos;Symbol&apos; defined without a storage-class specifier (&apos;static&apos; recommended)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In C99, the result of a call to a function declared with &apos;inline&apos; but not &apos;static&apos; or &apos;extern&apos; is unspecified.
    Example: Let the following text represent two translation units: /* In module_1.c */ void f() {}
    /* In module_2.c */ inline void f() {} void g() { f(); } /* which f() is called? */ The C99 Standard dictates that the above call to f() from g() in module_2.c may result in the execution of either f().
    The programmer may avoid confusion and improve portability by using the keyword &apos;static&apos; in addition to &apos;inline&apos;. The keyword &apos;extern&apos; can also be used along with the &apos;inline&apos; to resolve this ambiguity; however, we recommend using &apos;static&apos; because, as of this writing, more compilers correctly interpret &apos;static inline&apos;.</description>
    </rule>
    <rule key="696">
        <name>L0696: Variable &apos;Symbol&apos; has value &apos;String&apos; that is out of range for operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The variable cited in the message is being compared (using one of the 6 comparison operations) with some other expression called the comperand. The variable has a value that is out of the range of values of this comperand. For example consider: void f( unsigned char ch ) { int n = 1000; if( ch &lt; n ) // Message 696 ... Here a message 696 will be issued stating that n has a value of 1000 that is out of range because 1000 is not in the set of values that ch can hold (assuming default sizes of scalars).</description>
    </rule>
    <rule key="697">
        <name>L0697: Quasi-boolean values should be equality-compared only with 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A quasi-boolean value is being compared (using either != or ==) with a value that is not the literal zero. A quasi-boolean value is any value whose type is a strong boolean type and that could conceivably be something other than zero or one. This is significant because in C, all non-zero values are equally true. Example: /*lint -strong(AJXb, B) */ typedef int B; #define YES ((B)1) #define NO ((B)0)
    B f( B a, B b ) { B c = ( a == NO ); /* OK, no Warning here */ B d = ( a == (b != NO) ); /* Warning 697 for == but not for != */ B e = ( a == YES ); /* Warning 697 here */ return d == c; /* Warning 697 here */ } Note that if a and b had instead been declared with true boolean types, such as &apos;bool&apos; in C++ or &apos;_Bool&apos; in C99, this diagnostic would not have been issued.</description>
    </rule>
    <rule key="698">
        <name>L0698: Casual use of realloc can create a memory leak</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A statement of the form: v = realloc( v, ... ); has been detected. Note the repeated use of the same variable. The problem is that realloc can fail to allocate the necessary storage. In so doing it will return NULL. But then the original value of v is overwritten resulting in a memory leak.</description>
    </rule>
    <rule key="701">
        <name>L0701: Shift left of signed quantity (int)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Shifts are normally accomplished on unsigned operands.</description>
    </rule>
    <rule key="702">
        <name>L0702: Shift right of signed quantity (int)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Shifts are normally accomplished on unsigned operands. Shifting an int right is machine dependent (sign fill vs. zero fill).</description>
    </rule>
    <rule key="703">
        <name>L0703: Shift left of signed quantity (long)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Shifts are normally accomplished on unsigned operands.</description>
    </rule>
    <rule key="704">
        <name>L0704: Shift right of signed quantity (long)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Shifts are normally accomplished on unsigned operands. Shifting a long right is machine dependent (sign fill vs. zero fill).</description>
    </rule>
    <rule key="705">
        <name>L0705: Argument no. Integer nominally inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The argument to a printf (or fprintf or sprintf) was nominally inconsistent with the format. Although the size of the quantity was appropriate the type was similar, but not exact. (E.g., passing a long to a %d or an int to a %x) You might consider casting the quantity to the correct type. You could also suppress this message, as more flagrant violations are picked up with warnings 559 and 626.</description>
    </rule>
    <rule key="706">
        <name>L0706: (arg. no. Integer) indirect object inconsistent with format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The type of an argument to scanf (or fscanf or sscanf) was inappropriate to the format. However, the argument was a pointer and it pointed to a quantity of the expected size and similar, but not expected type.</description>
    </rule>
    <rule key="707">
        <name>L0707: Mixing narrow and wide string literals in concatenation.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The following is an example of a mixing of narrow and wide string literals. const wchar_t *s = &quot;abc&quot; L&quot;def&quot;; The concatenation of narrow and wide string literals results in undefined behavior for C90 and C++2003. If your compiler supports such combinations or you use a C/C++ dialect that supports such, you may either suppress this message or consider making the concatenands match.</description>
    </rule>
    <rule key="708">
        <name>L0708: union initialization</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There was an attempt to initialize the value of a union. This may not be permitted in some older C compilers. This is because of the apparent ambiguity: which member should be initialized. The standard interpretation is to apply the initialization to the first subtype of the union.</description>
    </rule>
    <rule key="712">
        <name>L0712: Loss of precision (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) is being made between two integral quantities in which the first Type is larger than the second Type. A cast will suppress this message.</description>
    </rule>
    <rule key="713">
        <name>L0713: Loss of precision (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) is being made from an unsigned quantity to a signed quantity, that will result in the possible loss of one bit of integral precision such as converting from unsigned int to int. A cast will suppress the message.</description>
    </rule>
    <rule key="714">
        <name>L0714: Symbol &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named external variable or external function was defined but not referenced. This message is suppressed for unit checkout (-u option).</description>
    </rule>
    <rule key="715">
        <name>L0715: Symbol &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named formal parameter was not referenced.</description>
    </rule>
    <rule key="716">
        <name>L0716: while(1) ...</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A construct of the form while(1) ... was found. Whereas this represents a constant in a context expecting a Boolean, it may reflect a programming policy whereby infinite loops are prefixed with this construct. Hence it is given a separate number and has been placed in the informational category. The more conventional form of infinite loop prefix is for(;;).</description>
    </rule>
    <rule key="717">
        <name>L0717: do ... while(0)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Whereas this represents a constant in a context expecting a Boolean, this construct is probably a deliberate attempt on the part of the programmer to encapsulate a sequence of statements into a single statement, and so it is given a separate error message. [22, ?20.7] For example:
    #define f(k) do {n=k; m=n+1;} while(0)
    allows f(k) to be used in conditional statements as in
    if(n&gt;0) f(3); else f(2);
    Thus, if you are doing this deliberately use -e717</description>
    </rule>
    <rule key="718">
        <name>L0718: Symbol &apos;Symbol&apos; undeclared, assumed to return int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function was referenced without (or before) it had been declared or defined within the current module. This is not necessarily an error and you may want to suppress such messages. Note that by adding a declaration to another module, you will not suppress this message. It can only be suppressed by placing a declaration within the module being processed.</description>
    </rule>
    <rule key="719">
        <name>L0719: Too many arguments for format (Integer too many)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The number of arguments to a function in the printf/scanf family was more than what is specified in the format. This message is similar to Warning 558 which alerts users to situations in which there were too few arguments for the format. It receives a lighter Informational classification because the additional arguments are simply ignored.</description>
    </rule>
    <rule key="720">
        <name>L0720: Boolean test of assignment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment was found in a context that requires a Boolean (such as in an if() or while() clause or as an operand to &amp;&amp; or ||). This may be legitimate or it could have resulted from a mistaken use of = for ==.</description>
    </rule>
    <rule key="721">
        <name>L0721: Suspicious use of ;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A semi-colon was found immediately to the right of a right parenthesis in a construct of the form if(e);. As such it may be overlooked or confused with the use of semi-colons to terminate statements. The message will be inhibited if the &apos;;&apos; is separated by at least one blank from the &apos;)&apos;. Better, place it on a separate line. See also message 548.</description>
    </rule>
    <rule key="722">
        <name>L0722: Suspicious use of ;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A semi-colon was found immediately to the right of a right parenthesis in a construct of the form while(e); or for(e;e;e);. As such it may be overlooked or confused with the use of semi-colons to terminate statements. The message will be inhibited if the &apos;;&apos; is separated by at least one blank from the &apos;)&apos;. Better, place it on a separate line.</description>
    </rule>
    <rule key="723">
        <name>L0723: Suspicious use of =</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A preprocessor definition began with an = sign. For example:
    #define LIMIT = 50
    Was this intentional? Or was the programmer thinking of assignment when he wrote this?</description>
    </rule>
    <rule key="725">
        <name>L0725: Expected positive indentation from Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The current line was found to be aligned with, rather than indented with respect to, the indicated line. The indicated line corresponds to a clause introducing a control structure and statements within its scope are expected to be indented with respect to it. If tabs within your program are other than 8 blanks you should use the -t option.</description>
    </rule>
    <rule key="726">
        <name>L0726: Extraneous comma ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A comma followed by a right-brace within an enumeration is not a valid ANSI construct. The comma is ignored.</description>
    </rule>
    <rule key="727">
        <name>L0727: Symbol &apos;Symbol&apos; (Location) not explicitly initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named static variable (local to a function) was not explicitly initialized prior to use. The following remarks apply to messages 728 and 729 as well as 727. By no explicit initialization we mean that there was no initializer present in the definition of the object, no direct assignment to the object, and no address operator applied to the object or, if the address of the object was taken, it was assigned to a pointer to const. These messages do not necessarily signal errors since the implicit initialization for static variables is 0. However, the messages are helpful in indicating those variables that you had forgotten to initialize to a value. To extract the maximum benefit from the messages we suggest that you employ an explicit initializer for those variables that you want to initialize to 0. For example:
    static int n = 0;
    For variables that will be initialized dynamically, do not use an explicit initializer as in:
    static int m;
    This message will be given for any array, struct or union if no member or element has been assigned a value.</description>
    </rule>
    <rule key="728">
        <name>L0728: Symbol &apos;Symbol&apos; (Location) not explicitly initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named intra-module variable (static variable with file scope) was not explicitly initialized. See the comments on message 727 for more details.</description>
    </rule>
    <rule key="729">
        <name>L0729: Symbol &apos;Symbol&apos; (Location) not explicitly initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named inter-module variable (external variable) was not explicitly initialized. See the comments on message 727 for more details. This message is suppressed for unit checkout (-u).</description>
    </rule>
    <rule key="730">
        <name>L0730: Boolean argument to function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A Boolean was used as an argument to a function. Was this intended? Or was the programmer confused by a particularly complex conditional statement. Experienced C programmers often suppress this message. This message is given only if the associated parameter is not declared bool.</description>
    </rule>
    <rule key="731">
        <name>L0731: Boolean argument to equal/not equal</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A Boolean was used as an argument to == or !=. For example:
    if( (a &gt; b) == (c &gt; d) ) ...
    tests to see if the inequalities are of the same value. This could be an error as it is an unusual use of a Boolean (see Warnings 503 and 514) but it may also be deliberate since this is the only way to efficiently achieve equivalence or exclusive or. Because of this possible use, the construct is given a relatively mild &apos;informational&apos; classification. If the Boolean argument is cast to some type, this message is not given.</description>
    </rule>
    <rule key="732">
        <name>L0732: Loss of sign (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) is made from a signed quantity to an unsigned quantity. Also, it could not be determined that the signed quantity had no sign. For example:
    u = n; /* Info 732 */ u = 4; /* OK */
    where u is unsigned and n is not, warrants a message only for the first assignment, even though the constant 4 is nominally a signed int.
    Make sure that this is not an error (that the assigned value is never negative) and then use a cast (to unsigned) to remove the message.</description>
    </rule>
    <rule key="733">
        <name>L0733: Assigning address of auto variable &apos;Symbol&apos; to outer scope symbol &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of an auto variable is only valid within the block in which the variable is declared. An address to such a variable has been assigned to a variable that has a longer life expectancy. There is an inherent danger in doing this.</description>
    </rule>
    <rule key="734">
        <name>L0734: Loss of precision (Context) (Integer bits to Integer bits)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment is being made into an object smaller than an int. The information being assigned is derived from another object or combination of objects in such a way that information could potentially be lost. The number of bits given does not count the sign bit. For example if ch is a char and n is an int then:
    ch = n;
    will trigger this message whereas:
    ch = n &amp; 1;
    will not. To suppress the message a cast can be made as in:
    ch = (char) n;
    You may receive notices involving multiplication and shift operators with subinteger variables. For example:
    ch = ch &lt;&lt; 2 ch = ch * ch
    where, for example, ch is an unsigned char. These can be suppressed by using the flag +fpm (precision of an operator is bound by the maximum of its operands).</description>
    </rule>
    <rule key="735">
        <name>L0735: Loss of precision (Context) (Integer bits to Integer bits)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) is made from a long double to a double. Using a cast will suppress the message. The number of bits includes the sign bit.</description>
    </rule>
    <rule key="736">
        <name>L0736: Loss of precision (Context) (Integer bits to Integer bits)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment (or implied assignment, see Context) is being made to a float from a value or combination of values that appear to have higher precision than a float. You may suppress this message by using a cast. The number of bits includes the sign bit.</description>
    </rule>
    <rule key="737">
        <name>L0737: Loss of sign in promotion from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An unsigned quantity was joined with a signed quantity in a binary operator (or 2nd and 3rd arguments to the conditional operator ? :) and the signed quantity is implicitly converted to unsigned. The message will not be given if the signed quantity is an unsigned constant, a Boolean, or an expression involving bit manipulation. For example,
    u &amp; ~0xFF
    where u is unsigned does not draw the message even though the operand on the right is technically a signed integer constant. It looks enough like an unsigned to warrant not giving the message.
    This mixed mode operation could also draw Warnings 573 or 574 depending upon which operator is involved.
    You may suppress the message with a cast but you should first determine whether the signed value could ever be negative or whether the unsigned value can fit within the constraints of a signed quantity.</description>
    </rule>
    <rule key="738">
        <name>L0738: Symbol &apos;Symbol&apos; (Location) not explicitly initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named static local variable was not initialized before being passed to a function whose corresponding parameter is declared as pointer to const. Is this an error or is the programmer relying on the default initialization of 0 for all static items. By employing an explicit initializer you will suppress this message. See also message numbers 727 and 603.</description>
    </rule>
    <rule key="739">
        <name>L0739: Trigraph Sequence &apos;String&apos; in literal (Quiet Change)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated Trigraph (three-character) sequence was found within a string. This trigraph reduces to a single character according to the ANSI standard. This represents a &quot;Quiet Change&quot; from the past where the sequence was not treated as exceptional. If you had no intention of mapping these characters into a single character you may precede the initial &apos;?&apos; with a backslash. If you are aware of the convention and you intend that the Trigraph be converted you should suppress this informational message.</description>
    </rule>
    <rule key="740">
        <name>L0740: Unusual pointer cast (incompatible indirect types)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to convert one pointer to another such that neither of the pointers is a generic pointer (neither is pointer to char, unsigned char, or void) and the indirect types are truly different. The message will not be given if the indirect types differ merely in signedness (e.g., pointer to unsigned versus pointer to int) or in qualification (e.g., pointer to const int versus pointer to int). The message will also not be given if one of the indirect types is a union.
    The main purpose of this message is to report possible problems for machines in which pointer to char is rendered differently from pointer to word. Consider casting a pointer to pointer to char to a pointer to pointer to word. The indirect bit pattern remains unchanged.
    A second reason is to identify those pointer casts in which the indirect type doesn&apos;t seem to have the proper bit pattern such as casting from a pointer to int to a pointer to double.
    If you are not interested in running on machines in which char pointers are fundamentally different from other pointers then you may want to suppress this message. You can also suppress this message by first casting to char pointer or to void pointer but this is only recommended if the underlying semantics are right.</description>
    </rule>
    <rule key="741">
        <name>L0741: Unusual pointer cast (function qualification)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made between two pointers such that their indirect types differ in one of the Microsoft qualifiers: pascal, fortran, cdecl and interrupt. If this is not an error you may cast to a more neutral pointer first such as a void *.</description>
    </rule>
    <rule key="742">
        <name>L0742: Multiple character constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A character constant was found that contained multiple characters, e.g., &apos;ab&apos;. This is legal C but the numeric value of the constant is implementation defined. It may be safe to suppress this message because, if more characters are provided than what can fit in an int, message number 25 is given.</description>
    </rule>
    <rule key="743">
        <name>L0743: Negative character constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A character constant was specified whose value is some negative integer. For example, on machines where a byte is 8 bits, the character constant &apos;\xFF&apos; is flagged because its value (according to the ANSI standard) is -1 (its type is int). Note that its value is not 0xFF.</description>
    </rule>
    <rule key="744">
        <name>L0744: switch statement has no default</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A switch statement has no section labeled default:. Was this an oversight? It is standard practice in many programming groups to always have a default: case. This can lead to better (and earlier) error detection. One way to suppress this message is by introducing a vacuous default: break; statement. If you think this adds too much overhead to your program, think again. In all cases tested so far, the introduction of this statement added absolutely nothing to the overall length of code. If you accompany the vacuous statement with a suitable comment, your code will at least be more readable.
    This message is not given if the control expression is an enumerated type. In this case, all enumerated constants are expected to be represented by case statements, else 787 will be issued.</description>
    </rule>
    <rule key="745">
        <name>L0745: function &apos;Name&apos; has no explicit type or class, int assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declaration or definition contained no explicit type. Was this deliberate?</description>
    </rule>
    <rule key="746">
        <name>L0746: call to function &apos;Name&apos; not made in the presence of a prototype</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to a function is not made in the presence of a prototype. This does not mean that PC-lint/FlexeLint is unaware of any prototype; it means that a prototype is not in a position for a compiler to see it. If you have not adopted a strict prototyping convention you will want to suppress this message with -e746.</description>
    </rule>
    <rule key="747">
        <name>L0747: Significant prototype coercion (Context) Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The type specified in the prototype differed from the type provided as an argument in some significant way. Usually the two types are arithmetic of differing sizes or one is float and the other integral. This is flagged because if the program were to be translated by a compiler that does not support prototype conversion, the conversion would not be performed.</description>
    </rule>
    <rule key="748">
        <name>L0748: Symbol &apos;Symbol&apos; (Location) is a register variable used with setjmp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named variable is a register variable and is used within a function that calls upon setjmp. When a subsequent longjmp is issued the values of register variables may be unpredictable. If this error is not suppressed for this variable, the variable is marked as uninitialized at this point in the program.</description>
    </rule>
    <rule key="749">
        <name>L0749: local enumeration constant &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member (name provided as Symbol) of an enum was defined in a module but was not otherwise used within that module. A &apos;local&apos; member is one that is not defined in a header file. Compare with messages 754 and 769.</description>
    </rule>
    <rule key="750">
        <name>L0750: local macro &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;local&apos; macro is one that is not defined in a header file. The macro was not referenced throughout the module in which it is defined.</description>
    </rule>
    <rule key="751">
        <name>L0751: local typedef &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;local&apos; typedef symbol is one that is not defined in any header file. It may have file scope or block scope but it was not used through its scope.</description>
    </rule>
    <rule key="752">
        <name>L0752: local declarator &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;local&apos; declarator symbol is one declared in a declaration which appeared in the module file itself as opposed to a header file. The symbol may have file scope or may have block scope. But it wasn&apos;t referenced.</description>
    </rule>
    <rule key="753">
        <name>L0753: local struct, union or enum tag &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;local&apos; tag is one not defined in a header file. Since its definition appeared, why was it not used? Use of a tag is implied by the use of any of its members.</description>
    </rule>
    <rule key="754">
        <name>L0754: local structure member &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member (name provided as Symbol) of a struct or union was defined in a module but was not otherwise used within that module. A &apos;local&apos; member is one that is not defined in a header file. See message 768.</description>
    </rule>
    <rule key="755">
        <name>L0755: global macro &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;global&apos; macro is one defined in a header file. This message is given for macros defined in non-library headers. The macro is not used in any of the modules comprising the program. This message is suppressed for unit checkout (-u option).</description>
    </rule>
    <rule key="756">
        <name>L0756: global typedef &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for a typedef symbol declared in a non-library header file. The symbol is not used in any of the modules comprising a program. This message is suppressed for unit checkout (-u option).</description>
    </rule>
    <rule key="757">
        <name>L0757: global declarator &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for objects that have been declared in non-library header files and that have not been used in any module comprising the program being checked. The message is suppressed for unit checkout (-u).</description>
    </rule>
    <rule key="758">
        <name>L0758: global struct, union or enum tag &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for struct, union and enum tags that have been defined in non-library header files and that have not been used in any module comprising the program. The message is suppressed for unit checkout (-u).</description>
    </rule>
    <rule key="759">
        <name>L0759: header declaration for symbol &apos;Symbol&apos; (Location) could be moved from header to module</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for declarations, within non-library header files, that are not referenced outside the defining module. Hence, it can be moved inside the module and thereby &apos;lighten the load&apos; on all modules using the header. This message is only given when more than one module is being linted.</description>
    </rule>
    <rule key="760">
        <name>L0760: Redundant macro &apos;Symbol&apos; defined identically at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given macro was defined earlier (location given) in the same way and is hence redundant.</description>
    </rule>
    <rule key="761">
        <name>L0761: Redundant typedef &apos;Symbol&apos; previously declared at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A typedef symbol has been typedefed earlier at the given location. Although the declarations are consistent you should probably remove the second.</description>
    </rule>
    <rule key="762">
        <name>L0762: Redundantly declared symbol &apos;Symbol&apos; previously declared at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration for the given symbol was found to be consistent with an earlier declaration in the same scope. This declaration adds nothing new and it can be removed.</description>
    </rule>
    <rule key="763">
        <name>L0763: Redundant declaration for symbol &apos;Symbol&apos; previously declared at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A tag for a struct, union or enum was defined twice in the same module (consistently). The second one can be removed.</description>
    </rule>
    <rule key="764">
        <name>L0764: switch statement does not have a case</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A switch statement has been found that does not have a case statement associated with it (it may or may not have a default statement). This is normally a useless construct.</description>
    </rule>
    <rule key="765">
        <name>L0765: external &apos;Symbol&apos; (Location) could be made static</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An external symbol was referenced in only one module. It was not declared static (and its type is not qualified with the Microsoft keyword __export). Some programmers like to make static every symbol they can, because this lightens the load on the linker. It also represents good documentation. On the other hand, you may want the symbol to remain external because debuggers often work only on external names. It&apos;s possible, using macros, to have the best of both worlds.</description>
    </rule>
    <rule key="766">
        <name>L0766: Header file FileName not used in module String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named header file was directly #include&apos;d in the named module but the #include can be removed because it was not used in processing the named module or in any header included by the module. It contained no macro, typedef, struct, union or enum tag or component, or declaration referenced by the module. One of the reasons a particular #include can be removed is because it had been included by an earlier header file. Warning 537 can be used to detect such cases.</description>
    </rule>
    <rule key="767">
        <name>L0767: macro &apos;Symbol&apos; was defined differently in another module (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two macros processed in two different modules had inconsistent definitions.</description>
    </rule>
    <rule key="768">
        <name>L0768: vglobal struct member &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member (name provided as Symbol) of a struct or union appeared in a non-library header file but was not used in any module comprising the program. This message is suppressed for unit checkout. Since struct&apos;s may be replicated in storage, finding an unused member can pay handsome storage dividends. However, many structures merely reflect an agreed upon convention for accessing storage and for any one program many members are unused. In this case, receiving this message can be a nuisance. One convenient way to avoid unwanted messages (other than the usual -e and -esym) is to always place such structures in library header files. Alternatively, you can place the struct within a ++flb ... --flb sandwich to force it to be considered library.</description>
    </rule>
    <rule key="769">
        <name>L0769: global enumeration constant &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member (name provided as Symbol) of an enum appeared in a non-library header file but was not used in any module comprising the program. This message is suppressed for unit checkout. There are reasons why a programmer may occasionally want to retain an unused enum and for this reason this message is distinguished from 768 (unused member). See message 768 for ways of selectively suppressing this message.</description>
    </rule>
    <rule key="770">
        <name>L0770: tag &apos;Symbol&apos; defined identically at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The struct, union, or enum tag Symbol was defined identically in different locations (usually two different files). This is not an error but it is not necessarily good programming practice either. It is better to place common definitions of this kind in a header file where they can be shared among several modules. If you do this, you will not get this message. Note that if the tag is defined differently in different scopes, you will receive warning 631 rather than this message.</description>
    </rule>
    <rule key="771">
        <name>L0771: Symbol &apos;Symbol&apos; (Location) conceivably not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named symbol, declared at Location, was initialized in the main portion of a control loop (while, for, or do) and subsequently used outside the loop. If it is possible for the main body of the loop to not be fully executed, then the given symbol would remain uninitialized resulting in an error.
    PC-lint/FlexeLint does not do a great job of evaluating expressions and hence may not recognize that a loop is executed at least once. This is particularly true after initializing an array. Satisfy yourself that the loop is executed and then suppress the message. You may wish to suppress the message globally with -e771 or just for specific symbols using -esym. Don&apos;t forget that a simple assignment statement may be all that&apos;s needed to suppress the message.</description>
    </rule>
    <rule key="772">
        <name>L0772: Symbol &apos;Symbol&apos; (Location) conceivably not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of the named Symbol was passed to a function expecting to receive a pointer to a const item. This requires the Symbol to have been initialized. See Warning 603 for an explanation of the dangers of such a construct. See Informational message 771 for an explanation of &quot;conceivably not initialized.&quot;</description>
    </rule>
    <rule key="773">
        <name>L0773: Expression-like macro &apos;Symbol&apos; not parenthesized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A macro that appeared to be an expression contained unparenthesized binary operators and therefore may result in unexpected associations when used with other operators. For example,
    #define A B + 1
    may be used later in the context:
    f( A * 2 );
    with the surprising result that B+2 gets passed to f and not the (B+1)*2 corrective action is to define A as:
    #define A (B + 1)
    Lowest precedence binary operators are not reported upon. Thus:
    #define A s.x
    does not elicit this message because this case does not seem to represent a problem. Also, unparenthesized unary operators (including casts) do not generate this message. Information about such unparenthesized parameters can be found by enabling Elective Note 973. [22, ?20.5]</description>
    </rule>
    <rule key="774">
        <name>L0774: Boolean within &apos;String&apos; always evaluates to [True/False]</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated clause (String is one of if, while or for (2nd expression)) has an argument that appears to always evaluate to either &apos;True&apos; or &apos;False&apos; (as indicated in the message). Information is gleaned from a variety of sources including prior assignment statements and initializers. Compare this with message 506 which is based on testing constants or combinations of constants. Also compare with the Elective Note 944 which can sometimes provide more detailed information.</description>
    </rule>
    <rule key="775">
        <name>L0775: non-negative quantity cannot be less than zero</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-negative quantity is being compared for being &lt;=0. This is a little suspicious since a non-negative quantity can be equal to 0 but never less than 0. The non-negative quantity may be of type unsigned or may have been promoted from an unsigned type or may have been judged not to have a sign by virtue of it having been AND&apos;ed with a quantity known not to have a sign bit an enum that may not be negative, etc. See also Warning 568.</description>
    </rule>
    <rule key="776">
        <name>L0776: Possible truncation of addition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An int expression (signed or unsigned) involving addition or subtraction is converted to long implicitly or explicitly. Moreover, the precision of a long is greater than that of int. If an overflow occurred, information would be lost. Either cast one of the operands to some form of long or cast the result to some form of int.
    See Warning 647 for a further description and an example of this kind of error. See also 790 and 942.</description>
    </rule>
    <rule key="777">
        <name>L0777: Testing float&apos;s for equality</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when the operands of operators == and != are some form of floating type (float, double, or long double). Testing for equality between two floating point quantities is suspect because of round-off error and the lack of perfect representation of fractions. If your numerical algorithm calls for such testing turn the message off. The message is suppressed when one of the operands can be represented exactly, such as 0 or 13.5.</description>
    </rule>
    <rule key="778">
        <name>L0778: Constant expression evaluates to 0 in operation: String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constant expression involving addition, subtraction, multiplication, shifting, or negation resulted in a 0. This could be a purposeful computation but could also have been unintended. If this is intentional, suppress the message. If one of the operands is 0 Elective Note 941 may be issued rather than a 778.</description>
    </rule>
    <rule key="779">
        <name>L0779: String constant in comparison operator: Operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A string constant appeared as an argument to a comparison operator. For example:
    if( s == &quot;abc&quot; ) ...
    This is usually an error. Did the programmer intend to use strcmp? It certainly looks suspicious. At the very least, any such comparison is bound to be machine-dependent. If you cast the string constant, the message is suppressed.</description>
    </rule>
    <rule key="780">
        <name>L0780: Vacuous array element</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration of an array looks suspicious because the array element is an array of 0 dimension. For example:
    extern int a[][]; extern int a[10][];
    will both emit this message but
    extern int a[][10];
    will not. In the latter case, proper array accessing will take place even though the outermost dimension is missing.
    If extern were omitted, the construct would be given a more serious error message.</description>
    </rule>
    <rule key="782">
        <name>L0782: Line exceeds Integer characters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An internal limit on the size of the input buffer has been reached. The message contains the maximum permissible size. This does not necessarily mean that the input will be processed erroneously. Additional characters will be read on a subsequent read. However the line sequence numbers reported on messages will be incorrect.</description>
    </rule>
    <rule key="783">
        <name>L0783: Line does not end with new-line</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when an input line is not terminated by a new-line or when a NUL character appears within an input line. When input lines are read, an fgets is used. A strlen call is made to determine the number of characters read. If the new-line character is not seen at the presumed end, this message is issued. If your editor is in the habit of not appending new-lines onto the end of the last line of the file then suppress this message. Otherwise, examine the file for NUL characters and eliminate them.</description>
    </rule>
    <rule key="784">
        <name>L0784: Nul character truncated from string</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>During initialization of an array with a string constant there was not enough room to hold the trailing NUL character. For example:
    char a[3] = &quot;abc&quot;;
    would evoke such a message. This may not be an error since the easiest way to do this initialization is in the manner indicated. It is more convenient than: char a[3] = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; };
    On the other hand, if it really is an error it may be especially difficult to find.</description>
    </rule>
    <rule key="785">
        <name>L0785: Too few initializers for aggregate &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The number of initializers in a brace-enclosed initializer was less than the number of items in the aggregate. Default initialization is taken. An exception is made with the initializer {0}. This is given a separate message number in the Elective Note category (943). It is normally considered to be simply a stylized way of initializing all members to 0.</description>
    </rule>
    <rule key="786">
        <name>L0786: String concatenation within initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Although it is perfectly &apos;legal&apos; to concatenate string constants within an initializer, this is a frequent source of error. Consider:
    char *s[] = { &quot;abc&quot; &quot;def&quot; };
    Did the programmer intend to have an array of two strings but forget the comma separator? Or was a single string intended?</description>
    </rule>
    <rule key="787">
        <name>L0787: enum constant &apos;Symbol&apos; not used within switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A switch expression is an enumerated type and at least one of the enumerated constants was not present as a case label. Moreover, no default case was provided.</description>
    </rule>
    <rule key="788">
        <name>L0788: enum constant &apos;Symbol&apos; not used within defaulted switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A switch expression is an enumerated type and at least one of the enumerated constants was not present as a case label. However, unlike Info 787, a default case was provided. This is a mild form of the case reported by Info 787. The user may thus elect to inhibit this mild form while retaining Info 787.</description>
    </rule>
    <rule key="789">
        <name>L0789: Assigning address of auto variable &apos;Symbol&apos; to static</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of an auto variable (Symbol) is being assigned to a static variable. This is dangerous because the static variable will persist after return from the function in which the auto is declared but the auto will be, in theory, gone. This can prove to be among the hardest bugs to find. If you have one of these, make certain there is no error and use -esym to suppress the message for a particular variable.</description>
    </rule>
    <rule key="790">
        <name>L0790: Suspicious truncation, integral to float.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when it appears that there may have been an unintended loss of information during an operation involving integrals the result of which is later converted to a floating point quantity. The operations that are scrutinized and reported upon by this message are: shift left and multiplication. Addition and subtraction are covered by Elective Note 942. See also 647 and 776.</description>
    </rule>
    <rule key="791">
        <name>L0791: unusual option sequence</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A temporary message suppression option (one having the form: !e...) followed a regular option. Was this intended?</description>
    </rule>
    <rule key="792">
        <name>L0792: void cast of void expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A void expression has been cast to void. Was this intended?</description>
    </rule>
    <rule key="793">
        <name>L0793: ANSI limit of String &apos;String&apos; &apos;Name&apos; exceeded -- processing is unaffected</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some ANSI limit has been exceeded. These limits are described in Section 2.2.4.1 of the ANSI C Standard. Programs exceeding these limits are not considered maximally portable. However, they may work for individual compilers.
    Many large programs exceed the ANSI limit of 511 external identifiers. This will result in message 793 &quot;ANSI limit of 511 &apos;external identifiers&apos; exceeded&quot;. It may not be obvious how to inhibit this message for identifiers while leaving other limits in a reportable state. The second parameter of the message is designated Name and so the -esym may be used. Because the symbol contains a blank, quotes must be used. The option becomes:
    -&quot;esym(793,external identifiers)&quot;</description>
    </rule>
    <rule key="794">
        <name>L0794: Conceivable use of null pointer &apos;Symbol&apos; in [left/right] argument to operator &apos;String&apos; Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>From information gleaned from earlier statements it is conceivable that a null pointer (a pointer whose value is 0) can be used in a context where null pointers are inappropriate. In the case of binary operators one of the words &apos;left&apos; or &apos;right&apos; is used to designate which operand is null. Symbol identifies the pointer variable that may be NULL. This is similar to messages 413 and 613 and differs from them in that the likelihood is not as great. For example: int *p = 0; int i; for( i = 0; i &lt; n; i++ ) p = &amp;a[i]; *p = 0;
    If the body of the for loop is never taken then p remains null.</description>
    </rule>
    <rule key="795">
        <name>L0795: Conceivable division by 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a division or modulus operation the division is deduced to be conceivably 0.</description>
    </rule>
    <rule key="796">
        <name>L0796: Conceivable access of out-of-bounds pointer (&apos;Integer&apos; beyond end of data) by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An out-of-bounds pointer may conceivably have been accessed. See message 415 for a description of the parameters Integer and String. For example: int a[10]; int j = 100; for( i = 0; i &lt; n; i++ ) j = n; a[j] = 0;
    Here, the access to a[j] is flagged because it is conceivable that the for loop is not executed leaving the unacceptable index of 100 in variable j. This message is similar to messages 415 and 661 but differing from them by the degree of probability.</description>
    </rule>
    <rule key="797">
        <name>L0797: Conceivable creation of out-of-bounds pointer (&apos;Integer&apos; beyond end of data) by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An out-of-bounds pointer is potentially being created. See message 415 for a description of the parameters Integer and String. See message 796 for an example of how a probability can be considered &apos;conceivable&apos;.</description>
    </rule>
    <rule key="798">
        <name>L0798: Redundant character &apos;Char&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated character char is redundant and can be eliminated from the input source. A typical example is a backslash on a line by itself.</description>
    </rule>
    <rule key="799">
        <name>L0799: numerical constant &apos;Integer&apos; larger than unsigned long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integral constant was found to be larger than the largest value allowed for unsigned long quantities. By default, an unsigned long is 4 bytes but can be respecified via the option -sl#. If the long long type is permitted (see option +fll) this message is automatically suppressed. See also message 417.</description>
    </rule>
    <rule key="801">
        <name>L0801: Use of goto is deprecated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A goto was detected. Use of the goto is not considered good programming practice by most authors and its use is normally discouraged. There are a few cases where the goto can be effectively employed but often these can be rewritten just as effectively without the goto. The use of goto&apos;s can have a devastating effect on the structure of large functions creating a mass of spaghetti-like confusion. For this reason its use has been banned in many venues.</description>
    </rule>
    <rule key="802">
        <name>L0802: Conceivably passing a null pointer to function &apos;Symbol&apos;, Context Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A NULL pointer is conceivably being passed to a function identified by Symbol. The argument in question is given by Context. The function is either a library function designed not to receive a NULL pointer or a user function dubbed so via the option -function.</description>
    </rule>
    <rule key="803">
        <name>L0803: Conceivable data overrun for function &apos;Symbol&apos;, argument Integer exceeds argument Integer Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is for data transfer functions such as memcpy, strcpy, fgets, etc. when the size indicated by the first cited argument (or arguments) can conceivably exceed the size of the buffer area cited by the second. The message may also be issued for user functions via the -function option.</description>
    </rule>
    <rule key="804">
        <name>L0804: Conceivable access beyond array for function &apos;Symbol&apos;, argument Integer exceeds Integer Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for several library functions (such as fwrite, memcmp, etc) wherein there is conceivably an attempt to access more data than exist. For example, if the length of data specified in the fwrite call can exceed the size of the data specified. The function is specified by Symbol and the arguments are identified by argument number.</description>
    </rule>
    <rule key="805">
        <name>L0805: Expected L&quot;...&quot; to initialize wide char string</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer for a wide character array or pointer did not use a preceding &apos;L&apos;. For example:
    wchar_t a[] = &quot;abc&quot;;
    was found whereas
    wchar_t a[] = L&quot;abc&quot;:
    was expected.</description>
    </rule>
    <rule key="806">
        <name>L0806: Small bit field is signed rather than unsigned</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A small bit field (less than an int wide) was found and the base type is signed rather than unsigned. Since the most significant bit is a sign bit this practice can produce surprising results. For example, struct { int b:1; } s; s.b = 1; if( s.b &gt; 0 ) /* should succeed but actually fails */ ...</description>
    </rule>
    <rule key="807">
        <name>L0807: Conceivably passing to function &apos;Symbol&apos; a negative value (Integer), Context Reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integral value that may conceivably be negative is being passed to a function that is expecting only positive values for a particular argument. The message contains the name of the function (Symbol), the questionable value (Integer) and the argument number (Context). The function may be a standard library function designed to accept only positive values such as malloc or memcpy (third argument), or may have been identified by the user as such through the -function or -sem options. See message 422 for an example and further explanation.</description>
    </rule>
    <rule key="808">
        <name>L0808: No explicit type given symbol &apos;Sybmol&apos;, assumed int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An explicit type was missing in a declaration. Unlike Warning 601, the declaration may have been accompanied by a storage class or modifier (qualifier) or both. For example: extern f(void);
    will draw message 808. Had the extern not been present, a 601 would have been raised.
    The keywords unsigned, signed, short and long are taken to be explicit type specifiers even though int is implicitly assumed as a base.</description>
    </rule>
    <rule key="809">
        <name>L0809: Possible return of address of auto through variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The value held by a pointer variable may have been the address of an auto variable. It is normally incorrect to return the address of an item on the stack because the portion of the stack allocated to the returning function is subject to being obliterated after return.</description>
    </rule>
    <rule key="810">
        <name>L0810: Arithmetic modification of custodial pointer &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>810,Arithmetic modification of custodial pointer &apos;Symbol&apos; We define the custodial variable as that variable directly receiving the result of a malloc or new or equivalent call. It is inappropriate to modify such a variable because it must ultimately be free&apos;ed or delete&apos;ed. You should first make a copy of the custodial pointer and then modify the copy. The copy is known as an alias.</description>
    </rule>
    <rule key="811">
        <name>L0811: Possible deallocation of pointer alias</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A free or a delete was applied to a pointer that did not appear to be the custodial variable of the storage that had been allocated. Please refer to message 810 for the definition of &apos;custodial variable&apos;. Deleting an alias pointer is bad because it can result in deleting the same area twice. This can cause strange behavior at unpredictable times. Always try to identify the custodial pointer as opposed to copies (or aliases) of it. Then deallocate storage through the custodial pointer. Modify only the alias pointers.</description>
    </rule>
    <rule key="812">
        <name>L0812: static variable &apos;Symbol&apos; has size &apos;Integer&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The amount of storage for a static symbol has reached or exceeded a value that was specified in a -size option (See Section 5.7, &quot;Other Options&quot;).</description>
    </rule>
    <rule key="813">
        <name>L0813: auto variable &apos;Symbol&apos; in function &apos;Symbol&apos; has size &apos;Integer&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The amount of storage for an auto symbol has reached or exceeded a value that was specified in a -size option (See Section 5.7, &quot;Other Options&quot;).</description>
    </rule>
    <rule key="814">
        <name>L0814: useless declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A tagless struct was declared without a declarator. For example: struct { int n; }; Such a declaration cannot very well be used.</description>
    </rule>
    <rule key="815">
        <name>L0815: Arithmetic modification of unsaved pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An allocation expression (malloc, calloc, new) is not immediately assigned to a variable but is used as an operand in some expression. This would make it difficult to free the allocated storage. For example:
    p = new X[n] + 2;
    will elicit this message. A preferred sequence is:
    q = new X[n]; p = q+2;
    In this way the storage may be freed via the custodial pointer q.
    Another example of a statement that will yield this message is:
    p = new (char *) [n];
    This is a gruesome blunder on the part of the programmer. It does NOT allocate an array of pointers as a novice might think. It is parsed as:
    p = (new (char *)) [n];
    which represents an allocation of a single pointer followed by an index into this &apos;array&apos; of one pointer.</description>
    </rule>
    <rule key="816">
        <name>L0816: Non-ANSI format specification</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-standard format specifier was found in a format-processing function such as printf or scanf. Such a specifier could be unique to a particular compiler or could be a de facto standard but is not ANSI.</description>
    </rule>
    <rule key="817">
        <name>L0817: Conceivably negative subscript (Integer) in operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integer whose value was conceivably negative was added to an array or to a pointer to an allocated area (allocated by malloc, operator new, etc.) This message is not given for pointers whose origin is unknown since a negative subscript is in general legal.
    The addition could have occurred as part of a subscript operation or as part of a pointer arithmetic operation. The operator is denoted by String. The value of the integer is given by Integer.</description>
    </rule>
    <rule key="818">
        <name>L0818: Pointer parameter &apos;Symbol&apos; (Location) could be declared ptr to const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>As an example:
    int f( int *p ) { return *p; }
    can be redeclared as:
    int f( const int *p ) { return *p; }
    Declaring a parameter a pointer to const offers advantages that a mere pointer does not. In particular, you can pass to such a parameter the address of a const data item. In addition it can offer better documentation.
    Other situations in which a const can be added to a declaration are covered in messages 952, 953, 954 and 1764.</description>
    </rule>
    <rule key="820">
        <name>L0820: Boolean test of a parenthesized assignment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A Boolean test was made on the result of an assignment and, moreover, the assignment was parenthesized. For example:
    if ( (a = b) ) ... // Info 820
    will draw this informational whereas
    if ( a = b ) ... // Info 720
    (i.e. the unparenthesized case) will, instead, draw Info 720. We, of course, do not count the outer parentheses required by the language that always accompany the if clause.
    The reason for partitioning the messages in this fashion is to allow the programmer to adopt the convention, advanced by some compilers (in particular gcc), of always placing a redundant set of parentheses around any assignment that is to be tested. In this case you can suppress Info 820 (via -e820) while still enabling Info 720.</description>
    </rule>
    <rule key="821">
        <name>L0821: Right hand side of assignment not parenthesized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment operator was found having one of the following forms: a = b || c a = b &amp;&amp; c a = b ? c : d
    Moreover, the assignment appeared in a context where a value was being obtained. For example:
    f( a = b ? c : d );
    The reader of such code could easily confuse the assignment for a test for equality. To eliminate any such doubts we suggest parenthesizing the right hand side as in:
    f( a = (b ? c : d) );</description>
    </rule>
    <rule key="825">
        <name>L0825: control flows into case/default without -fallthrough comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A common programming mistake is to forget a break statement between case statements of a switch. For example: case &apos;a&apos;: a = 0; case &apos;b&apos;: a++;
    Is the fall through deliberate or is this a bug? To signal that this is intentional use the -fallthrough option within a lint comment as in: case &apos;a&apos;: a = 0; //lint -fallthrough case &apos;b&apos;: a++;
    This message is similar to Warning 616 (&quot;control flows into case/default&quot;) and is intended to provide a stricter alternative. Warning 616 is suppressed by any comment appearing between the case&apos;s. Thus, an accidental omission of a break can go undetected by the insertion of a neutral comment. This can be hazardous to well-commented programs.</description>
    </rule>
    <rule key="826">
        <name>L0826: Suspicious pointer-to-pointer conversion (area too small)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer was converted into another either implicitly or explicitly. The area pointed to by the destination pointer is larger than the area that was designated by the source pointer. For example:
    long *f( char *p ) { return (long *) p; }</description>
    </rule>
    <rule key="827">
        <name>L0827: Loop not reachable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A loop structure (for, while, or do) could not be reached. Was this an oversight? It may be that the body of the loop has a labeled statement and that the plan of the programmer is to jump into the middle of the loop through that label. It is for this reason that we give an Informational message and not the Warning (527) that we would normally deliver for an unreachable statement. But please note that jumping into a loop is a questionable practice in any regard.</description>
    </rule>
    <rule key="828">
        <name>L0828: Semantics of function &apos;Name&apos; copied to function &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function with built-in semantics or user-defined semantics was #define&apos;d to be some other function with a similar name formed by prepending or appending underscores. For example:
    #define strcmp(a,b) __strcmp__(a,b)
    will cause Info 828 to be issued. As the message indicates, the semantics will be automatically transferred to the new function.</description>
    </rule>
    <rule key="829">
        <name>L0829: A +headerwarn option was previously issued for header &apos;Symbol</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some coding standards discourage or even prohibit the use of certain header files. PC-lint can guard against their use if we by activating the lint option +headerwarn(Symbol). Later, if the file is used, we will then issue this message.</description>
    </rule>
    <rule key="830">
        <name>L0830: Location cited in prior message</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Message 830 is a vehicle to convey in &apos;canonical form&apos; the location information embedded within some other message. For example, consider the (somewhat simplified) message:
    file x.c line 37: Declaration for &apos;x&apos; conflicts with line 22
    This contains the location (&quot;line 22&quot;) embedded in the text of the message. Embedded location information is not normally understood by editors and IDE&apos;s (Interactive Development Environments) which can only position to the nominal location (line 37 in this example). By adding this additional message with the nominal location of line 22 the user can, by stepping to the next message and, in this case, see what the &apos;conflict&apos; is all about. This message and message 831 below do not follow the ordinary rules for message suppression. If they did then when the option -w2 was employed to turn the warning level down to 2 these messages (at level 3) would also vanish. Instead they continue to function as expected. To inhibit them you need to explicitly turn them off using one of: -e830 -e831 They may be restored via +e830 and +e831; they state of suppression can be saved and restored via the -save -restore options. Options such as -e8* and -e{831} will have no effect.</description>
    </rule>
    <rule key="831">
        <name>L0831: Reference cited in prior message</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Message 831 is similar to message 830 in that it is a vehicle to convey in &apos;canonical form&apos; location information embedded within some other message. In the case of Info 831 the information is &apos;Reference&apos; information. This is a sequence of 1 or more locations that support a particular message. For example, consider the (somewhat simplified) message:
    file y.c line 701: Possible divide by 0 [Reference: file z.c lines 22, 23]
    Accompanying this message will be two Info 831 messages, one for each of the references cited in the message. Without this it would be a relatively tedious matter to locate each one of the references to determine just why there is a potential divide by 0. With these additional messages, editors and IDE&apos;s can automatically position the focus of editing to the nominal locations of the message.</description>
    </rule>
    <rule key="832">
        <name>L0832: Parameter &apos;Symbol&apos; not explicitly declared, int assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In an old-style function definition a parameter was not explicitly declared. To illustrate: void f( n, m ) int n; { ...
    This is an example of an old-style function definition with n and m the parameters. n is explicitly declared and m is allowed to default to int. An 832 will be issued for m.</description>
    </rule>
    <rule key="833">
        <name>L0833: Symbol &apos;Symbol&apos; is typed differently (String) in another module, Location,</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two objects, functions or definials are typed differently in two different modules. This is a case where the difference is legal but may cause confusion on the part of program maintenance.</description>
    </rule>
    <rule key="834">
        <name>L0834: Operator &apos;Name&apos; followed by operator &apos;Name&apos; is confusing. Use parentheses.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some combinations of operators seem to be confusing. For example
    a = b - c - d; a = b - c + d; a = b / c / d; a = b / c * d;
    tend to befuddle the reader. To reduce confusion we recommend using parentheses to make the association of these operators explicit. For example:
    a = (b - c) - d; a = (b - c) + d; a = (b / c) / d; a = (b / c) * d;
    in place of the above.</description>
    </rule>
    <rule key="835">
        <name>L0835: A zero has been given as [left/right] argument to operator &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A 0 has been provided as an operand to an arithmetic operator. The name of the operator is provided in the message as well as the side of the operator (left or right) that had the unusual value. For example: n = n + 0 - m; will produce a message that the right hand operand of operator &apos;+&apos; is zero.
    In general the operators examined are the binary operators: + - * / % | &amp; ^ &lt;&lt; &gt;&gt; and the unary operators - and +.
    An enumeration constant whose value is 0 is permitted with operators: + - &gt;&gt; &lt;&lt; Otherwise a message is issued. For example: enum color { red, blue = red+100, /* ok */ green= red*0x10 /* 835 */ }; The assignment operators that have an arithmetic or bitwise component, such as |=, are also examined. The message given is equivalent to that given with the same operator without the assignment component.</description>
    </rule>
    <rule key="836">
        <name>L0836: Conceivable access of pointer pointing Integer bytes past nul character by operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A situation was detected where it appears remotely possible that a buffer is being accessed beyond the (nul-terminated) string that was placed in the buffer. An example of accessing beyond the nul character is shown in the example below: char buf[20]; int k = 4; strcpy( buf, &quot;a&quot; ); if( buf[k] == &apos;a&apos; ) ... // legal but suspect In this particular case the access would be deemed &apos;likely&apos; and a different but related message (Warning 448 in Section 13.3) would have been issued. This message (836) could be issued if there were some intervening code involving k. See also Warning 690 in Section 13.3.</description>
    </rule>
    <rule key="838">
        <name>L0838: Previously assigned value to variable &apos;Symbol&apos; has not been used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment statement was encountered that apparently obliterated a previously assigned value that had never had the opportunity of being used. For example, consider the following code fragment: y = 1; if( n &gt; 0 ) y = 2; y = 4; // Info 838 ... Here we can report that the assignment of 4 to y obliterates previously assigned values that were not used. We, of course, cannot report anything unusual about the assignment of 2. This will assign over a prior value of 1 that so far had not been used but the existence of an alternative path means that the value of 1 can still be employed later in the code and is accepted for the time being as reasonable. It is only the final assignment that raises alarm bells. See also Warning 438 in Section 13.3.</description>
    </rule>
    <rule key="839">
        <name>L0839: Storage class of symbol &apos;Symbol&apos; assumed static (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration for a symbol that was previously declared static in the same module was found without the &apos;static&apos; specifier. For example: static void f(); extern void f(); // Info 839 void f() {} // Info 839 By the rules of the language &apos;static&apos; wins and the symbol is assumed to have internal linkage. This could be the definition of a previously declared static function (as in line 3 of the above example) in which case by adding the static specifier you will inhibit this message. This could also be a redeclaration of either a function or a variable (as in line 2 of the above example) in which case the redeclaration is redundant.</description>
    </rule>
    <rule key="840">
        <name>L0840: Use of nul character in a string literal</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A nul character was found in a string literal. This is legal but suspicious and may have been accidental. This is because a nul character is automatically placed at the end of a string literal and because conventional usage and most of the standard library&apos;s string functions ignore information past the first nul character.</description>
    </rule>
    <rule key="843">
        <name>L0843: Variable &apos;Symbol&apos; (Location) could be declared as const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable of static storage duration is initialized but never modified thereafter. Was this an oversight? If the intent of the programmer is to not modify the variable, it could and should be declared as const. See [30, Item 3] in Section 14. Added Bibliography and message 844.</description>
    </rule>
    <rule key="844">
        <name>L0844: Pointer variable &apos;Symbol&apos; (Location) could be declared as pointing to const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The data pointed to by a pointer of static storage duration is never changed (at least not through that pointer). It therefore would be better if the variable were typed pointer to const. See [30, Item 3] in Section 14. Added Bibliography and message 843.</description>
    </rule>
    <rule key="845">
        <name>L0845: The [left/right] argument to operator &apos;Name&apos; is certain to be 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An operand that can be deduced to always be 0 has been presented to an arithmetic operator in a context that arouses suspicion. The name of the operator is provided in the message as well as the side of the operator (left or right) that had the unusual value. For example: n = 0; k = m &amp; n; will produce a message that the right hand operand of operator &apos;&amp;&apos; is certain to be zero.
    The operands examined are the right hand sides of operators + - | || the left hand sides of operators / % and both sides of operators * &amp; &lt;&lt; &gt;&gt; &amp;&amp; The reason that the left hand side of operator + (and friends) is not examined for zero is that zero is the identity operation for those operators and hence is often used as an initializing value. For example: sum = 0; for( ... ) sum = sum + what_ever; // OK, no message The message is not issued for arithmetic constant zeros. Info 835 in Section 13.4 is issued in that instance.
    The message is also suspended when the expression has side-effects. For example: i = 0; buf[i++] = &apos;A&apos;; We don&apos;t consider it reasonable to force the programmer to write: buf[0] = &apos;A&apos;; i = 1;</description>
    </rule>
    <rule key="846">
        <name>L0846: Signedness of bit-field is implementation defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A bit-field was detected having the form: int a:5; Most bit fields are more useful when they are unsigned. If you want to have a signed bit field you must explicitly indicate this as follows: signed int a:5; The same also holds for typedef&apos;s. For example, typedef int INT; typedef signed int SINT; struct { INT a:16; // Info 846 SINT b:16; // OK }: It is very unusual in C or C++ to distinguish between signed int and just plain int. This is one of those rare cases.</description>
    </rule>
    <rule key="847">
        <name>L0847: Thread &apos;Symbol&apos; has unprotected call to thread unsafe function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A thread named in the message makes an unprotected call (i.e., outside of a critical section) on the function named in the message. The function had previously been identified as thread unsafe. See Section 8. Mult-thread Support for a definition of the terms: unprotected and thread unsafe.
    This is not necessarily an error. Most thread unsafe functions may be called outside of critical sections provided no other thread is making such a call. There are other messages (at the Warning level) that will be issued when some other thread is also calling the same function, so it would normally be safe to suppress this message.</description>
    </rule>
    <rule key="848">
        <name>L0848: Worst case function for stack usage: String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message, issued at global wrap-up, will report on the function that requires the most stack. The stack required consists of the amount of auto storage the function requires plus the amounts required in any chain of functions called. The worst case chain is always reported.
    To obtain a report of all the function use the option -ok(filename).
    Reasonable allowances are made for function call overhead and the stack requirements of external functions. These assumptions can be controlled via the -stack option.
    If recursion is detected it will be reported here as this is considered worse than any finite case. The next worse case is that the stack can&apos;t be determined because a function makes a call through a function pointer. The function is said to be non-deterministic. If neither if these conditions prevail, the function that heads the worst case chain of calls will be reported upon.
    The message will normally provide you with the name of a called function. If the function is recursive this will provide you with the first call of a recursive loop. To determine the full loop, use option -ok(filename) which will contain a record for each function for which a definition was found. You will be able to follow the chain of calls to determine the recursive path.
    If you can assure yourself through code analysis that there is an upper bound to the amount of stack utilized by some recursive function then you can employ the -stack option to specify this bound. The function will no longer be considered recursive but rather finite. In this way, possibly through a sequence of options, you can progressively eliminate apparent recursion and in that way arrive at a safe upper bound for stack usage. Similar considerations apply for non-deterministic functions.</description>
    </rule>
    <rule key="849">
        <name>L0849: Symbol &apos;Symbol&apos; has same enumerator value &apos;String&apos; as enumerator &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two enumerators have the same value. For example: enum colors { red, blue, green = 1 }; will elicit this informational message. This is not necessarily an error and you may want to suppress this message for selected enumerators.</description>
    </rule>
    <rule key="850">
        <name>L0850: for loop index variable &apos;Symbol&apos; whose type category is &apos;String&apos; modified in body of the for loop that began at &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Note: This message is delivered after the for loop has been completed.
    A for loop with an identifiable loop index variable was programmed in such a way that the loop body also modifies the index variable. For example: for( i = 0; i &lt; 100; i++ ) { a[i++] = 0; } In general it is better to restrict modifications to for loop index variables to the for clause if at all possible. If this is not possible, you can prefix the for loop with an appropriate lint comment such as: /*lint -e{850} i is modified in the body of the for loop */ The message is parameterized with a type category which is one of:
    integral some form of integer float some form of floating point number string some form of char * including wide char pointer some form of pointer other than string enumeration an enumeration of some kind unclassified none of the above
    This will allow you to be more selective in the delivery of messages because you may suppress or enable messages according to these classifications. For example: -e850 +estring(850,integral) +estring(850,float) will enable Info 850 for integrals or for floats but not for other forms of loop variables.</description>
    </rule>
    <rule key="864">
        <name>L0864: Expression involving variable &apos;Symbol&apos; possibly depends on order of evaluation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The variable cited in the message is either passed to a reference that is not a const reference or its address is passed to a pointer that is not a pointer to const. Hence the variable is potentially modified by the function. If the same variable is used elsewhere in the same expression, then the result may depend on the order of evaluation of the expression. For example: int g( int ); int h( int &amp; ); int f( int k ) { return g(k) + h(k); // Info 864 } Here the compiler is free to evaluate the call to g() first with the original value of k and then call h() where k gets modified. Alternatively, it can, with equal validity, call h() first in which case the value passed to g() would be the new value.
    The object being modified could be the implicit argument (the this argument) to a member function call. For example: void f( int, int ); class X { public: int bump(); int k; }; ... X x; f( x.bump(), x.bump() ); // Info 864 Here the message states that the expression involving object x possibly depends on the order of evaluation. x is an implicit argument (by reference) to the bump() member function. If the member function bump() were declared const then the message would not have been emitted.
    (See also 11.1 Order of Evaluation in the manual and Warning 564).</description>
    </rule>
    <rule key="866">
        <name>L0866: Unusual use of &apos;String&apos; in argument to sizeof</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression used as an argument to sizeof() counts as &quot;unusual&quot; if it is not a constant, a symbol, a function call, a member access, a subscript operation (with indices of zero or one), or a dereference of the result of a symbol, scoped symbol, array subscript operation, or function call. Also, since unary &apos;+&apos; could legitimately be used to determine the size of a promoted expression, it does not fall under the category of &quot;unusual&quot;. Example: char A[10]; unsigned end = sizeof(A - 1); // 866; Programmer probably meant // &apos;sizeof(A) - 1&apos; size_of_promoted_char = sizeof(+A[0]); // &apos;+&apos; makes a difference here size_t s1 = sizeof( end+1 ); // 866: use +end to get promoted type size_t s2 = sizeof( +(end+1) ); // OK, we won&apos;t complain struct B *p; // B is some POD. B b1;
    memcpy( p, &amp;b1, sizeof(&amp;b1) ); // 866; intended to take sizeof(b1)
    size_t s3 = sizeof(A[0]); // OK, get the size of an element. size_t s4 = sizeof(A[2]); // 866; Not incorrect, but ... // unusual in a sizeof().</description>
    </rule>
    <rule key="867">
        <name>L0867: Unrecognized pragma &apos;Name&apos; will be ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first identifier after #pragma is considered the name of the pragma. If the name is unrecognized then the remainder of the line is ignored. Since the purpose of #pragma is to allow for compiler-dependent communication it is not really expected that all pragmas will be understood by all third-party processors of the code. Thus, this message does not necessarily indicate that there is anything wrong and could easily be supressed entirely.
    Moreover, if the pragma occurs in a libary header this message would not normally be issued because the option -wlib(1) would be in effect (this option is present in all of our compiler option files).
    But if the pragma occurs in user code then it should be examined to see if there is something there that might interest a lint processor. There are a variety of facilities to deal with pragmas; in particular, they can be mapped into languistic constructs or lint options or both. See 3.5 pragmas push_macro and pop_macro and 3.6 Casting pragmas as macros.</description>
    </rule>
    <rule key="900">
        <name>L0900: Successful completion, &apos;Integer&apos; messages produced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message exists to provide some way of ensuring that an output message is always produced, even if there are no other messages. This is required for some windowing systems. For this purpose use the option +e900.</description>
    </rule>
    <rule key="904">
        <name>L0904: Return statement before end of function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A return statement was found before the end of a function definition. Many programming standards require that functions contain a single exit point located at the end of the function. This can enhance readability and may make subsequent modification less error prone.</description>
    </rule>
    <rule key="905">
        <name>L0905: Non-literal format specifier used (with arguments)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A printf/scanf style function received a non-literal format specifier but, unlike the case covered by Warning 592 in Section 13.3 the function also received additional arguments. E.g. char *fmt; int a, b; ... printf( fmt, a, b ); Variable formats represent a very powerful feature of C/C++ but they need to be used judiciously. Unlike the case covered by Warning 592, this case cannot be easily rewritten with an explicit visible format. But this Elective Note can be used to examine code with non-literal formats to make sure that no errors are present and that the formats themselves are properly constructed and contain no user-provided data. See also Warning 592 in Section 13.3</description>
    </rule>
    <rule key="909">
        <name>L0909: Implicit conversion from Type to bool</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-bool was tested as a Boolean. For example, in the following function: int f(int n) { if( n ) return n; else return 0; }
    the programmer tests &apos;n&apos; directly rather than using an explicit Boolean expression such as &apos;n != 0&apos;. Some shops prefer the explicit test.</description>
    </rule>
    <rule key="910">
        <name>L0910: Implicit conversion (Context) from 0 to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer was assigned (or initialized) with a 0. Some programmers prefer other conventions such as NULL or nil. This message will help such programmers root out cavalier uses of 0. This is relatively easy in C since you can define NULL as follows:
    #define NULL (void *)0
    However, in C++, a void* cannot be assigned to other pointers without a cast. Instead, assuming that NULL is defined to be 0, use the option:
    --emacro((910),NULL)
    This will inhibit message 910 in expressions which use NULL. This method will also work in C.
    Both methods assume that you expressly turn on this message with a +e910 or equivalent.</description>
    </rule>
    <rule key="911">
        <name>L0911: Implicit expression promotion from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever a sub-integer expression such as a char, short, enum, or bit-field is promoted to int for the purpose of participating in some arithmetic operation or function call.</description>
    </rule>
    <rule key="912">
        <name>L0912: Implicit binary conversion from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever a binary operation (other than assignment) requires a type balancing. A smaller range type is promoted to a larger range type. For example: 3 + 5.5 will trigger such a message because int is converted to double.</description>
    </rule>
    <rule key="913">
        <name>L0913: Implicit adjustment of expected argument type from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever an old-style function definition contains a sub-integer or float type. For example:
    int f( ch, x ) char ch; float x; { ...
    contains two 913 adjustments.</description>
    </rule>
    <rule key="914">
        <name>L0914: Implicit adjustment of function return value from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever the function return value is implicitly adjusted. This message is given only for functions returning arrays.</description>
    </rule>
    <rule key="915">
        <name>L0915: Implicit conversion (Context) Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever an assignment, initialization or return implies an arithmetic conversion (Context specifies which).</description>
    </rule>
    <rule key="916">
        <name>L0916: Implicit pointer assignment conversion (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever an assignment, initialization or return implies an implicit pointer conversion (Context specifies which).</description>
    </rule>
    <rule key="917">
        <name>L0917: Prototype coercion (Context) Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever an implicit arithmetic conversion takes place as the result of a prototype. For example:
    double sqrt(double); ... sqrt(3); ...
    will elicit this message because 3 is quietly converted to double.</description>
    </rule>
    <rule key="918">
        <name>L0918: Prototype coercion (Context) of pointers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Notes whenever a pointer is implicitly converted because of a prototype. Because of prototype conversion, near pointers will otherwise be silently mapped into far pointers. far pointers mapped into near pointers also generate message 619.</description>
    </rule>
    <rule key="919">
        <name>L0919: Implicit conversion (Context) Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A lower precision quantity was assigned to a higher precision variable as when an int is assigned to a double.</description>
    </rule>
    <rule key="920">
        <name>L0920: Cast from Type to void</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made from the given type to void.</description>
    </rule>
    <rule key="921">
        <name>L0921: Cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made from one integral type to another.</description>
    </rule>
    <rule key="922">
        <name>L0922: Cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to or from one of the floating types (float, double, long double).</description>
    </rule>
    <rule key="923">
        <name>L0923: Cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made either from a pointer to a non-pointer or from a non-pointer to a pointer.</description>
    </rule>
    <rule key="924">
        <name>L0924: Cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made from a struct or a union. If the cast is not to a compatible struct or union error 69 is issued.</description>
    </rule>
    <rule key="925">
        <name>L0925: Cast from pointer to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to convert one pointer to another such that one of the pointers is a pointer to void. Such conversions are considered harmless and normally do not even need a cast.</description>
    </rule>
    <rule key="926">
        <name>L0926: Cast from pointer to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to convert a char pointer to a char pointer (one or both of the char&apos;s may be unsigned). This is considered a &apos;safe&apos; cast.</description>
    </rule>
    <rule key="927">
        <name>L0927: Cast from pointer to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to convert a char (or unsigned char) pointer to a non-char pointer. char pointers are sometimes implemented differently from other pointers and there could be an information loss in such a conversion.</description>
    </rule>
    <rule key="928">
        <name>L0928: Cast from pointer to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made from a non-char pointer to a char pointer. This is generally considered to be a &apos;safe&apos; conversion.</description>
    </rule>
    <rule key="929">
        <name>L0929: Cast from pointer to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to convert one pointer to another that does not fall into one of the classifications described in 925 through 928 above. This could be nonportable on machines that distinguish between pointer to char and pointer to word. Consider casting a pointer to pointer to char to a pointer to pointer to word. The indirect bit pattern remains unchanged.</description>
    </rule>
    <rule key="930">
        <name>L0930: Cast from Type to Type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast is being made to or from an enumeration type.</description>
    </rule>
    <rule key="931">
        <name>L0931: Both sides have side effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Indicates when both sides of an expression have side-effects. An example is n++ + f(). This is normally benign. The really troublesome cases such as n++ + n are caught via Warning 564.</description>
    </rule>
    <rule key="932">
        <name>L0932: Passing near pointer to library function &apos;(Symbol)&apos; (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A source of error in Windows programming is to pass a near pointer to a library function. If the library is a DLL library, then in supplying the missing segment, the library would assume its own data segment which would probably be wrong. See also messages 933 and 934.</description>
    </rule>
    <rule key="933">
        <name>L0933: Passing near pointer to far function (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A source of error in Windows programming is to pass a near pointer to a DLL function. Most Microsoft functions in DLLs are declared with the far modifier. Hence this can be tentatively used as a discriminant to decide that a pointer is too short. An advantage that this Note has over 932 is that it can catch functions designated only by pointer. Also you may be using libraries that are not DLLs and that share the same DS segment. In this case, 932 may produce too many superfluous messages. See also message 934.</description>
    </rule>
    <rule key="934">
        <name>L0934: Taking address of near auto variable &apos;Symbol&apos; (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A source of error in writing DLL libraries is that the stack segment may be different from the data segment. In taking the address of a near data object only the offset is obtained. In supplying the missing segment, the compiler would assume the data segment which could be wrong. See also messages 932 and 933.</description>
    </rule>
    <rule key="935">
        <name>L0935: int within struct</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This Note helps to locate non-portable data items within struct&apos;s. If instead of containing int&apos;s and unsigned int&apos;s, a struct were to contain short&apos;s and long&apos;s then the data would be more portable across machines and memory models. Note that bit fields and union&apos;s do not get complaints.</description>
    </rule>
    <rule key="936">
        <name>L0936: old-style function definition for function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An &quot;old-style&quot; function definition is one in which the types are not included between parentheses. Only names are provided between parentheses with the type information following the right parenthesis. This is the only style allowed by K&amp;R.</description>
    </rule>
    <rule key="937">
        <name>L0937: old-style function declaration for function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An &quot;old-style&quot; function declaration is one which does not have type information for its arguments.</description>
    </rule>
    <rule key="938">
        <name>L0938: parameter &apos;Symbol&apos; not explicitly declared</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In an &quot;old-style&quot; function definition it is possible to let a function parameter default to int by simply not providing a separate declaration for it.</description>
    </rule>
    <rule key="939">
        <name>L0939: return type defaults to int for function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function was declared without an explicit return type. If no explicit storage class is given, then Informational 745 is also given provided the Deduce Return mode flag (fdr) is off. This is meant to catch all cases.</description>
    </rule>
    <rule key="940">
        <name>L0940: omitted braces within an initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer for a subaggregate does not have braces. For example:
    int a[2][2] = { 1, 2, 3, 4 };
    This is legal C but may violate local programming standards. The worst violations are covered by Warning 651.</description>
    </rule>
    <rule key="941">
        <name>L0941: Result 0 due to operand(s) equaling 0 in operation &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The result of a constant evaluation is 0 owing to one of the operands of a binary operation being 0. This is less severe than Info 778 wherein neither operand is 0. For example, expression (2&amp;1) yields a 778 whereas expression (2&amp;0) yields a 941.</description>
    </rule>
    <rule key="942">
        <name>L0942: Possibly truncated addition promoted to float</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integral expression (signed or unsigned) involving addition or subtraction is converted to a floating point number. If an overflow occurred, information would be lost. See also messages 647, 776 and 790.</description>
    </rule>
    <rule key="943">
        <name>L0943: Too few initializers for aggregate &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The initializer {0} was used to initialize an aggregate of more than one item. Since this is a very common thing to do it is given a separate message number which is normally suppressed. See 785 for more flagrant abuses.</description>
    </rule>
    <rule key="944">
        <name>L0944: [left/right/] argument for operator &apos;String&apos; always evaluates to [True/False]</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated operator (given by String has an argument that appears to always evaluate to either &apos;True&apos; or &apos;False&apos; (as indicated in the message). This is given for Boolean operators (||and &amp;&amp; and for Unary operator !) and information is gleaned from a variety of sources including prior assignment statements and initializers. Compare this with message 506 which is based on testing constants or combinations of constants.</description>
    </rule>
    <rule key="945">
        <name>L0945: Undefined struct used with extern</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some compilers refuse to process declarations of the form:
    extern struct X s;
    where struct X is not yet defined. This note can alert a programmer porting to such platforms.</description>
    </rule>
    <rule key="946">
        <name>L0946: Relational or subtract operator applied to pointers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A relational operator (one of &gt;, &gt;=, &lt;, &lt;=) or the subtract operator has been applied to a pair of pointers. The reason this is of note is that when large model pointers are compared (in one of the four ways above) or subtracted, only the offset portion of the pointers is subject to the arithmetic. It is presumed that the segment portion is the same. If this presumption is not accurate then disaster looms. By enabling this message you can focus in on the potential trouble spots.</description>
    </rule>
    <rule key="947">
        <name>L0947: Subtract operator applied to pointers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression of the form p - q was found where both p and q are pointers. This is of special importance in cases where the maximum pointer can overflow the type that holds pointer differences. For example, suppose that the maximum pointer is 3 Gigabytes -1, and that pointer differences are represented by a long, where the maximum long is 2 Gigabytes -1. Note that both of these quantities fit within a 32 bit word. Then subtracting a small pointer from a very large pointer will produce an apparent negative value in the long representing the pointer difference. Conversely, subtracting a very large pointer from a small pointer can produce a positive quantity.
    The alert reader will note that a potential problem exists whenever the size of the type of a pointer difference equals the size of a pointer. But the problem doesn&apos;t usually manifest itself since the highest pointer values are usually less than what a pointer could theoretically hold. For this reason, the message cannot be given automatically based on scalar types and hence has been made an Elective Note.
    Compare this Note with that of 946 which was designed for a slightly different pointer difference problem.</description>
    </rule>
    <rule key="948">
        <name>L0948: Operator &apos;String&apos; always evaluates to [True/False]</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The operator named in the message is one of four relational operators or two equality operators in the list: &gt; &gt;= &lt; &lt;= == != The arguments are such that it appears that the operator always evaluates to either True or to False (as indicated in the message). This is similar to message 944. Indeed there is some overlap with that message. Message 944 is issued in the context where a Boolean is expected (such as the left hand side of a ? operator) but may not involve a relational operator. Message 948 is issued in the case of a relational (or equality) operator but not necessarily in a situation that requires a Boolean.</description>
    </rule>
    <rule key="950">
        <name>L0950: Non-ANSI reserved word or construct: &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Symbol is either a reserved word that is non-ANSI or a construct (such as the // form of comment in a C module). This Elective Note is enabled automatically by the -A option. If these messages are occurring in a compiler or library header file over which you have no control, you may want to use the option -elib(950). If the reserved word is one which you want to completely disable, then use the option -rw(Word).</description>
    </rule>
    <rule key="951">
        <name>L0951: Pointer to incomplete type &apos;Symbol&apos; employed in operation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pointer to an incomplete type (for example, struct X where struct X has not yet been defined in the current module) was employed in an assignment or in a comparison (for equality) operator. For example, suppose a module consisted only of the following function: struct A * f(struct A *p ) { return p; }
    Since struct A had not been defined, this message will be issued. Such employment is permitted by the standard but is not permitted by all C compilers. If you want to deploy your application to the maximum number of platforms you should enable this Elective Note.</description>
    </rule>
    <rule key="952">
        <name>L0952: Parameter &apos;Symbol&apos; (Location) could be declared const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A parameter is not modified by a function. For example:
    int f( char *p, int n ) { return *p = n; }
    can be redeclared as:
    int f( char * const p, const int n ) { return *p = n; }
    There are few advantages to declaring an unchanging parameter a const. It signals to the person reading the code that a parameter is unchanging, but, in the estimate of most, reduces legibility. For this reason the message has been given an Elective Note status.
    However, there is a style of programming that encourages declaring parameters const. For the above example, this style would declare f as
    int f( char * p, int n);
    and would use the const qualifier only in the definition. Note that the two forms are compatible according to the standard. The declaration is considered the interface specification where the const&apos;s do not matter. The const&apos;s do matter in the definition of the function which is considered the implementation. Message 952 could be used to support this style.
    Marking a parameter as const does not affect the type of argument that can be passed to the parameter. In particular, it does not mean that only const arguments may be passed. This is in contrast to declaring a parameter as pointer to const or reference to const. For these situations, Informational messages are issued (818 and 1764 respectively) and these do affect the kinds of arguments that may be passed. See also messages 953 and 954.</description>
    </rule>
    <rule key="953">
        <name>L0953: Variable &apos;Symbol&apos; (Location) could be declared as const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A local variable (either static or auto) is initialized but never modified thereafter. Such a variable could be declared const. One advantage in making such a declaration is that it can furnish a clue to the program reader that the variable is unchanging. In the case of static data it can mean that the data is ROM&apos;able. Other situations in which a const can be added to a declaration are covered in messages 818, 952, 954 and 1764.</description>
    </rule>
    <rule key="954">
        <name>L0954: Pointer variable &apos;Symbol&apos; (Location) could be declared as pointing to a const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The data pointed to by a pointer is never changed (at least not through that pointer). It may therefore be better, or at least more descriptive, if the variable were typed pointer to const. For example: { char *p = &quot;abc&quot;; for( ; *p; p++ ) print(*p); }
    can be redeclared as: { const char *p = &quot;abc&quot;; for( ; *p; p++ ) print(*p); }
    It is interesting to contrast this situation with that of pointer parameters. The latter is given Informational status (818) because it has an effect of enhancing the set of pointers that can be passed into a function. Other situations in which a const can be added to a declaration are covered in messages 952, 953 and 1764.</description>
    </rule>
    <rule key="955">
        <name>L0955: Parameter name missing from prototype for function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a function declaration a parameter name is missing. For example:
    void f(int);
    will raise this message. This is perfectly legal but misses an opportunity to instruct the user of a library routine on the nature of the parameter. For example:
    void f(int count);
    would presumably be more meaningful. [27, Rule 34].
    This message is not given for function definitions, only function declarations.</description>
    </rule>
    <rule key="956">
        <name>L0956: Non const, non volatile static or external variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This check has been advocated by programmers whose applications are multi-threaded. Software that contains modifiable data of static duration is often non-reentrant. That is, two or more threads cannot run the code concurrently. By &apos;static duration&apos; we mean variables declared static or variables declared external to any function. For example: int count = 0; void bump() { count++; } void get_count() { return count; }
    If the purpose is to obtain a count of all the bump()&apos;s by a given thread then this program clearly will not do since the global variable count sums up the bump()&apos;s from all the threads. Moreover, if the purpose of the code is to obtain a count of all bump()&apos;s by all threads, it still may contain a subtle error (depending on the compiler and the machine). If it is possible to interrupt a thread between the access of count and the subsequent store, then two threads that are bump()&apos;ing at the same time, may register an increase in the count by just one.
    Please note that not all code is intended to be re-entrant. In fact most programs are not designed that way and so this Elective Note need not be enabled for the majority of programs. If the program is intended to be re-entrant, all uses of non-const static variables should be examined carefully for non-reentrant properties.</description>
    </rule>
    <rule key="957">
        <name>L0957: Function &apos;Symbol&apos; defined without a prototype in scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function was defined without a prototype in scope. It is usually good practice to declare prototypes for all functions in header files and have those header files checked against the definitions of the function to assure that they match.
    If you are linting all the files of your project together such cross checking will be done in the natural course of things. For this reason this message has been given a relatively low urgency of Elective Note.</description>
    </rule>
    <rule key="958">
        <name>L0958: Padding of Integer byte(s) is required to align member on Integer byte boundary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given whenever padding is necessary within a struct to achieve a required member alignment. Consider: struct A { char c; int n; }; Assuming that int must be aligned on a 4-byte boundary and assuming the size of a char to be 1, then this message will be issued indicating that there will be a padding of 3 bytes.
    The alignment requirements vary with the compiler, the machine and, sometimes, compiler options. When separately compiled programs need to share data at the binary level it helps to remove any artificially created padding from any of the structures that may be shared.</description>
    </rule>
    <rule key="959">
        <name>L0959: Nominal struct size (Integer bytes) is not an even multiple of the maximum member alignment (Integer bytes)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The alignment of a structure (or union) is equal to the maximum alignment of any of its members. When an array of structures is allocated, the compiler ensures that each structure is allocated at an address with the proper alignment. This will require padding if the size of the structure is not an even multiple of its maximum alignment. For example: struct A { int n; char ch; } a[10]; Assuming the size and alignment of int is 4 then the size of each struct is 5 but its alignment is 4. As a result each struct in the array will be padded with 3 bytes.
    Alignment can vary with the compiler and the machine. If binary data is to be shared by separately compiled modules, it is safer to make sure that all shared structures and unions are explicitly padded.</description>
    </rule>
    <rule key="960">
        <name>L0960: Violates MISRA Year Required Rule Name, String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA is the &quot;Guidelines for the use of the C Language in Vehicle Based Software&quot;. [10] The first version of the MISRA Standard was released in 1998 and the second in 2004. Lint references the rules from each version of the Standard using integers for 1998 and in decimal form for 2004, as per the Standard numbering style.
    The list of required checks made for both MISRA 1998 and 2004 are:
    (Rule 16/12.12) Bit representation of a floating point type used.
    (Rule 19/7.1) Octal constant used. (Rule 32/9.3) Should initialize either all enum members or only the first.
    (Rule 22/8.7) Could define variable at block scope.
    (Rule 27/8.8) Object/function previously declared.
    (Rule 33/12.4) Side effects on right hand side of logical operator.
    (Rule 34/12.5) Non-primary expression used with logical operator.
    (Rule 36/12.6) Boolean expression required for operator.
    (Rule 40/12.3) &apos;sizeof&apos; used on expressions with side effect.
    (Rule 42/12.10) Comma operator used outside of &apos;for&apos; expression.
    (Rule 47/12.1) Dependence placed on C operator precedence.
    (Rule 54/14.3) Null statement not in line by itself.
    (Rule 57/14.5) continue statement should not be used.
    (Rules 59/14.8 &amp; 14.9) Left brace expected for if, else, for, do, and while.
    (Rule 60/14.10) No &apos;else&apos; at end of &apos;if ... else if&apos; chain.
    (Rule 63/15.4) Boolean value in switch expression.
    (Rule 65/13.4) Floating point variable used as loop counter.
    (Rule 68/8.6) Function not declared at file scope.
    (Rule 69/16.1) Function has variable number of arguments.
    (Rule 73/16.3) Either all parameters or no parameters should have identifiers.
    (Rule 74/16.4) Parameter list differs from prior declaration for function.
    (Rule 87/19.1) Declaration before #include.
    (Rule 88/19.2) Header file name with non-standard character.
    (Rule 91/19.5) &apos;#define/#undef&apos; used within a block.
    (Rule 92/19.6) Use of &apos;#undef&apos; prohibited.
    (Rule 98/19.12) Multiple use of &apos;#&apos; and/or &apos;##&apos; operators in macro definition.
    (Rule 100/19.14) Non-standard use of &apos;defined&apos; preprocessor operator.
    (Rule 115/20.2) Re-use of C90 identifier/identifier pattern.

    Required checks made exclusively for MISRA 1998 are:
    (Rule 8) Multibyte characters and wide string literals prohibited.
    (Rule 42) Comma operator used outside of &apos;for&apos; expression.
    (Rule 54) Null statement not in line by itself.
    (Rule 58) break used outside of a switch.
    (Rule 73) Either all parameters or no parameters should have identifiers.
    (Rule 87) Declaration before #include.
    (Rule 88) Header file name contains non-standard character.
    (Rule 110) Bitfields inside union.

    Required checks made exclusively for MISRA 2004 are:
    (Rule 4.1) Prohibited escape sequence used.
    (Rule 6.1) Disallowed use of non-character value.
    (Rule 6.2) Disallowed use of non-numeric value.
    (Rule 8.5) No definitions of objects or function in header files.
    (Rules 10.1 &amp; 10.2) Prohibited implicit conversion.
    (Rules 10.3 &amp; 10.4) Prohibited cast of complex expressions.
    (Rule 10.5) Recasting required for operators &apos;~&apos; and &apos;&lt;&lt;&apos;.
    (Rule 10.6) Unsigned integer literals require a &apos;U&apos; suffix.
    (Rule 11.5) Attempt to cast away const/volatile from a pointer or reference.
    (Rule 12.3) &apos;sizeof&apos; used on expressions with side effect.
    (Rule 12.7) Bitwise operator applied to signed underlying type.
    (Rule 12.9) Prohibited operator applied to unsigned underlying type.
    (Rule 12.10) Comma operator used.
    (Rule 12.13) Increment or decrement combined with another operator.
    (Rule 14.3) Null statement not in line by itself.
    (Rule 14.6) More than one &apos;break&apos; terminates loop.
    (Rule 14.8) Left brace expected.
    (Rule 16.3) All parameters shall have identifiers.
    (Rule 16.9) Function identifier used without &apos;&amp;&apos; or parenthesized parameter list.
    (Rule 17.4) Pointer arithmetic other than array indexing used.
    (Rule 14.10) No &apos;else&apos; at end of &apos;if ... else if&apos; chain.
    (Rule 15.4) Boolean value in switch expression.
    (Rule 18.4) Unions shall not be used.
    (Rule 19.6) Use of &apos;#undef&apos; prohibited.
    (Rule 19.13) &apos;#/##&apos; operator used in macro.

    MISRA 1998 checking is achieved using the -misra(1) option. For MISRA 2004 checks, use -misra(2).

    You may disable individual rules to your taste by using the Rule number in an esym option. For example:
    -esym( 960, 75, 8? )
    will suppress MISRA rules 75 and any of the those between 80 and 89 inclusive that are issued as the result of a 960. See [10] for information on the MISRA guidelines.</description>
    </rule>
    <rule key="961">
        <name>L0961: Violates MISRA Year Advisory Rule Name, String&quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for some violations of the MISRA advisory guidelines. Certain rules were advisories in the 1998 Standard and became required for the 2004 Standard and vice versa. Therefore, you might see some rules repeated here already listed above for message 960.
    The list of advisory checks made for both MISRA 1998 and 2004 are:
    (Rule 47/12.1) Dependence placed on C&apos;s operator precedence (Rule 87/19.1) Only preprocessor statements and comments before &apos;#include&apos;. (Rule 93/19.7) Use of function-like macros is discouraged. (Rule 102/17.5) More than two pointer indirection levels used.
    Advisory checks made exclusively for MISRA 1998 are:
    (Rule 18) Constant requires numerical suffix (Rule 28) &apos;register&apos; class discouraged (Rule 40) &apos;sizeof&apos; used on expressions with side effect (Rule 44) Redundant explicit casting (Rule 55) Non-case label (Rule 60) No &apos;else&apos; at end of &apos;if ... else if&apos; chain. (Rule 63) Boolean value in switch expression (Rule 92) Use of &apos;#undef&apos; is discouraged
    Advisory checks made exclusively for MISRA 2004 are:
    (Rule 19.2) Header file name contains non-standard character. (Rule 19.13) No use of &apos;#&apos; or &apos;##&apos;.
    Messages can be suppressed based on rule number. See also Message 960.</description>
    </rule>
    <rule key="962">
        <name>L0962: Macro &apos;Symbol&apos; defined identically at another location (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The same macro was defined in the same way in two different places in the source code. This is not a good practice since a subsequent change to one of the macros could lead to confusion.</description>
    </rule>
    <rule key="963">
        <name>L0963: Qualifier const or volatile follows/precedes a type; use -fqb/+fqb to reverse the test</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The declarations in the following example are equivalent: //lint +e963 report on qualifier-type inversion extern const char *p; extern char const *p; // Note 963 The qualifier &apos;const&apos; and &apos;volatile&apos; may appear either before or after or even between other declaration specifiers. Many programmers prefer a consistent scheme such as always placing the qualifier before the type. If you enable 963 (using +e963) this is what you will get by default. The message will contain the word &apos;follows&apos; rather than the word &apos;precedes&apos;.
    There is a diametrically opposite convention, viz. that of placing the qualifier after the type. As the message itself reminds the user you will obtain the reverse test if you turn off the fqb (place qualifiers before types) flag. Thus //lint -fqb turn off the Qualifiers Before types flag //lint +e963 report on type-qualifier inversion extern const char *p; // Note 963 extern char const *p; Note that the use of this flag will cause &apos;follows&apos; in the message to be replaced by &apos;precedes&apos; and the alternative option mentioned within the &apos;use&apos; clause is changed to its opposite orientation.
    Dan Saks [36] and Vandevoorde and Josuttis [32, section 1.4] (14. Added Bibliography), provide convincing evidence that this alternative convention is indeed the better one.</description>
    </rule>
    <rule key="964">
        <name>L0964: Header file FileName not directly used in module String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given header file was not used in the given module, however it, itself, included a header file (possibly indirectly) that was used. An example of this is os2.h that is an umbrella header serving only to include other headers. Compare this message with 766.</description>
    </rule>
    <rule key="966">
        <name>L0966: Indirectly included header file &apos;FileName&apos; not used by module &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The header file given by FileName was unused directly or indirectly in a given module outside of its group. It was not, however, directly included by the module and so may not easily be excluded without disturbing the header including it. Since this header may be included in other places caution is advised. This message is a weaker version of 766.</description>
    </rule>
    <rule key="967">
        <name>L0967: Header file &apos;FileName&apos; does not have a standard include guard</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>You may protect against the repeated inclusion of headers by means of a standard include guard having the following form: #ifndef Name #define Name ... #endif The header file cited in the message does not have such a guard. It is standard practice in many organizations to always place include guards within every header.
    See Warning 451 in Section 13.3 for more information about header include guards.</description>
    </rule>
    <rule key="970">
        <name>L0970: Use of modifier or type &apos;Name&apos; outside of a typedef</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some standards require the use of type names (defined in typedef&apos;s) in preference to raw names used within the text of the program. For example they may want you to use INT32 rather than int where INT32 is typedef&apos;s as:
    typedef int INT32;
    This message is normally issued for the standard intrinsic types: bool, char, wchar_t, int, float, double, and for modifiers unsigned, signed, short and long. You may enable this message and then suppress the message for individual types to obtain special effects. For example the following will enable the message for all but bool.
    +e970 -esym(970,bool)</description>
    </rule>
    <rule key="971">
        <name>L0971: Use of &apos;char&apos; without &apos;signed&apos; or &apos;unsigned&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The &apos;char&apos; type was specified without an explicit modifier to indicate whether the char was signed or unsigned. The plain char type can be regarded by the compiler as identifying a signed or an unsigned quantity whichever is more efficient to implement. Because of this ambiguity, some standards do not like the use of char without an explicit modifier to indicate its signedness.</description>
    </rule>
    <rule key="973">
        <name>L0973: Unary operator in macro &apos;Symbol&apos; not parenthesized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A unary operator appearing in an expression-like macro was found to be not parenthesized. For example:
    #define N -1
    The user may prefer to parenthesize such things as:
    #define N (-1)
    This has been placed in the elective note category because we cannot find an instance when this really produces a problem. The important case of unparenthesized binary operators is covered with message 773.</description>
    </rule>
    <rule key="974">
        <name>L0974: Worst case function for stack usage: String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message, issued at global wrap-up, will report on the function that requires the most stack. The stack required consists of the amount of auto storage the function requires plus the amounts required in any chain of functions called. The worst case chain is always reported.
    To obtain a report of all the functions, use the +stack option.
    Reasonable allowances are made for function call overhead and the stack requirements of external functions. These assumptions can be controlled via the +stack option.
    If recursion is detected it will be reported here, as this is considered worse than any finite case. The next worse case is that the stack can&apos;t be determined because a function makes a call through a function pointer. The function is said to be non-deterministic. If neither of these conditions prevail, the function that heads the worst case chain of calls will be reported upon.
    The message will normally provide you with the name of a called function. If the function is recursive this will provide you with the first call of a recursive loop. To determine the full loop, you will need a full stack report as obtained with the +stack option. You need a suboption of the form &amp;file=file to specify a file which will contain a record for each function for which a definition was found. You will be able to follow the chain of calls to determine the recursive path.
    If you can assure yourself through code analysis that there is an upper bound to the amount of stack utilized by some recursive function, then you can employ the +stack option to specify the bound for this function. The function will no longer be considered recursive but rather finite. In this way, possibly through a sequence of options, you can progressively eliminate apparent recursion and in that way arrive at a safe upper bound for stack usage. Similar considerations apply for non-deterministic functions.</description>
    </rule>
    <rule key="975">
        <name>L0975: Unrecognized pragma &apos;Name&apos; will be ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first identifier after #pragma is considered the name of the pragma. If the name is unrecognized then the remainder of the line is ignored. Since the purpose of #pragma is to allow for compiler-dependent communication it is not really expected that all pragmas will be understood by all third-party processors of the code. Thus, this message does not necessarily indicate that there is anything wrong and could easily be supressed entirely.
    Moreover, if the pragma occurs in a libary header this message would not normally be issued because the option -wlib(1) would be in effect (this option is present in all of our compiler option files).
    But if the pragma occurs in user code then it should be examined to see if there is something there that might interest a lint processor. There are a variety of facilities to deal with pragmas; in particular, they can be mapped into languistic constructs or lint options or both. See 3.5 pragmas push_macro and pop_macro and 3.6 Casting pragmas as macros.</description>
    </rule>
    <rule key="1001">
        <name>L1001: Scope &apos;Name&apos; must be a struct or class name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In an expression of the form X::Y, X must be a class name. [11, ?10.4]</description>
    </rule>
    <rule key="1002">
        <name>L1002: &apos;this&apos; must be used in class member function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The keyword this refers to the class being passed implicitly to a member function. It is invalid outside a class member function. [11, ?5.1]</description>
    </rule>
    <rule key="1003">
        <name>L1003: &apos;this&apos; may not be used in a static member function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static member function receives no this pointer. [11, ?9.4]</description>
    </rule>
    <rule key="1004">
        <name>L1004: Expected a pointer to member after .* or -&gt;*</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The .* and -&gt;* operators require pointer to members on the right hand side. [11, ?5.5]</description>
    </rule>
    <rule key="1005">
        <name>L1005: Destructor declaration requires class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>While expecting a declaration a &apos;~&apos; character was encountered. This was presumed to be the start of a destructor. However no class was specified. [11, ?12.4]</description>
    </rule>
    <rule key="1006">
        <name>L1006: Language feature &apos;String&apos; not supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated feature, while not supported in the current version, will hopefully be supported in future versions of the product.</description>
    </rule>
    <rule key="1007">
        <name>L1007: Pure specifier for function &apos;Symbol&apos; requires a virtual function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An &apos;=&apos; was found after a declaration. Was this the start of a pure specifier? The declaration was not that of a member function which it must be. Also, the member function should be virtual. [11, ?10.3]</description>
    </rule>
    <rule key="1008">
        <name>L1008: Expected &apos;0&apos; to follow &apos;=&apos;, text ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some nonstandard extensions to C++ allow integers to follow &apos;=&apos; for declarations of member functions. If you are using such extensions simply suppress this message. If only library headers are using this extension use -elib(1008). [11, ?10.3]</description>
    </rule>
    <rule key="1009">
        <name>L1009: operator String not redefinable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The cited operator, one of &apos;.*&apos;, &apos;?&apos;, &apos;::&apos; or &apos;.&apos;, may not be overloaded. [11, ?13.4]</description>
    </rule>
    <rule key="1010">
        <name>L1010: Expected a type or an operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Following the keyword operator the parser expected either an operator (including new, delete, (), [], comma) or a type. [11, ?13.4 and ?12.3.2]</description>
    </rule>
    <rule key="1011">
        <name>L1011: Conversion Type Name too long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An upper limit of 50 characters has been reached on a conversion type name.</description>
    </rule>
    <rule key="1012">
        <name>L1012: Type not needed before &apos;operator type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The return type of a function introduced with &apos;operator Type&apos; is Type and may not be preceded with the same or any other Type. [11, ?12.3.2]</description>
    </rule>
    <rule key="1013">
        <name>L1013: Symbol &apos;Name&apos; not a member of class &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The second operand of a scope operator or a &apos;.&apos; or &apos;-&gt;&apos; operator is not a member of the class (struct or union) expressed or implied by the left hand operand. [11, ?3.2]</description>
    </rule>
    <rule key="1014">
        <name>L1014: Explicit storage class not needed for member function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An explicit Symbol storage class such as extern or static was given in a separate definition of a class member. The storage class is effectively defined by its appearance within the class and may not be restated at definition time.</description>
    </rule>
    <rule key="1015">
        <name>L1015: Symbol &apos;Name&apos; not found in class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In an expression of the form X::Y, Y must be a member of X or of a public or protected base class of X. [11, ?10.4]</description>
    </rule>
    <rule key="1016">
        <name>L1016: Symbol &apos;Symbol&apos; is supposed to denote a class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a base-specifier an identifier is supposed to specify a base class. However, the identifier was not previously declared in this module. [11, ?10]</description>
    </rule>
    <rule key="1017">
        <name>L1017: conflicting access-specifier &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two different access specifiers were given in a simple base-specifier. [11, ?10]</description>
    </rule>
    <rule key="1018">
        <name>L1018: Expected a type after &apos;new&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In an expression involving new, a type is expected after possibly processing a placement. None was found. [11, ?5.3.3]</description>
    </rule>
    <rule key="1019">
        <name>L1019: Could not find match for function &apos;Symbol(String)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In attempting to find a match between a set of overloaded functions or operators (name given as Symbol) and an actual argument list (provided as String) no match could be found. [11, ?13.2]</description>
    </rule>
    <rule key="1020">
        <name>L1020: template specialization for &apos;Symbol&apos; declared without a &apos;template&lt;&gt;&apos; prefix</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A class template specialization is generally preceded by a &apos;template&lt;&gt;&apos; clause as in: template&lt; class T &gt; class A { }; // a template template&lt;&gt; class A&lt;int&gt; { }; // a specialization If the &apos;template&lt;&gt;&apos; is omitted, you will get this message but it will still be interpreted as a specialization. Before the standardization of template syntax was completed, a template specialization did not require this clause and its absence is still permitted by some compilers.</description>
    </rule>
    <rule key="1022">
        <name>L1022: Function: &apos;String&apos; must be a class member</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There are four operators which may not be defined except as class members. These are:
    = () [] -&gt;
    The parameter String indicates which it is. [11, ?13.4.3 and ?13.4.6]</description>
    </rule>
    <rule key="1023">
        <name>L1023: Call String(String) is ambiguous; candidates: String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to an overloaded function or operator is ambiguous. The candidates of choice are provided in the message. [11, ?13.2]</description>
    </rule>
    <rule key="1024">
        <name>L1024: No function has same argument count as &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to an overloaded function could not be resolved successfully because no function is declared with the same number of arguments as in the call. [11, ?13.2]</description>
    </rule>
    <rule key="1025">
        <name>L1025: No function matches invocation &apos;Name&apos; on arg no. Integer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to an overloaded function could not be resolved because each declared function has a type incompatibility with the indicated argument. [11, ?13.2]</description>
    </rule>
    <rule key="1026">
        <name>L1026: Undominated function &apos;String&apos; does not dominate &apos;String&apos; on call to &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to an overloaded function could not be resolved because no one function dominates all others. This is a subtle issue in the overload resolution process. The selected function must be strictly better than any non-selected function in at least one argument. [11, ?13.2]</description>
    </rule>
    <rule key="1027">
        <name>L1027: Non-consecutive default arguments in function &apos;String&apos;, assumed 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Default arguments need to be consecutive. For example
    void f(int i=0, int j, int k=0);
    is illegal. [11, ?8.2.6]</description>
    </rule>
    <rule key="1028">
        <name>L1028: Last argument not default in first instance of function &apos;String&apos;, assumed 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If any argument of a function is given a default value then all subsequent arguments need to be given a default value. [11, ?8.2.6]</description>
    </rule>
    <rule key="1029">
        <name>L1029: Default argument repeated in function &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A default value for a given argument for a given function should only be given once. [11, ?8.2.6]</description>
    </rule>
    <rule key="1030">
        <name>L1030: Not all arguments after arg no. Integer are default in function &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An argument that has a default value must either be followed by another argument that has a default value, or must be the last argument. [11, ?8.2.6]</description>
    </rule>
    <rule key="1031">
        <name>L1031: Local variable &apos;Symbol&apos; used in default argument expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Default values for arguments may not use local variables. [11, ?8.2.6]</description>
    </rule>
    <rule key="1032">
        <name>L1032: Member &apos;String&apos; cannot be called without object</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There was an attempt to call a non-static member function without specifying or implying an object that could serve as the basis for the this pointer. If the member name is known at compile time it will be printed with the message. [11, ?5.24]</description>
    </rule>
    <rule key="1033">
        <name>L1033: Static member functions cannot be virtual</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>You may not declare a static member function virtual. [11, ?10.2]</description>
    </rule>
    <rule key="1034">
        <name>L1034: Static member &apos;Symbol&apos; is global and cannot be redefined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This can come as a surprise to the novice C++ programmer. The word &apos;static&apos; within a class definition is used to describe a member that is alone and apart from any one object of a class. But such a member has program scope not file scope. The word &apos;static&apos; outside a class definition implies file scope not program scope. [11, ?9.4]</description>
    </rule>
    <rule key="1035">
        <name>L1035: Non-static member &apos;Symbol&apos; cannot initialize a default argument</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A default argument cannot be initialized from a class member unless an instantiation of the class is provided. [11, ?8.2.6]</description>
    </rule>
    <rule key="1036">
        <name>L1036: ambiguous reference to constructor; candidates: &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is more than one constructor that can be used to make a desired conversion. [11, ?12.3.2]</description>
    </rule>
    <rule key="1037">
        <name>L1037: ambiguous reference to conversion function; candidates: &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is more than one conversion function (of the form operator type () ) that will perform a desired conversion. [11, ?12.3.2]</description>
    </rule>
    <rule key="1038">
        <name>L1038: type &apos;Name&apos; not found, nested type &apos;Name::String&apos; assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>We have found what appears to be a reference to a type but no such type is in scope. We have, however, been able to locate a type buried within another class. Is this what the user intended? If this is what is intended, use full scoping. If your compiler doesn&apos;t support the scoping, suppress with -esym. [11, ?3.2]</description>
    </rule>
    <rule key="1039">
        <name>L1039: Symbol &apos;Symbol&apos; is not a member of class &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a declaration for the symbol X::Y, Y was not previously established as a member of X. [11, ?10.4]</description>
    </rule>
    <rule key="1040">
        <name>L1040: Symbol &apos;Symbol&apos; is not a legal declaration within class &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A declaration of the symbol X::Y appears within a class definition (other than for class X). It is not a friend declaration. Therefore it is in error.</description>
    </rule>
    <rule key="1041">
        <name>L1041: Can&apos;t declare &apos;String&apos;, assumed &apos;operator String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message can be given with String equal to new or delete. A common mistake with beginning C++ programmers is to declare (and/or define) new when they mean to define operator new. We presume this was what was intended. [11, ?12.5]</description>
    </rule>
    <rule key="1042">
        <name>L1042: At least one class-like operand is required with Name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In defining (or declaring) an operator you must have at least one class as an operand. [11, ?13.4]</description>
    </rule>
    <rule key="1043">
        <name>L1043: Attempting to &apos;delete&apos; a non-pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression being delete&apos;d is a non-pointer, non-array. You may only delete that which was created with an invocation of new. [11, ?5.3.4]</description>
    </rule>
    <rule key="1046">
        <name>L1044: member &apos;Symbol&apos;, referenced in a static function, requires an object</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The Symbol is a non-static member of a class and hence requires a class instantiation. None is in sight. [10, ?9.4]</description>
    </rule>
    <rule key="1047">
        <name>L1047: a template declaration must be made at file scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A template declaration may not appear within a function or within a class. [10, ?14.1]</description>
    </rule>
    <rule key="1048">
        <name>L1048: expected a constant expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a template argument list a constant expression was expected. An expression of the form T&lt;arg1,arg2,...&gt; was encountered and arg i for some i corresponds to a non-class parameter in the original template declaration. Such arguments need to be constants. [10, ?14.5]</description>
    </rule>
    <rule key="1049">
        <name>L1049: Too many template arguments</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There are more arguments in the template class-name than there were parameters in the original template declaration. [10, ?14.5]</description>
    </rule>
    <rule key="1050">
        <name>L1050: expected a template argument list &apos;&lt;...&gt;&apos; for template &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The name of a class template identified by Symbol was used without specifying a template argument list. [10, ?14.5]</description>
    </rule>
    <rule key="1051">
        <name>L1051: Symbol &apos;Name&apos; is both a function and a variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Whereas it is possible to overload a function name by giving it two different parameter lists, it is not possible to overload a name in any other way. In particular a function name may not also be used as a variable name. [11, ?9.2]</description>
    </rule>
    <rule key="1052">
        <name>L1052: a type was expected, &apos;class&apos; assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A template parameter list consists of 2 kinds of parameters: class identifier and type. The parameter did not begin with class and was not a type. [10, ?14.5]</description>
    </rule>
    <rule key="1053">
        <name>L1053: &apos;String&apos; cannot be distinguished from &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An overloaded function name had two parameter lists that were so close that discrimination between them would be difficult and error prone. Eg. void f(const int); and void f(int); [11, ?13]</description>
    </rule>
    <rule key="1054">
        <name>L1054: template variable declaration expects a type, int assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression of the form T&lt;arg,arg,...&gt; was encountered. One of the arguments corresponding to a type parameter in the original template declaration is not a type. [10, ?14.5]</description>
    </rule>
    <rule key="1055">
        <name>L1055: Symbol &apos;Symbol&apos; undeclared, assumed to return int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Whereas in C you may call a function without a prior declaration, in C++ you must supply such a declaration. For C programs you would have received an Informational message (718) in this event. [11, ?5.2.2]</description>
    </rule>
    <rule key="1056">
        <name>L1056: assignment from void * is not allowed in C++</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Whereas in C you may assign from void* to any other (data) pointer without a diagnostic, in C++ you may not do this. It will require a cast. [11, ?4.6]</description>
    </rule>
    <rule key="1057">
        <name>L1057: member &apos;Symbol&apos; cannot be used without an object</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member referenced via scope operator cannot be used in the absence of this pointer. [11, ?5.2.4]</description>
    </rule>
    <rule key="1058">
        <name>L1058: Initializing a non-const reference &apos;Symbol&apos; with a non-lvalue</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A reference is normally initialized with an lvalue. If you attempt to initialize a reference with a non-lvalue, a temporary is created to serve as a surrogate lvalue. However, modifications made to the temporary will be lost. This was legal at one time and is now illegal. Make the reference a const if you can. You may be initializing a reference without realizing it. A member function has an implicit parameter which is taken to be a reference to its object. If this is the situation make the member const. That is, use void f(...) const; rather than void f(...);</description>
    </rule>
    <rule key="1059">
        <name>L1059: Can&apos;t convert from &apos;Type&apos; to &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to initialize a reference with an object having a type other than the target type but no function could be found to effect the required conversion. [11, ?12.3]</description>
    </rule>
    <rule key="1060">
        <name>L1060: String member &apos;Symbol&apos; is not accessible to non-member non-friend functions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is an attempt to access a private or protected member of a class and the access is considered a violation of the access rules (although everything else proceeds as though no violation occurred). Specifically, the function attempting to make access must be a friend or member of the nominal class through which the access is made. See also 1061. [11, ?11]</description>
    </rule>
    <rule key="1061">
        <name>L10601: String member &apos;Symbol&apos; is not accessible through non-public inheritance</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is an attempt to access a private, protected or public member (the text of the message indicates which kind as well as which member) of a class through a class derived from the original. There is an access violation (see 1060 for the more common access violation) critically dependent on the fact that the inheritance relationship is non-public. [11, ?11.2]</description>
    </rule>
    <rule key="1062">
        <name>L1062: template must be either a class or a function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Following template &lt; arglist &gt; the parser expects to find either the token class or a function declaration or definition. [10, ?14.5]</description>
    </rule>
    <rule key="1063">
        <name>L1063: Argument to copy constructor for class &apos;Symbol&apos; should be a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constructor for a class closely resembles a copy constructor. A copy constructor for class X is typically declared as:
    X( const X &amp;)
    If you leave off the &apos;&amp;&apos; then a copy constructor would be needed just to copy the argument into the copy constructor. This is a runaway recursion. [11, ?12.1]</description>
    </rule>
    <rule key="1064">
        <name>L1064: Template parameter list for template &apos;Symbol&apos; inconsistent with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The template parameter list for a template function declaration or definition is inconsistent with that of a prior declaration or definition. [10, ?14.5]</description>
    </rule>
    <rule key="1065">
        <name>L1065: Symbol &apos;Symbol&apos; not declared as &quot;C&quot; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A symbol previously declared as extern &quot;C&quot; in some other module is not declared as extern &quot;C&quot; in this module. This could be the source of very mysterious linker diagnostics since a name declared as extern &quot;C&quot; is not subject to the name mangling procedures that strictly C++ functions are. [11, ?7.4]</description>
    </rule>
    <rule key="1066">
        <name>L1066: Symbol &apos;Symbol&apos; declared as &quot;C&quot; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A symbol is being declared as extern &quot;C&quot; and was not so declared in some other module. This could be the source of very mysterious linker diagnostics since a name declared as extern &quot;C&quot; is not subject to the name mangling procedures that strictly C++ functions are. [11, ?7.4]</description>
    </rule>
    <rule key="1067">
        <name>L1067: invalid prototype for function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Whenever operator delete or operator delete [] is defined its first parameter must be declared as void *. For member functions an optional second parameter may be size_t. [10, ?12.5].</description>
    </rule>
    <rule key="1068">
        <name>L1068: Symbol &apos;Symbol&apos; can not be overloaded</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>operator delete or operator delete [] can be redefined but not overloaded. There can only be one operator delete and one operator delete [] but neither of these can be overloaded. [10, ?12.5].</description>
    </rule>
    <rule key="1069">
        <name>L1069: Symbol &apos;Name&apos; is not a base class of class &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a constructor initialization list a name was found that did not correspond to either a direct base class of the class being defined or a member of the class.</description>
    </rule>
    <rule key="1070">
        <name>L1070: No scope in which to find symbol &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This could arise in an expression of the form X::Y where X does not represent a valid scope.</description>
    </rule>
    <rule key="1071">
        <name>L1071: Constructors and destructors can not have return type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Constructors and destructors may not be declared with a return type, not even void. See ARM Section 12.1 and 12.4.</description>
    </rule>
    <rule key="1072">
        <name>L1072: Reference variable &apos;Symbol&apos; must be initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A reference variable must have an initializer at the point of declaration.</description>
    </rule>
    <rule key="1073">
        <name>L1073: Insufficient number of template parameters for &apos;Symbol&apos;; &apos;String&apos; assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A (class) template instantiation did not have a sufficient number of parameters. String indicates what the missing argument is presumed to be.</description>
    </rule>
    <rule key="1074">
        <name>L1074: Expected a namespace identifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a declaration of the form: namespace name = scoped-identifier
    the scoped-identifier must identify a namespace.</description>
    </rule>
    <rule key="1075">
        <name>L1075: Ambiguous reference to symbol &apos;Symbol&apos; and symbol &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two namespaces contain the same name. A reference to such a name could not be disambiguated. You must fully qualify this name in order in indicate which name is intended.</description>
    </rule>
    <rule key="1076">
        <name>L1076: Anonymous union assumed to be &apos;static&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Anonymous unions need to be declared static. This is because the names contained within are considered local to the module in which they are declared.</description>
    </rule>
    <rule key="1077">
        <name>L1077: Could not evaluate default template parameter &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The evaluation of template parameters is deferred until needed. Thus:
    template&lt; class T = abc &gt; class A { /* ... */ };
    will be greeted with an Error 1077 only if an instantiation of A&lt;&gt; requires evaluation of the default argument and if that evaluation cannot be made. In that event int is assumed for type parameters and 0 is assumed for object parameters.</description>
    </rule>
    <rule key="1078">
        <name>L1078: class &apos;Symbol&apos; should not have itself as a base class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The following situation will trigger this message.
    class A : public A { };
    You can&apos;t define A in terms of itself as there is no escape from the recursive plummet.</description>
    </rule>
    <rule key="1079">
        <name>L1079: Could not find &apos;&gt;&apos; or &apos;,&apos; to terminate template parameter at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The default value for a template parameter appears to be malformed. For example, suppose the user mistakenly substituted a &apos;]&apos; for a &apos;&gt;&apos; producing the following: template &lt;class T = A&lt; int ] &gt; class X { };
    This will cause PC-lint/FlexeLint to process to the end of the file looking (in vain) for the terminating pointy bracket. Not finding it will cause this message to be printed. Fortunately, the message will bear the Location of the malformed template.</description>
    </rule>
    <rule key="1080">
        <name>L1080: Definition for class &apos;Name&apos; is not in scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message would be issued whenever a class definition were required and it were not available. For example:
    class X; // declare class X X *p; // OK, no definition required X a; // Error 1080</description>
    </rule>
    <rule key="1081">
        <name>L1081: Object parameter does not contain the address of a variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A template argument that is passed to a pointer parameter is supposed to identify a symbol. The expression passed does not do so. For example template&lt; int *P &gt; class A { ... }; int a[10]; A&lt; a+2 &gt; x; // a+2 does not represent a symbol</description>
    </rule>
    <rule key="1082">
        <name>L1082: Object parameter for a reference type should be an external symbol</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A template argument that is passed to a reference parameter is supposed to identify an external symbol. The expression passed does not do so. For example template&lt; int &amp;I &gt; class A { ... }; int a[10]; A&lt; a[2] &gt; x; // a[2] does not represent a symbol See also message 1081.</description>
    </rule>
    <rule key="1083">
        <name>L1083: Ambiguous conversion between 2nd and 3rd operands of conditional operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If the 2nd operand can be converted to match the type of the 3rd, and the 3rd operand can be converted to match the type of the 2nd, then the conditional expression is considered ill-formed.</description>
    </rule>
    <rule key="1084">
        <name>L1084: Ambiguous use of template-id for instantiation of &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When the language calls for a class template to be instantiated and the primary template is &quot;overloaded&quot; via one or more partial specializations, there is an attempt to see if the template arguments match any of those partial specializations. (Note, explicit specializations would have been considered before determining that the class definition needs to be generated by way of instantiation.) If multiple partial specializations match then:
    - If one of the matching partial specializations is more specialized than all others then it is used for the instantiation.
    - Otherwise, the program is ill-formed, so Lint issues message 1084.
    In the message, the matching partial specializations are provided as the list of candidates. Example: template&lt;class T1, class T2, int I&gt; class A {}; //#1 template&lt;class T1, class T2, int I&gt; class A&lt;T1*, T2, I&gt; {}; //#2 template&lt;class T1, class T2, int I&gt; class A&lt;T1, T2*, I&gt; {}; //#3 A&lt;int*, int*, 2&gt; a; // ambiguous: matches #2 and #3 // (and neither template is more specialized than the other)</description>
    </rule>
    <rule key="1085">
        <name>L1085: Invalid definition of &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to define a member of a template before the template was defined. Example: template&lt;class T, class U&gt; struct A { void }; template&lt;class U, class T&gt; void A&lt;T,U&gt;::f(){} // Error 1085 In this case, the template argument list is out of order; T and U have been interchanged.</description>
    </rule>
    <rule key="1086">
        <name>L1086: Compound literals may only be used in C99 programs</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Compound literals are defined in C99 ([4] ISO/IEC 9899:1999). However, some compilers allow the use of compound literals in C++. If you plan to port your code to another C++ compiler, then it may be worthwhile to heed this message; otherwise it may be safely suppressed with -e1086.</description>
    </rule>
    <rule key="1087">
        <name>L1087: Previous declaration of &apos;Name&apos; (Location) is incompatible with &apos;Name&apos; (Location) which was introduced by the current using-declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A using declaration such as:
    using NS::name;
    seems to be in error. It introduces a name that clashes with the name introduced earlier by another using-declaration. E.g.: namespace N { int i;} namespace Q { void i();} using N::i; using Q::i; // Error 1087 issued here.</description>
    </rule>
    <rule key="1088">
        <name>L1088: A using-declaration must name a qualified-id</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This error is issued when a using-declaration references a name without the :: scope resolution operator; e.g.: class A { protected: int n; }; class B : public A { public: using n; // Error 1088: should be &apos;using A::n;&apos; }; See Section 14. Added Bibliography, [34], 7.3.3 namespace.udecl.</description>
    </rule>
    <rule key="1089">
        <name>L1089: A using-declaration must not name a namespace</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This error is issued when the rightmost part of the qualified-id in a using-declaration is the name of a namespace. E.g.: namespace N { namespace Q{ void g(); } } void f() { using ::N::Q; // Error 1089 Q::g(); } Instead, use a namespace-alias-definition: namespace N { namespace Q{ void g(); } } void f() { namespace Q = ::N::Q; // OK Q::g(); // OK, calls ::N::Q::g(). } See Section 14. Added Bibliography, [35], Issue 460.</description>
    </rule>
    <rule key="1090">
        <name>L1090: A using-declaration must not name a template-id</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This error is issued when the rightmost part of the qualified-id in a using-declaration is a template-id. E.g.: template&lt;class T&gt; class A { protected: template&lt;class U&gt; class B{}; };
    struct D : public A&lt;int&gt; { public: using A&lt;int&gt;::B&lt;char*&gt;; // Error 1090 };
    D::B&lt;char*&gt; bc; Instead, refer to the template name without template arguments: template&lt;class T&gt; class A { protected: template&lt;class U&gt; class B{}; };
    struct D : public A&lt;int&gt; { public: using A&lt;int&gt;::B; // OK };
    D::B&lt;char*&gt; bc; // OK See Section 14. Added Bibliography, [34], 7.3.3 namespace.udecl.</description>
    </rule>
    <rule key="1091">
        <name>L1091: &apos;Name&apos; is not a base class of &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This error is issued when the nested-name-specifier of the qualified-id in a using-declaration does not name a base class of the class containing the using-declaration; e.g.: struct N { void f(); }
    class A { protected: void f(); }; class B : A { public: using N::f; // Error 1091 }; See Section 14. Added Bibliography, [35], Issue 400.</description>
    </rule>
    <rule key="1092">
        <name>L1092: A using-declaration that names a class member must be a member-declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This error is issued when the nested-name-specifier of the qualified-id in a using-declaration names a class but the using-declaration does not appear where class members are declared. E.g.: struct A { void f(); };
    struct B : A{ void g() { using A::f; // Error 1092 } }; See Section 14. Added Bibliography, [34], 7.3.3 namespace.udecl.</description>
    </rule>
    <rule key="1093">
        <name>L1093: A pure specifier was given for function &apos;Symbol&apos; which was not declared virtual</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pure specifier (&quot;= 0&quot;) should not be placed on a function unless the function had been declared &quot;virtual&quot;.</description>
    </rule>
    <rule key="1094">
        <name>L1094: Could not find &apos;)&apos; or &apos;,&apos; to terminate default function argument at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A default function argument was found which did not seem to include any terminating tokens (the &apos;,&apos; separating arguments or &apos;)&apos; ending the function&apos;s argument list). Consequently, Lint continued scanning to the end of the file. Location indicates where the default argument began.</description>
    </rule>
    <rule key="1095">
        <name>L1095: Effective type &apos;Type&apos; of non-type template parameter #Integer (corresponding to argument expression &apos;String&apos;) depends on an unspecialized parameter of this partial specialization</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The ISO C++ Standard says that &quot;the type of a template parameter corresponding to a specialized non-type argument shall not be dependent on a parameter of the specialization.&quot; See Section 14. Added Bibliography, [34], 14.5.4 temp.class.spec. Example: // primary template: template&lt;class T, T N, class U&gt; struct B;
    // PS #1: template&lt;class U&gt; struct B&lt;int,257,U&gt;; // Ok
    // PS #2: template&lt;class U&gt; struct B&lt;bool,257,U&gt;; // Ok, same as: template&lt;class U&gt; struct B&lt;bool,true,U&gt;; // Ok (redeclaration of #2)
    // PS #3: template&lt;class U&gt; struct B&lt;T,257,U&gt;; // Error 1095 here In PS #3, the value 257 is the &apos;specialized non-type argument&apos; and its corresponding parameter is &apos;N&apos; whose type is T which was not made concrete. But in PS #1 and PS #2, T was given the concrete types &apos;int&apos; and &apos;bool&apos;, respectively.</description>
    </rule>
    <rule key="1096">
        <name>L1096: A target ctor must be the only mem-initializer in the mem-initializer-list of a delegating ctor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>C++0x requires that if a constructor delegates to another constructor, then the mem-initializer (the region between the colon and the function body) must contain only one item, and that item must be a call to another constructor (which is called the &quot;target constructor&quot;). Example: struct A { int n; A(int); A( const A&amp; p) : A(p.n) {} // Ok A() : n(42), A(32) // Error 1096 {} };</description>
    </rule>
    <rule key="1097">
        <name>L1097: Delegating ctor delegates directly to itself, causing infinite recursion</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Example: struct A { int n; A(int x) : A(x){} // Error 1097 };</description>
    </rule>
    <rule key="1098">
        <name>L1098: Function template specialization &apos;Symbol&apos; does not match any function template</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for a declaration where the user apparently intended to name a specialization of a function template (e.g., in an explicit specialization, an explicit instantiation or a friend declaration of specialization), but no previously-declared function template is matched. Example: template&lt;class T&gt; void f( const T&amp; ); // #1
    struct A{}; template&lt;&gt; void f( const A&amp; ); // Ok // (A is the deduced argument to T.)
    struct B{}; template&lt;&gt; void f( const B ); // Error 1097. // (A template argument cannot be deduced for T.)</description>
    </rule>
    <rule key="1099">
        <name>L1099: Ambiguous function template specialization &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for a declaration where the user apparently intended to name a specialization of a function template (e.g., in an explicit specialization, an explicit instantiation or a friend declaration of specialization), but the specialization matches multiple function templates, and none of the matched templates is more specialized than all of the other matching templates. The candidates (i.e., the matching templates) are provided in the message. Example: template&lt;class T&gt; struct A {};
    template&lt;class T, class U&gt; void f( T*, U ); // #1 template&lt;class T, class U&gt; void f( T, A&lt;U&gt; ); // #2
    struct B{}; template&lt;&gt; void f( B, A&lt;B&gt; ); // Ok // #1 does not match but #2 does.
    template&lt;&gt; void f( char*, A&lt;int&gt; ); // Error 1099 // Both #1 and #2 match and neither is more specialized than the // other. This situation can be avoided in at least a couple of ways. One way is to explicitly specify one or more template arguments. Example: // continuing from above... template&lt;&gt; void f&lt;char*&gt;( char*, A&lt;int&gt; ); // Ok // #1 does not match but #2 does. Another way is to use SFINAE tactics in the declaration of one or more function templates, e.g. with boost::enable_if.</description>
    </rule>
    <rule key="1100">
        <name>L1100: Declaration of &apos;Symbol&apos; does not declare an explicit specialization, explicit instantiation or friend</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a declaration that explicitly specifies template arguments with angle brackets immediately after the name of a function template, the declaration must declare either an explicit specialization, explicit instantiation or friend. (Note, an explicit specialization always begins with &apos;template&lt;&gt;&apos; and an explicit instantiation always begins with &apos;template&apos;&lt;/name&gt;&lt;description&gt;-without angle brackets after the keyword &apos;template&apos;.) template&lt;class T&gt; struct A {};
    template&lt;class T&gt; inline void f( A&lt;T&gt; ); // #1 void f( A&lt;int&gt; ); // #2 // Ok, declares an ordinary function
    void f&lt;char&gt;( A&lt;char&gt; ); // Error 1100</description>
    </rule>
    <rule key="1101">
        <name>L1101: Type of variable &apos;Symbol&apos; cannot be deduced from its initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Example: int f(void); int f(char*); auto n = f; // Error In terms of deduction, this is equivalent to: int f(void); int f(char*); template&lt;class T&gt; void g( const T&amp; ); void h( void ) { g( f ); // Error } Here, &apos;f&apos; refers to multiple overloaded functions, so it is an ambiguous reference and T cannot be deduced. (Code like this could still be well-formed however, e.g. if g is overloaded with a non-template function whose parameter type is &apos;ptr-to-function returning int taking (char*)&apos;.)</description>
    </rule>
    <rule key="1102">
        <name>L1102: auto type deduced inconsistently: &apos;Type&apos; for &apos;Symbol&apos; but &apos;Type&apos; for &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When multiple variables are defined in the same declaration, and when that declaration uses the keyword auto as the type-specifier (a feature of C++0x), the type for which auto is a placeholder must be the same for each variable. Example: float g(void); char* s(); auto a = 42; // Ok, auto is &apos;int&apos; auto b = g(); // Ok, auto is &apos;float&apos; auto c = &apos;q&apos;, *d = s(); // Ok, auto is &apos;char&apos; (for both c and d) auto x = 42, y = g(); // Error 1102 here</description>
    </rule>
    <rule key="1103">
        <name>L1103: Type &apos;Type&apos; is not allowed as an enum-base</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When an enumeration type is declared with an explicit underlying type, that type must be integral. Example: enum A : bool; // ok enum B : short; // ok enum C : unsigned long long; // ok enum D : float; // Error 1103</description>
    </rule>
    <rule key="1104">
        <name>L1104: A reference to enumeration &apos;Symbol&apos; should not use &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Although an enumeration may be declared or defined using a scope indicator or an underlying type indicator, these should not be applied when simply referencing the enumeration. E.g. enum class A { red, green }; enum class A x; // Error -- don&apos;t need &apos;class&apos; enum A : unsigned { red, green }; enum A : unsigned y; // Error -- don&apos;t need &apos;: unsigned&apos;</description>
    </rule>
    <rule key="1105">
        <name>L1105: Use of ref qualification of &apos;Symbol&apos; inconsistent with overloaded function &apos;Symbol&apos; (Location)&quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If an explicit ref qualifier (&apos;&amp;&apos; or &apos;&amp;&amp;&apos;) of a nonstatic member function is employed, an explicit ref qualifier needs to be used with every member of the overload set. Thus: class A { void f(int) &amp;; // ok (so far) void f(int); // 1105 void f(double); // 1105 void g(int); // ok (fresh function) void g(double); // still ok };</description>
    </rule>
    <rule key="1106">
        <name>L1106: Initializing value &apos;String&apos; of enumerator &apos;Name&apos; cannot be represented by the enumeration&apos;s underlying type &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An enumerator is being initialized with a value that is inappropriate to the declared type of the initializer. Example: enum E : unsigned char { e = 256 }; The value 256 cannot be represented by an unsigned char.</description>
    </rule>
    <rule key="1107">
        <name>L1107: Mixing two different kinds of string literals</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Two string literals are being concatenated which have different types. Examples: char *s = u&quot;abc&quot; U&quot;def&quot;; char *q = &quot;L&quot;ghi&quot; u&quot;jkl&quot;; This message is issued for mixing strings of char16_t, char32_t, and/or wchar_t (as shown). Literal string concatenation of any of these with an ordinary character literal is permitted and will receive Informational 707.
    error;1108;Use of deleted function &apos;Symbol&apos; defined at &apos;Location&apos; This message is issued when a deleted function is used. Example: void f( int ) = delete; void f( double ); void g( double d, int n ) { f( d ); // Ok f( n ); // Error }</description>
    </rule>
    <rule key="1110">
        <name>L1110: Cycle detected: explicit application of &apos;Name&apos;::operator-&gt; causes infinite implicit applications of the same operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When an overloaded operator-&gt; is used as in a-&gt;b it is effectively expanded to: a.operator-&gt;()-&gt;b And this expansion repeats until an operator-&gt; is found that does not yield a class type. But in the process of evaluating this expansion, it might be found that one of the operators returns a class type for which an overloaded operator-&gt; was already expanded; in that case, Error 1110 is triggered. Example: struct B; struct A { struct B&amp; operator-&gt;(); }; struct B { struct A&amp; operator-&gt;(); }; int f( A &amp; p ) { p-&gt;g(); } // Error</description>
    </rule>
    <rule key="1111">
        <name>L1111: ISO C++ requires an explicit specialization/instantiation to appear at namespace scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued at the beginning of each explicit specialization/instantiation that does not appear at namespace scope. Example: struct A { template &lt;typename U&gt; struct B {};
    // template &lt;&gt; // Would be ill-formed by ISO C++. // struct B&lt;int&gt; {}; }; template&lt;&gt; struct A::B&lt;int&gt; {}; // Ok. There is an additional limitation with member class templates of class templates. As with members of a non-template class, one cannot write a specialization at class scope. Example: template&lt;typename T&gt; struct G { template &lt;typename U&gt; struct H {}; // template &lt;&gt; // Would be ill-formed by ISO C++. // struct H&lt;int&gt; {}; }; But the language specification does not even allow this to be expressed in a namespace-scope definition; there is no way to write an explicit specialization that is a member of a class template. Example: template&lt;typename T&gt; struct J { template &lt;typename U&gt; struct K {}; }; // template&lt;typename T&gt; // template &lt;&gt; // Would be ill-formed by ISO C++; // struct J&lt;T&gt;::K&lt;int&gt; {}; This is because the rules for explicit specializations say that &apos;template&lt;&gt;&apos; is not allowed to appear after a non-empty template-parameter-list within the same declaration. However, one may write an explicit specialization that is a member of an implicitly-instantiated specialization of a class template. Example: template&lt;typename T&gt; struct L { template &lt;typename U&gt; struct M {}; }; template &lt;&gt; template &lt;&gt; struct L&lt;char&gt;::M&lt;int&gt; {}; // Ok Here, the body of the class L&lt;char&gt; is automatically generated by implicit instantiation (otherwise the reference to &apos;L&lt;char&gt;::M&apos; would be ill-formed), while the body of L&lt;char&gt;::M&lt;int&gt; is provided in the explicit specialization.
    In March of 2009, the ISO C++ committee reviewed a report submitted against this example: struct A { template&lt;class T&gt; struct B; template &lt;class T&gt; struct B&lt;T*&gt; { }; // well-formed template &lt;&gt; struct B&lt;int*&gt; { }; // ill-formed }; While it might seem odd that one is able to write the partial specialization but not the full specialization, the committee (which at the time was in a &quot;feature-freeze&quot; mode and trying to finalize a draft for the next International Standard) decided that this capability would need to be regarded as an &quot;extension&quot;, meaning that it could be considered as a new feature in a future standard but not as a bug-fix for C++0x.
    Note that the Microsoft compiler implements this extension. For that reason, the Lint option -elib(1111) appears in recent versions of our configuration files for Microsoft compilers.</description>
    </rule>
    <rule key="1112">
        <name>L1111: In a declaration, the form &apos;auto D(parms)-&gt;type&apos; is the only valid way to use a trailing-return-type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a declaration, the form &apos;auto D(parms)-&gt;type&apos; (where D is either a name or a parenthesized region) is the only valid way to use a trailing-return-type</description>
    </rule>
    <rule key="1268">
        <name>L1268: Internal Error; contact Gimpel Software</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Internal Error  -- Some inconsistency or contradiction was discovered in the PC-lint/FlexeLint system. This may or may not
    be the result of a user error. This inconsistency should be brought to the attention of Gimpel Software</description>
    </rule>
    <rule key="1401">
        <name>L1401: member &apos;Symbol&apos; (Location) not initialized by constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol was not initialized by a constructor. Was this an oversight?</description>
    </rule>
    <rule key="1402">
        <name>L1402: member &apos;Symbol&apos; (Location) not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol was not initialized prior to use. Either this is in a constructor where it is presumed that no members are pre-initialized or this is after a statement which will remove its initialization such as a delete or a free.</description>
    </rule>
    <rule key="1403">
        <name>L1403: member &apos;Symbol&apos; (Location) not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol was not initialized prior to a point where its address is being passed to a constant pointer. This looks suspicious. Either this is in a constructor where it is presumed that no members are pre-initialized or this is after a statement which will remove its initialization such as a delete or a free.</description>
    </rule>
    <rule key="1404">
        <name>L1404: deleting an object of type &apos;Symbol&apos; before type is defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The following situation was detected:
    class X; ... X *p; ... delete p;
    That is, a placeholder declaration for a class is given and an object of that type is deleted before any definition is seen. This may or may not be followed by the actual class definition:
    class X { ... };
    A delete before the class is defined is dangerous because, among other things, any operator delete that may be defined within the class could be ignored.</description>
    </rule>
    <rule key="1405">
        <name>L1405: Header typeinfo must be included before typeid is used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>According to Section 5.2.8 (para 6) of the C++ standard [10], &quot;If the header &lt;typeinfo&gt; (18.5.1) is not included prior to a use of typeid, the program is ill-formed.&quot; A typeid was found in the program but the required include was not.</description>
    </rule>
    <rule key="1411">
        <name>L1411: Member with different signature hides virtual member &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member function has the same name as a virtual member of a derived class but it has a different signature (different parameter list). This is legal but suspicious, because it looks as though the function would override the virtual function but doesn&apos;t. You should either adjust the parameters of the member so that the signatures conform or choose a different name. See also message 1511.</description>
    </rule>
    <rule key="1412">
        <name>L1412: Reference member &apos;Symbol&apos; is not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A class member typed reference to class (or struct or union) is mentioned in a constructor initializer list. But the class (or struct or union) referenced has no constructor and so is never initialized.</description>
    </rule>
    <rule key="1413">
        <name>L1413: function &apos;Symbol&apos; is returning a temporary via a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It appears that a function (identified as Symbol in the message) declared to return a reference is returning a temporary. According to the C++ standard (Section 12.2), in addressing the issue of binding temporary values to references, says &quot;A temporary bound to the returned value in a function return statement ... persists until the function exits&quot;. Thus the information being returned is not guaranteed to last longer than the function being called.
    It would probably be better to return by value rather than reference. Alternatively, you may return a static variable by reference. This will have validity at least until the next call upon the same function.</description>
    </rule>
    <rule key="1414">
        <name>L1414: Assigning address of auto variable &apos;Symbol&apos; to member of this</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of an auto variable was taken and assigned to a this member in a member function. For example: struct A { char *x; void f() { char y[10]; x = y; // warning 1414 } }; Here the address of y is being passed to member x but this is dangerous (if not ridiculous) since when the function returns, the storage allocated for y is deallocated and the pointer could very easily harm something.</description>
    </rule>
    <rule key="1415">
        <name>L1415: Pointer to non-POD class &apos;Name&apos; passed to function &apos;Symbol&apos; (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-POD class is one which goes beyond containing just Plain Old Data (POD). In particular it may have private or protected data or it may have constructors or destructors or copy assignment. All of these things disqualify it from being a POD. A POD is fully defined in the C++ standard (Clause 9).
    Some functions such as memcpy, memcmp, memmove, etc. are expected to be given only pointers to POD objects. The reason is that only POD objects have the property that they can be copied to an array of bytes and back again with a guarantee that they will retain their original value. (See Section 3.9 of the C++ standard). See also Semantic pod(i) in Section 4. Semantics</description>
    </rule>
    <rule key="1416">
        <name>L1416: An uninitialized reference &apos;Symbol&apos; is being used to initialize reference &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is usually issued when a reference to a member of a class is used to initialize a reference to another member of the same class before the first member was initialized. For example: class C { int &amp;n, &amp;m; C( int &amp;k ) : n(m), m(k) { /* ... */ } }; Here m is initialized properly to be identical to k. However, the initialization of n, taking place, as it does, before m is so initialized, is erroneous. It is undefined what location n will reference.</description>
    </rule>
    <rule key="1417">
        <name>L1417: reference member &apos;Symbol&apos; not initialized by constructor initializer list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when a reference data member of a class does not appear in a mem-initializer. For example, the following code will result in a Warning 1417 for symbol m since a mem-initializer is the only way that m can be reference initialized. class C { int &amp;n, &amp;m; C( int &amp;k ) : n(k) { /* ... */ } };</description>
    </rule>
    <rule key="1419">
        <name>L1419: Destructors should never throw</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A destructor was declared without a throw() specification.  At least one author has warned against throwing exceptions from destructors and the practice can result in undefined behavior.  A safer approach is to provide an explciit throw() for each destructor.</description>
    </rule>
    <rule key="1501">
        <name>L1501: data member &apos;Symbol&apos; has zero size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A data member had zero size. It could be an array of zero length or a class with no data members. This is considered an error in C (Error 43) but in C++ we give this warning. Check your code to make sure this is not an error. Some libraries employ clever templating which will elicit this message. In such a case it is necessary for you to inhibit the message outright (using -e1501) or through a judicious use of -esym(1501,...).</description>
    </rule>
    <rule key="1502">
        <name>L1502: defined object &apos;Symbol&apos; has no nonstatic data members</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable (Symbol) is being instantiated that belongs to a class that contains no data members (either directly or indirectly through inheritance). [11, ?9]</description>
    </rule>
    <rule key="1503">
        <name>L1503: a tagged union is not anonymous</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A tagged union without a declarator appeared within a struct/union declaration. An anonymous union requires no tag. [11, ?9.5]</description>
    </rule>
    <rule key="1504">
        <name>L1504: useless struct declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An untagged struct declaration appeared within a struct/union and has no declarator. It is not treated like an anonymous union. Was this intended?</description>
    </rule>
    <rule key="1505">
        <name>L1505: no access specifier provided, &apos;String&apos; assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A base class specifier provides no access specifier (public, private or protected). An explicit access specifier is always recommended since the default behavior is often not what is expected. For example:
    class A : B { int a; };
    would make B a private base class by default.
    class A : private B { int a; };
    is preferred if that&apos;s what you want. [11, ?11.1]</description>
    </rule>
    <rule key="1506">
        <name>L1506: Call to virtual function &apos;Symbol&apos; within a constructor or destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to a virtual function was found in a constructor or a destructor of a class. If this class is a base class of some other class (why else make a virtual call?), then the function called is not the overriding function of the derived class but rather the function associated with the base class. If you use an explicit scope operator this message will not be produced. [20, ?9]</description>
    </rule>
    <rule key="1507">
        <name>L1507: attempting to &apos;delete&apos; an array</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The type of an object to be delete&apos;d is usually a pointer. This is because operator new always returns a pointer and delete may only delete that which has been allocated via new. Perhaps this is a programmer error attempting to delete an auto array? [19]</description>
    </rule>
    <rule key="1509">
        <name>L1509: base class destructor for class &apos;Name&apos; is not virtual</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated class is a base class for some derived class. It has a destructor which is not virtual. Was this a mistake? It is conventional to virtualize destructors of base classes so that it is safe to delete a base class pointer. [19]</description>
    </rule>
    <rule key="1510">
        <name>L1510: base class &apos;Name&apos; has no destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated class is a base class for some derived class that has a destructor. The base class does not have a destructor. Is this a mistake? The difficulty that you may encounter is this; if you represent (and manipulate) a heterogeneous collection of possibly derived objects via a pointer to the base class then you will need a virtual base class destructor to invoke the derived class destructor. [13, ?4]</description>
    </rule>
    <rule key="1511">
        <name>L1511: Member hides non-virtual member &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named member of a derived class hides a similarly named member of a base class. Moreover, the base class member is not virtual. Is this a mistake? Was the base member supposed to have been declared virtual? By unnecessarily using the same name, confusion could be created.</description>
    </rule>
    <rule key="1512">
        <name>L1512: destructor for base class &apos;Symbol&apos; (Location) is not virtual</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a final pass through all the classes, we have found a class (named in the message) that is the base class of a derivation and has a destructor but the destructor is not virtual. It is conventional for inherited classes to have virtual destructors so that it is safe to &apos;delete&apos; a pointer to a base class. [19]</description>
    </rule>
    <rule key="1513">
        <name>L1513: storage class ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A storage class (one of auto, extern, or register) was found within a class definition. The only storage classes that are significant when declaring members are static and typedef. [11, ?9.2]</description>
    </rule>
    <rule key="1514">
        <name>L1514: Creating temporary to copy &apos;Type&apos; to &apos;Type&apos; (context: Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A temporary was created in order to initialize (or pass a value to or return a value to) a reference. This is suspect because any modification to the value will be a modification of this temporary. This message is not issued when initializing a const reference. [11, ?12.2]</description>
    </rule>
    <rule key="1515">
        <name>L1515: Default constructor not available for member &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member of a class was found that had a type for which a constructor was defined but for which a default constructor (one with no arguments) was not defined.</description>
    </rule>
    <rule key="1516">
        <name>L1516: Data member hides inherited member &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A data member of a class happens to have the same name as a member of a base class. Was this deliberate? Identical names can cause confusion. To inhibit this message for a particular symbol or for an identifiable set of symbols use -esym().</description>
    </rule>
    <rule key="1520">
        <name>L1520: Multiple assignment operators for class &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>More than one assignment operator has been declared for a given class. For example, for class X there may have been declared:
    void operator=(X); void operator=(X) const;
    Which is to be used for assignment?</description>
    </rule>
    <rule key="1521">
        <name>L1521: Multiple copy constructors for class &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>For a given class, more than one function was declared that could serve as a copy constructor. Typically this means that you declared both X( X&amp; ) and X( const X&amp; ) for the same class. This is probably a mistake.</description>
    </rule>
    <rule key="1522">
        <name>L1522: Symbol &apos;Symbol&apos; is an array of empty objects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An array (Symbol) is being allocated. Each member of the array appears to be empty. Although this is legal, it could be the result of human error. If this is deliberate policy, inhibit the message, either globally, or for this Symbol.</description>
    </rule>
    <rule key="1524">
        <name>L1524: new in constructor for class &apos;Name&apos; which has no explicit destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to new has been found in a constructor for a class for which no explicit destructor has been declared. A destructor was expected because how else can the storage be freed? [10, ?12.5]</description>
    </rule>
    <rule key="1526">
        <name>L1525: Member function &apos;Symbol&apos; (Location) not defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member function (named in the message) of a non-library class was not defined. This message is suppressed for unit checkout (-u option).</description>
    </rule>
    <rule key="1527">
        <name>L1527: static member &apos;Symbol&apos; (Location) not defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static data member (named in the message) of a non-library class was not defined. In addition to its declaration within the class, it must be defined in some module.</description>
    </rule>
    <rule key="1528">
        <name>L1528: call to String does not match function template String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first String of the message designates an actual function call that appeared to be the invocation of the template function identified by the second String. No match could be made between the arguments of the call and the template parameters.</description>
    </rule>
    <rule key="1529">
        <name>L1529: Symbol &apos;Symbol&apos; not first checking for assignment to this</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The assignment operator does not appear to be checking for assignment of the value of a variable to itself (assignment to this). Specifically PC-lint/FlexeLint is looking for one of:
    if( &amp;arg == this ) if( &amp;arg != this ) if( this == &amp;arg ) if( this != &amp;arg )
    as the first statement of the function.
    It is important to check for a self assignment so as to know whether the old value should be subject to a delete operation. This is often overlooked by a class designer since it is counter-intuitive to assign to oneself. But through the magic of aliasing (pointers, references, function arguments) it is possible for an unsuspecting programmer to stumble into a disguised self-assignment [12, Item 17].
    If you are currently using the following test
    if( arg == *this)
    we recommend you replace this with the more efficient:
    if( &amp;arg == this || arg == *this)</description>
    </rule>
    <rule key="1531">
        <name>L1531: Symbol &apos;Symbol&apos; (Location) should have compared argument against sizeof(class)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is given for either operator new or operator delete when defined as member functions of a class that is the base class of a derivation. In this case you can&apos;t be certain of the size of allocation and therefore your allocation functions should test the size parameter for equality to the sizeof the class. See Elective Note 1921 for more details.</description>
    </rule>
    <rule key="1532">
        <name>L1532: Symbol &apos;Symbol&apos; not checking argument for NULL</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for a function operator delete which is a member function of a class that does not have a destructor. It should check for NULL because delete p where p has the NULL value will be passed in to it. See also 1922.</description>
    </rule>
    <rule key="1533">
        <name>L1533: Repeated friend declaration for symbol &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A friend declaration for a particular symbol (class or function) was repeated in the same class. Usually this is a harmless redundancy.</description>
    </rule>
    <rule key="1534">
        <name>L1534: static variable &apos;Symbol&apos; found within inline function in header</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static variable (Symbol) was found within an inline function within a header file. This can be a source of error since the static variable will not retain the same value across multiple modules. Rather each module will retain its own version of the variable. If multiple modules need to use the function then have the function refer to an external variable rather than a static variable. Conversely if only one module needs to use the function then place the definition of the function within the module that requires it. [23, Item 26].</description>
    </rule>
    <rule key="1535">
        <name>L1535: Exposing low access data through member &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member function is returning an address being held by the indicated member symbol (presumably a pointer). The member&apos;s access (such as private or protected) is lower than the access of the function returning the address.</description>
    </rule>
    <rule key="1536">
        <name>L1536: Exposing low access member &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>-- A member function is
    returning the non-const address of a member either directly or
    via a reference.  Moreover, the member&apos;s access (such as private
    or protected) is lower than the access of the function returning
    the address.  For example:

    class X
    {
    private:
    int a;
    public:
    int *f() { return &amp;a; }
    };

    This looks like a breach of the access system [12, Item 30].  You
    may lower the access rights of the function, raise the
    accessibility of the member or make the return value a const
    pointer or reference.  In the above example you could change the
    function to:

    const int *f() { return &amp;a; }
    </description>
    </rule>
    <rule key="1537">
        <name>L1537: const function returns pointer data member &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A const function is behaving suspiciously. It is returning a pointer data member (or equivalently a pointer to data that is pointed to by a data member). For example, class X { int *p; int *f() const { return p; } };
    Since f is supposedly const and since p is presumptively pointing to data that is logically part of class X we certainly have the potential for a security breach. Either return a pointer to const or remove the const modifier to the function. [12, Item 29 ].
    Note, if a const function returns the address of a data member then a 605 (capability increase) is issued.</description>
    </rule>
    <rule key="1538">
        <name>L1538: base class &apos;Name&apos; absent from initializer list for copy constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated base class did not appear in the initializer list for a copy constructor. Was this an oversight? If the initializer list does not contain an initializer for a base class, the default constructor is used for the base class. This is not normally appropriate for a copy constructor. The following is more typical: class B { ... }; class D : public B { D( const D &amp;arg ) : B( arg ) { ... } ... };</description>
    </rule>
    <rule key="1539">
        <name>L1539: member &apos;Symbol&apos; (Location) not assigned by assignment operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated Symbol was not assigned by an assignment operator. Was this an oversight? It is not strictly necessary to initialize all members in an assignment operator because the &apos;this&apos; class is presumably already initialized. But it is easy to overlook the assignment of individual members. It is also easy to overlook your responsibility to assign base class members. This is not done for you automatically. [12, Item 16]
    The message is not given for const members or reference members. If you have a member that is deliberately not initialized you may suppress the message for that member only using -esym.</description>
    </rule>
    <rule key="1540">
        <name>L1540: pointer member &apos;Symbol&apos; (Location) neither freed nor zero&apos;ed by destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member is a non-static pointer member of a class that was apparently not freed by the class&apos; destructor. Was this an oversight? By freeing, we mean either a call to the free() function or use of the delete operator. If the pointer is only intended to point to static information during its lifetime then, of course, it never should be freed. In that case you should signal closure by assigning it the NULL pointer (0).</description>
    </rule>
    <rule key="1541">
        <name>L1541: member &apos;Symbol&apos; (Location) possibly not initialized by constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol may not have been initialized by a constructor. Was this an oversight? Some of the paths that the constructor takes do initialize the member.</description>
    </rule>
    <rule key="1542">
        <name>L1542: member &apos;Symbol&apos; (Location) possibly not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol may not have been initialized prior to use. Either this is in a constructor where it is presumed that no members are pre-initialized or this is after a statement which will remove its initialization such as a delete or a free.</description>
    </rule>
    <rule key="1543">
        <name>L1543: member &apos;Symbol&apos; (Location) possibly not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol may not have been initialized prior to a point where its address is being passed to a constant pointer. This looks suspicious. Either this is in a constructor where it is presumed that no members are pre-initialized or this is after a statement which will remove its initialization such as a delete or a free.</description>
    </rule>
    <rule key="1544">
        <name>L1544: value of variable &apos;Symbol&apos; (Location) indeterminate (order of initialization)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable (identified by Symbol) was used in the run-time initialization of a static variable. However this variable itself was initialized at run-time. Since the order of initialization cannot be predicted this is the source of possible error.
    Whereas addresses are completely known at initialization time values may not be. Whether the value or merely the address of a variable is used in the initialization of a second variable is not an easy thing to determine when an argument is passed by reference or via pointer. For example, class X { X( const X &amp; ); };
    extern X x1; X x2 = x1; X x1 = x2;
    It is theoretically possible, but unlikely, that the constructor X() is interested only in the address of its argument and not its current value. If so, it only means you will be getting a spurious report which you can suppress based on variable name. However, if the const is missing when passing a reference parameter (or a pointer parameter) then we cannot easily assume that values are being used. In this case no report will be issued. The moral is that if you want to get the checking implied by this message you should make your constructor reference arguments const.</description>
    </rule>
    <rule key="1545">
        <name>L1545: value of variable &apos;Symbol&apos; used previously to initialize variable &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable identified by Symbol was used previously to initialize some other variable. This variable is now itself being initialized with run-time code. The order of these initializations cannot be predicted. See also message 1544.</description>
    </rule>
    <rule key="1546">
        <name>L1546: direct throw of exception &apos;Name&apos; within destructor &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The body of a destructor (signature provided within the message) contains a throw not within a try block. This is dangerous because destructors are themselves triggered by exceptions in sometimes unpredictable ways. The result can be a perpetual loop. [23, Item 11]</description>
    </rule>
    <rule key="1547">
        <name>L1547: Assignment of array to pointer to base class (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An assignment from an array of a derived class to a pointer to a base class was detected. For example: class B { }; class D : public B {}; D a[10]; B *p = a; // Warning 1547 B *q = &amp;a[0]; // OK
    In this example p is being assigned the address of the first element of an array. This is fraught with danger since access to any element other than the zeroeth must be considered an error (we presume that B and D actually have or have the potential to have different sizes). [23, Item 3].
    We do not warn about the assignment to q because it appears that the programmer realizes the situation and wishes to confine q to the base object of the zeroeth element of a only. As a further precaution against inappropriate array access, out of bounds warnings are issued for subsequent references to p[1] and q[1].</description>
    </rule>
    <rule key="1548">
        <name>L1548: Exception specification for &apos;Symbol&apos; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The exception specification of a function begins with the keyword &apos;throw&apos; and follows the prototype. Two declarations were found for the same function with inconsistent exception specifications.</description>
    </rule>
    <rule key="1549">
        <name>L1549: Exception thrown for function &apos;Symbol&apos; not declared to throw</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An exception was thrown (i.e., a throw was detected) within a function and not within a try block; moreover the function was declared to throw but the exception thrown was not on the list. If you provide an exception specification, include all the exception types you potentially will throw. [23, Item 14]</description>
    </rule>
    <rule key="1550">
        <name>L1550: exception &apos;Name&apos; thrown by function &apos;Symbol&apos; is not on throw-list of function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function was called (first Symbol) which was declared as potentially throwing an exception. The call was not made from within a try block and the function making the call had an exception specification. Either add the exception to the list, or place the call inside a try block and catch the throw. [23, Item 14]</description>
    </rule>
    <rule key="1551">
        <name>L1551: function may throw exception &apos;Name&apos; in destructor &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A call to a function (name given by the first Symbol) was made from within a destructor. The function was declared as potentially throwing an exception. Such exceptions need to be caught within a try block because destructors should never throw exceptions. [23, Item 11].</description>
    </rule>
    <rule key="1552">
        <name>L1552: Converting pointer to array-of-derived to pointer to base</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This warning is similar to Warning 1547 and is sometimes given in conjunction with it. It uses value tracking to determine that an array (that could be dynamically allocated) is being assigned to a base class pointer.
    For example, Derived *d = new Derived[10]; Base *b; b = d; // Warning 1552 b = &amp;d[0]; // OK
    [23, Item 3] Also, see the article by Mark Nelson (Bug++ of the Month, Windows developer&apos;s Journal, May 1997, pp. 43-44).</description>
    </rule>
    <rule key="1553">
        <name>L1553: struct &apos;Symbol&apos; declared as extern &quot;C&quot; contains C++ substructure &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A C++ substructure was found in a structure or class declared as extern &quot;C&quot;. Was this intended?</description>
    </rule>
    <rule key="1554">
        <name>L1554: Direct pointer copy of member &apos;Symbol&apos; within copy constructor: &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a copy constructor a pointer was merely copied rather than recreated with new storage. This can create a situation where two objects have the same data and this, in turn, causes problems when these objects are deleted or modified. For example, the following class will draw this warning: class X { char *p; X( const X &amp; x ) { p = x.p; } ... };
    Here, member p is expected to be recreated using new or some variant.</description>
    </rule>
    <rule key="1555">
        <name>L1555: Direct pointer copy of member &apos;Symbol&apos; within copy assignment operator: &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a copy assignment operator a pointer was merely copied rather than recreated with new storage. This can create a situation where two objects have the same data and this, in turn, causes problems when these objects are deleted or modified. For example, the following class will draw this warning: class X { char *p; X&amp; operator=( const X &amp; x ) { p = x.p; } ... };
    Here, member p is expected to be recreated using new or some variant.</description>
    </rule>
    <rule key="1556">
        <name>L1556: &apos;new Type(integer)&apos; is suspicious</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A new expression had the form new T(Integer) where type T has no constructor. For example:
    new int(10)
    will draw this warning. The expression allocates an area of storage large enough to hold one integer. It then initializes that integer to the value 10. Could this have been a botched attempt to allocate an array of 10 integers? Even if it was a deliberate attempt to allocate and initialize a single integer, a casual inspection of the code could easily lead a reader astray.
    The warning is only given when the type T has no constructor. If T has a constructor then either a syntactic error will result because no constructor matches the argument or a match will be found. In the latter case no warning will or should be issued.</description>
    </rule>
    <rule key="1557">
        <name>L1557: const member &apos;Symbol&apos; is not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A class member typed const class (or struct or union) is mentioned in a constructor initializer list. But the class (or struct or union) referenced has no constructor and hence the member is not initialized. See also messages 1558 and 1769.</description>
    </rule>
    <rule key="1558">
        <name>L1558: virtual coupled with inline is an unusual combination</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The function declared both &apos;virtual&apos; and &apos;inline&apos; has been detected. An example of such a situation is as follows: class C { virtual inline void f(); // Warning 1558 }; Virtual functions by their nature require an address and so inlining such a function seems contradictory. We recommend that the &apos;inline&apos; function specifier be removed.</description>
    </rule>
    <rule key="1559">
        <name>L1559: Uncaught exception &apos;Name&apos; may be thrown in destructor &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named exception occurred within a try block and was either not caught by any handler or was caught but then thrown from the handler. Destructors should normally not throw exceptions [23, Item 11].</description>
    </rule>
    <rule key="1560">
        <name>L1560: Uncaught exception &apos;Name&apos; not on throw-list of function &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A direct or indirect throw of the named exception occurred within a try block and was either not caught by any handler or was rethrown by the handler. Moreover, the function has an exception specification and the uncaught exception is not on the list. Note that a function that fails to declare a list of thrown exceptions is assumed to potentially throw any exception.</description>
    </rule>
    <rule key="1561">
        <name>L1561: Reference initialization causes loss of const/volatile integrity (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A reference initialization is resulting in a capability gain that can cause a loss of const or volatile integrity.
    Typically the message is given on initializing a non-const reference with a const. For example: void f( int &amp;x ); const int n = 0; ... f(n); Here, function f() could assign a value to its argument and thereby modify n which is declared to be const.
    The message can also be issued when a pointer is initialized. Consider the following example. void h( const int *&amp;q ); int *p; ... h(p); It might seem that passing a regular (i.e., non-const) pointer to a const int * could cause no harm. That would be correct if it were not for the reference. If function h() were to assign a pointer to const to its parameter q then upon return from the call, p could be used to modify const data.
    There are many subtle cases that can boggle the mind. See the commentary to Message 605.</description>
    </rule>
    <rule key="1562">
        <name>L1562: Exception specification for &apos;Symbol&apos; is not a subset of &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first symbol is that of an overriding virtual function for the second symbol. The exception specification for the first was found not to be a subset of the second. For example, it may be reasonable to have: struct B { virtual void f() throw(B); }; struct D:B { virtual void f() throw(D); }; Here, although the exception specification is not identical, the exception D is considered a subset of the base class B.
    It would not be reasonable for D::f() to throw an exception outside the range of those thrown by B::f() because in general the compiler will only see calls to B::f() and it should be possible for the compiler to deduce what exceptions could be thrown by examining the static call.</description>
    </rule>
    <rule key="1563">
        <name>L1563: Suspicious third argument to ?: operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The third argument to ?: contained an unparenthesized assignment operator such as p ? a : b = 1 If this is what was intended you should parenthesize the third argument as in: p ? a : (b = 1) Not only is the original form difficult to read but C, as opposed to C++, would parse this as: (p ? a : b) = 1</description>
    </rule>
    <rule key="1564">
        <name>L1564: Assigning a non-zero-one constant to a bool</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The following looks suspicious. bool a = 34; Although there is an implicit conversion from integral to bool and assigning an integer varaible to a bool to obtain its Boolean meaning is legitimate, assigning an integer such as this looks suspicious. As the message suggests, the warning is not given if the value assigned is either 0 or 1. An Elective Note would be raised in that instance.</description>
    </rule>
    <rule key="1565">
        <name>L1565: member &apos;Symbol&apos; (Location) not assigned by initializer function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function dubbed &apos;initializer&apos; by a -sem option is not initializing (i.e., assigning to) every data member of a class. Reference members and const members theoretically can only be initialized via the constructor so that these members are not candidates for this message.</description>
    </rule>
    <rule key="1566">
        <name>L1566: member &apos;Symbol&apos; (Location) might have been initialized by a separate function but no &apos;-sem(Name,initializer)&apos; was seen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A class data member (whose name and location are indicated in the message) was not directly initialized by a constructor. It may have been initialized by a separately called member function. If this is the case you may follow the advice given in the message and use a semantic option to inform PC-lint/FlexeLint that the separately called function is in fact an &apos;initializer&apos;. For example: class A { int a; public: void f(); A() { f(); } }; Here f() is presumably serving as an initializer for the constructor A::A(). To inform PC-lint/FlexeLint of this situation, use the option: -sem( A::f, initializer ) This will suppress Warning 1566 for any constructor of class A that calls A::f.</description>
    </rule>
    <rule key="1567">
        <name>L1567: Initialization of variable &apos;Symbol&apos; (Location) is indeterminate as it uses variable &apos;Symbol&apos; through calls: &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable was dynamically initialized using an expression that contained a call to a function and that function referenced a variable that was also dynamically initialized and was in some other module. For example: a.cpp: b.cpp:
    int g(void); int f(void); int y = g(); int x = f(); int f() { return y; } The initialization of both x and y are dynamic. Although the order of dynamic initialization within a module is pre-ordained the order in which modules are initialized is not. Therefore it is perfectly possible for b.cpp to be initialized before a.cpp. Thus when the call is made upon function f() to initialize x, variable y may not yet have been initialized.</description>
    </rule>
    <rule key="1568">
        <name>L1568: Variable &apos;Symbol&apos; (Location) accesses variable &apos;Symbol&apos; before the latter is initialized through calls: &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable was dynamically initialized using an expression that contained a call to a function and that function referenced a variable that was also dynamically initialized but later in the module. For example: int g(void); int f(void); int x = f(); int y = g(); int f() { return y; } The initialization of both x and y are dynamic. The order of dynamic initialization within a module is in the order in which the initialization is specified. Thus when the call is made upon function f() to initialize x, variable y will not yet have been initialized.</description>
    </rule>
    <rule key="1569">
        <name>L1569: Initializing a member reference with a temporary.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member reference was initialized with a temporary. For example: struct A { int &amp;n; A() : n(3) {} }; The constructor A() contains an initializer list within which it initializes n. But n will be bound to a temporary created by the compiler to hold the value 3. The lifetime of this temporary is limited; it &quot;persists until the constructor exits&quot; [10 section class.temporary]</description>
    </rule>
    <rule key="1570">
        <name>L1570: Initializing a reference class member with an auto variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a constructor initializer, a reference class member is being initialized to bind to an auto variable. Consider: class X { int &amp;n; X(int k) :n(k) {} }; In this example member n is being bound to variable k which, although a parameter, is nonetheless placed into auto storage. But the lifetime of k is only the duration of the call to the constructor, whereas the lifetime of n is the lifetime of the class object constructed.</description>
    </rule>
    <rule key="1571">
        <name>L1571: Returning an auto variable &apos;Symbol&apos; via a reference type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function that is declared to return a reference is returning an auto variable (that is not itself a reference). The auto variable is not guaranteed to exist beyond the lifetime of the function. This can result in unreliable and unpredictable behavior.</description>
    </rule>
    <rule key="1572">
        <name>L1572: Initializing a static reference variable with an auto variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static variable has a lifetime that will exceed that of the auto variable that it has been bound to. Consider void f( int n ) { static int&amp; r = n; ... } The reference r will be permanently bound to an auto variable n. The lifetime of n will not extend beyond the life of the function. On the second and subsequent calls to function f the static variable r will be bound to a non-existent entity.</description>
    </rule>
    <rule key="1573">
        <name>L1573: Generic function template &apos;Symbol&apos; declared in namespace associated with type &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>When a class (or union or enum) is declared within a namespace that namespace is said to be associated with the type. A Generic function template is any that has as parameters only intrinsic types or plain template arguments possibly adorned with reference or const or volatile qualification. Consider namespace X { template&lt; class T &gt; void f( int, const T&amp; ); // Generic class A{}; // Warning 1573 } A call to function f that contained an argument of type X::A would, by ADL (Argument Dependent Lookup), need to also consider function X::f even though this function was not in the scope of the call. In the past this has led to strange an unexpected results.
    Some designers adopt the strategy of embedding the class within a sub namespace and employing a using-declaration to make it available to users of the original namespace. For example: namespace X { template&lt; class T &gt; void f( int, const T&amp; ); // Generic namespace X1 { class A{}; // No Warning } using X1::A; } Now an argument of type X::A will not automatically trigger a consideration of X::f.</description>
    </rule>
    <rule key="1574">
        <name>L1574: Returning the address of an auto variable indirectly through reference variable &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a function whose return type is reference to some type, a return statement is returning a reference which has been initialized (possibly indirectly) with an auto variable. For example: int &amp;f( int k ) { int &amp;r = k; return r; }</description>
    </rule>
    <rule key="1576">
        <name>L1576: Explicit specialialization does not occur in the same file as corresponding function template &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An explicit specialization of a function template was found to be declared in a file other than the one in which the corresponding function template is declared. Two identical calls in two different modules on the same function template could then have two differing interpretations based on the inclusion of header files. The result is undefined behavior.
    As if this wasn&apos;t enough, if the explicit specialization could match two separate function templates then the result you obtain could depend on which function templates are in scope.
    See also the next message.</description>
    </rule>
    <rule key="1577">
        <name>L1577: Partial or explicit specialialization does not occur in the same file as primary template &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There is a danger in declaring an explicit specialization or a partial specialization in a file other than that which holds the primary class template. The reason is that a given implicit specialization will differ depending on what headers it sees. It can easily differ from module to module and undefined behavior can be the result.
    See also Warning 1576 which diagnoses a similar problem with function templates.</description>
    </rule>
    <rule key="1578">
        <name>L1578: Pointer member &apos;Symbol&apos; (Location) neither freed nor zeroed by cleanup function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member is a non-static data member of a class that was apparently not cleared by a function that had previously been given the cleanup semantic. By clearing we mean that the pointer was either zeroed or the storage associated with the pointer released via the free function or its semantic equivalent or some form of delete. See also Warning 1540.</description>
    </rule>
    <rule key="1579">
        <name>L1579: Pointer member &apos;Symbol&apos; (Location) might have been freed by a separate function but no &apos;-sem(Name,cleanup)&apos; was seen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A class data member (whose name and location are indicated in the message) was not directly freed by the class destructor. There was a chance that it was cleared by a separately called member function. If this is the case you may follow the advice given in the message and use a semantic option to inform PC-lint/FlexeLint that the separately called function is in fact a &apos;cleanup&apos; function. For example: class A { int *p; public: void release_ptrs(); ~A() { release_ptrs(); } }; Here release_ptrs() is presumably serving as a cleanup function for the destructor ~A::A(). To inform PC-lint/FlexeLint of this situation, use the option: -sem( A::release_ptrs, cleanup ) A separate message (Warning 1578) will be issued if the cleanup function fails to clear all pointers. See also Warning 1566.</description>
    </rule>
    <rule key="1701">
        <name>L1701: redundant access-specifier &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given access specifier (one of &apos;public&apos;, &apos;private&apos; or &apos;protected&apos;) has been repeated. [11, ?11.1]</description>
    </rule>
    <rule key="1702">
        <name>L1702: operator &apos;Name&apos; is both an ordinary function &apos;String&apos; and a member function &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In attempting to resolve the definition of an operator it was found that the same operator was declared as both a member function and a non-member function. Was this intended? Symmetric binary operators (such as &apos;+&apos;, &apos;-&apos;, &apos;==&apos;, &apos;&gt;&apos;, etc.) are usually defined external to a class definition so that they can support non-objects on the left hand side. [11, ?13.4.2]</description>
    </rule>
    <rule key="1703">
        <name>L1703: Function &apos;String&apos; arbitrarily selected. Refer to Error &apos;Integer&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This informational message is given with error numbers 1023, 1024, 1025 and 1026. These are issued when an error is encountered during the overload resolution process, and is issued merely to indicate which function was arbitrarily selected. [11, ?13.2]</description>
    </rule>
    <rule key="1704">
        <name>L1704: Constructor &apos;Symbol&apos; has private access specification</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A private constructor is legal and has its uses but can also result in messages that are difficult to interpret. If you use private constructors as a programming technique then you may suppress this message with a -e1704. But it&apos;s probably better to suppress this on a constructor by constructor basis using -esym.</description>
    </rule>
    <rule key="1705">
        <name>L1705: static class members may be accessed by the scoping operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static class member was accessed using a class object and -&gt; or . notation. For example:
    s.member or p-&gt;member
    But an instance of the object is not necessary. It could just as easily have been referenced as:
    X::member
    where X is the class name. [10, ?9.4]</description>
    </rule>
    <rule key="1706">
        <name>L1706: Declaration with scope operator is unusual within a class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Class members within a class are not normally declared with the scope operator. For example:
    class X { int X::n; ...
    will elicit this message. If the (redundant) class specification (X::) were replaced by some different class specification and the declaration was not friend an error (1040) would be issued. [11, ?9.2]</description>
    </rule>
    <rule key="1707">
        <name>L1707: static assumed for String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>operator new() and operator delete(), when declared as member functions, should be declared as static. They do not operate on an object instantiation (implied this pointer). [11, ?12.5]</description>
    </rule>
    <rule key="1708">
        <name>L1708: typedef &apos;Symbol&apos; not declared as &quot;C&quot; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A typedef symbol which was previously declared as extern &quot;C&quot; was not so declared at the current location. This is not considered as serious a situation as is indicated by message 1065 which is given for external function and variable names. If this is your programming style you may suppress this message.</description>
    </rule>
    <rule key="1709">
        <name>L1709: typedef &apos;Symbol&apos; declared as &quot;C&quot; conflicts with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A typedef symbol was previously not declared as extern &quot;C&quot; but is so declared at the current location. This is not considered as serious a situation as is indicated by message 1066 which is given for external function and variable names. If this is your programming style you may suppress this message.</description>
    </rule>
    <rule key="1710">
        <name>L1710: An implicit &apos;typename&apos; was assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when the standard requires the use of &apos;typename&apos; to disambiguate the syntax within a template where it may not be clear that a name is the name of a type or some non-type. (See C++ Standard [10], Section 14.6, Para 2). Consider: template&lt; class T &gt; class A { T::N x; // Info 1710 }; Many compilers will accept this construct since the only interpretation consistent with valid syntax is that T::N represents a type. (But if the &apos;x&apos; weren&apos;t there it would be taken as an access declaration and more frequently would be a non-type).</description>
    </rule>
    <rule key="1711">
        <name>L1711: class &apos;Symbol&apos; (Location) has a virtual function but is not inherited</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The given class has a virtual function but is not the base class of any derivation. Was this a mistake? There is no advantage to making member functions virtual unless their class is the base of a derivation tree. In fact, there is a disadvantage because there is a time and space penalty for virtual functions. This message is not given for library classes and is suppressed for unit checkout. [13, ?4]</description>
    </rule>
    <rule key="1712">
        <name>L1712: default constructor not defined for class &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A class was defined with one or more constructors but none of these could be used as a (0 argument) default constructor. Is this an omission? The default constructor is used in declarations and for new when no explicit initialization is given. It is also used when the class is a base class and no mem-initializer is given. It is used for arrays as well. A default constructor should therefore be omitted only for good reason. If you have such a good reason for class X you can employ option -esym(1712,X). [19]</description>
    </rule>
    <rule key="1713">
        <name>L1713: Parentheses have inconsistent interpretation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression of the form: new T() is supposed to produce a default initialized allocation of type T. If T is a POD type (Plain Old Data type) it is supposed to be initialized to 0. Since this change was made relatively late in the draft leading to the standard, many compilers do not yet support this construct. If your compiler does support the construct and you have no intention of porting your application to any other compiler, suppress this message. Alternatively, code this as: new T and initialize the result explicitly.</description>
    </rule>
    <rule key="1714">
        <name>L1714: Member function &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member function was not referenced. This message is automatically suppressed for unit checkout (-u) and for members of a library class.</description>
    </rule>
    <rule key="1715">
        <name>L1715: static member &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static data member of a class was not referenced. This message is automatically suppressed for unit checkout (-u) and for members of a library class.</description>
    </rule>
    <rule key="1716">
        <name>L1716: Virtual member function &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A virtual member function was apparently not referenced. Not only was the function itself not referenced but the function or functions that it overrides were not referenced either. The message is not given if the member function itself or any member function that it overrides is a library member function. This is because the original virtual function may be called implicitly by the library.
    This message is suppressed for unit checkout (-u).</description>
    </rule>
    <rule key="1717">
        <name>L1717: empty prototype for function declaration, assumed &apos;(void)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An empty prototype, as in:
    void f();
    has a different meaning in C than in C++. In C it says nothing about the arguments of the function; in C++, it says there are no arguments. This message is not given for member function declarations or for function definitions. Rather, weaker Elective Notes (1917 and 1918) are given. This is because the chance of ambiguity does not exist in these cases. [11, ?8.2.5]</description>
    </rule>
    <rule key="1718">
        <name>L1718: expression within brackets ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In the expression:
    delete [ expression ] p
    the expression is ignored. The expression is a vestige of an earlier time when this information provided a count of the number of items in the array being released. Note that empty square brackets are considered necessary for deleting an array. This is a complaint directed toward the expression within the brackets not the brackets themselves. [11, ?5.3.4]</description>
    </rule>
    <rule key="1719">
        <name>L1719: assignment operator for class &apos;Symbol&apos; has non-reference parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The typical assignment operator for a class is of the form:
    X&amp; operator =(const X &amp;)
    If the argument is not a reference then your program is subject to implicit function calls and less efficient operation. [11, ?13.4.3]</description>
    </rule>
    <rule key="1720">
        <name>L1720: assignment operator for class &apos;Symbol&apos; has non-const parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The typical assignment operator for a class is of the form:
    X&amp; operator =(const X &amp;)
    If the argument is not const then your program will not be diagnosed as completely as it might otherwise be. [11, ?13.4.3]</description>
    </rule>
    <rule key="1721">
        <name>L1721: operator =() for class &apos;Symbol&apos; is not assignment operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The assignment operator for a class has the form:
    X&amp; operator =(const X &amp;)
    A member function whose name is operator =, but which doesn&apos;t have that form, is not an assignment operator. This could be a source of subtle confusion for a program reader. If this is not an error you may selectively suppress this message for the given class. [11, ?13.4.3]</description>
    </rule>
    <rule key="1722">
        <name>L1722: assignment operator for class &apos;Symbol&apos; does not return a reference to class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The typical assignment operator for a class X is of the form:
    X&amp; operator =(const X &amp;)
    The reason for returning a reference to class is to support multiple assignment as in:
    a = b = c
    [11, ?13.4.3]</description>
    </rule>
    <rule key="1724">
        <name>L1724: Argument to copy constructor for class &apos;Symbol&apos; should be a const reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A copy constructor for class X is typically declared as:
    X( const X &amp; );
    If you leave off the &apos;const&apos; then some diagnostics will not be possible. [19]</description>
    </rule>
    <rule key="1725">
        <name>L1725: class member &apos;Symbol&apos; is a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>There are a number of subtle difficulties with reference data members. If a class containing a reference is assigned, the default assignment operator will presumably copy the raw underlying pointer. This violates the principle that a reference&apos;s underlying pointer, once established, is never modified. Some compilers protect against this eventuality by refusing to create a default assignment operator for classes containing references. Similar remarks can be made about copy constructors. If you are careful about how you design your copy constructors and assignment operators, then references within classes can be a useful programming technique. They should not, however, be employed casually. [21, ?2.1.3]</description>
    </rule>
    <rule key="1726">
        <name>L1726: taking address of overloaded function name &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A reference is being made to an overloaded function without an immediately following &apos;(&apos;. Thus there is no argument list to distinguish which function is intended. Resolution of the overloaded name can only be made by analyzing the destination. Is this what the programmer intended? [11, ?13.3]</description>
    </rule>
    <rule key="1727">
        <name>L1727: inline &apos;Symbol&apos; not previously defined inline at (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declared or defined inline was not previously declared inline. Was this intended? If this is your standard practice then suppress this message. [11, ?9.3.2]</description>
    </rule>
    <rule key="1728">
        <name>L1728: Symbol &apos;Symbol&apos; was previously defined inline at (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function was previously declared or defined inline. The inline modifier is absent from the current declaration or definition. Was this intended? If this is your standard practice then suppress this message. [11, ?9.3.2]</description>
    </rule>
    <rule key="1729">
        <name>L1729: Initializer inversion detected for member &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In a constructor initializer the order of evaluation is determined by the member order not the order in which the initializers are given. At least one of the initializers was given out of order. Was there a reason for this? Did the programmer think that by changing the order that he/she would affect the order of evaluation? Place the initializers in the order of their occurrence within the class so that there can be no mistaken assumptions. [12, Item 13]</description>
    </rule>
    <rule key="1730">
        <name>L1730: class/struct inconsistency for symbol &apos;Symbol&apos; (conflicts with Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An object is declared both with the keyword class and with the keyword struct. Though this is legal it is suspect. [11, ?7.1.6]</description>
    </rule>
    <rule key="1732">
        <name>L1732: new in constructor for class &apos;Name&apos; which has no assignment operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a constructor for the cited class, there appeared a new. However, no assignment operator was declared for this class. Presumably some class member (or members) points to dynamically allocated memory. Such memory is not treated properly by the default assignment operator. Normally a custom assignment operator would be needed. Thus, if x and y are both of type Symbol
    x = y;
    will result in pointer duplication. A later delete would create chaos. [12, Item 11]</description>
    </rule>
    <rule key="1733">
        <name>L1733: new in constructor for class &apos;Name&apos; which has no copy constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Within a constructor for the cited class, there appeared a new. However, no copy constructor was declared for this class. Presumably, because of the new, some class member (or members) points to dynamically allocated memory. Such memory is not treated properly by the default copy constructor. Normally a custom copy constructor would be needed. [12, Item 11]</description>
    </rule>
    <rule key="1734">
        <name>L1734: Had difficulty compiling template function: &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>At template wrap-up time where there is an attempt to &apos;compile&apos; each template function according to arguments provided, the cited function could not be processed fully. The difficulty may be the result of syntax errors cited earlier and if these errors are repaired then this message should go away.</description>
    </rule>
    <rule key="1735">
        <name>L1735: Virtual function &apos;Symbol&apos; has default parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A virtual function was detected with a default parameter. For example: class B { virtual void f( int n = 5 ); ... };
    The difficulty is that every virtual function f overriding this virtual function must contain a default parameter and its default parameter must be identical to that shown above. If this is not done, no warnings are issued but behavior may have surprising effects. This is because when f() is called through a base class pointer (or reference) the function is determined from the actual type (the dynamic type) and the default argument is determined from the nominal type (the static type). [12, Item 38].</description>
    </rule>
    <rule key="1736">
        <name>L1736: Redundant access specifier (String)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An access specifier (one of public, private, or protected as shown in String) is redundant. That is, the explicitly given access specifier did not have to be given because an earlier access specifier of the same type is currently active. This message is NOT given for an access specifier that is the first item to appear in a class definition. Thus class abc { private: ...
    does not draw this message. The reason this message is issued is because it is very easy to make the following mistake. class A { public: // declare private members: ... public: // declare public members: ...
    In general there are no compiler warnings that would result from such an unintentional botch.</description>
    </rule>
    <rule key="1737">
        <name>L1737: Symbol &apos;Symbol&apos; hides global operator new</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated Symbol is a class member operator new. It is not compatible with the global operator new and, moreover, no other operator new within the class is argument list compatible with the global operator new. For this reason the user of these classes will get a surprise if he/she calls for new X where X is the class name. It will be greeted with an error. The solution is to define a single argument operator new as a class member. [12, Item 9].</description>
    </rule>
    <rule key="1738">
        <name>L1738: non-copy constructor &apos;Symbol&apos; used to initialize copy constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In an initializer list for a copy constructor, a base class constructor was invoked. However, this base class constructor was not itself a copy constructor. We expect that copy constructors will invoke copy constructors. Was this an oversight or was there some good reason for choosing a different kind of constructor? If this was deliberate, suppress this message. See also message 1538.</description>
    </rule>
    <rule key="1739">
        <name>L1739: Binary operator &apos;Symbol&apos; should be non-member function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated function was declared as a member function. There were a number of indicators to suggest that it should have been a non-member function. The class, X of which it was a member has a constructor that could be used to convert numeric values to X. The parameter to the operator was X or its equivalent. For this reason the operator would behave unsymmetrically. A numeric value on the right hand side would be promoted but not a value on the left hand side. For example, X op 27 would work but 27 op X would not. [12, Item 19].</description>
    </rule>
    <rule key="1740">
        <name>L1740: pointer member &apos;Symbol&apos; (Location) not directly freed or zero&apos;ed by destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A destructor did not free or zero a pointer member. However, it did call out to another (non-const) member function which may have done the required work. This Informational message is a companion to Warning 1540 which covers the situation where no member function is called from within the destructor.</description>
    </rule>
    <rule key="1741">
        <name>L1741: member &apos;Symbol&apos; (Location) conceivably not initialized by constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol may not have been initialized by a constructor. Was this an oversight? There appears to be a path through a loop that does initialize the member and the warning is issued because it is not clear that the loop is always executed at least once.</description>
    </rule>
    <rule key="1742">
        <name>L1742: member &apos;Symbol&apos; (Location) conceivably not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol conceivably may not have been initialized by a constructor. Was this an oversight? Some of the execution paths that the constructor takes, do initialize the member.</description>
    </rule>
    <rule key="1743">
        <name>L1743: member &apos;Symbol&apos; (Location) conceivably not initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated member symbol conceivably may not have been initialized prior to use. Either this is in a constructor where it is presumed that no members are pre-initialized or this is after a statement which will remove its initialization such as a delete or a free.</description>
    </rule>
    <rule key="1744">
        <name>L1744: member &apos;Symbol&apos; (Location) possibly not initialized by private constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The designated member was possibly not initialized by a private constructor. This message is similar to messages 1401, 1541 and 1741 which are given for ordinary (non private) constructors. It is given a special error number because a private constructor may be one that, by design, is never called and variables may be deliberately left uninitialized. In that case this message should be suppressed.</description>
    </rule>
    <rule key="1745">
        <name>L1745: member &apos;Symbol&apos; (Location) not assigned by private assignment operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated Symbol was not assigned by a private assignment operator. This is very much like Warning 1539 except that the assignment operator in question is private. A private assignment operator may simply be a device to thwart unintended use of the assignment operator. In this case you may not care about unassigned members. If this is so, suppress this message.
    The message is not given for const members or reference members. [12, Item 16]</description>
    </rule>
    <rule key="1746">
        <name>L1746: parameter &apos;Symbol&apos; of function &apos;Symbol&apos; could be made const reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated parameter is a candidate to be declared as a const reference. For example: void f( X x ) { // x not modified. }
    Then the function definition can be replaced with: void f( const X &amp;x ) { // x not modified. }
    The result is more efficient since less information needs to be placed onto the stack and a constructor need not be called.
    The message is only given with class-like arguments (including struct&apos;s and union&apos;s) and only if the parameter is not subsequently modified or potentially modified by the function. The parameter is potentially modified if it is passed to a function whose corresponding parameter is a reference (not const) or if its address is passed to a non-const pointer. [12, Item 22].</description>
    </rule>
    <rule key="1747">
        <name>L1747: binary operator &apos;Symbol&apos; returning a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An operator-like function was found to be returning a reference. For example: X &amp;operator+ ( X &amp;, X &amp; );
    This is almost always a bad idea. [12, Item 23]. You normally can&apos;t return a reference unless you allocate the object, but then who is going to delete it. The usual way this is declared is: X operator+ ( X &amp;, X &amp; );</description>
    </rule>
    <rule key="1748">
        <name>L1748: non-virtual base class &apos;Name&apos; included twice in class &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Through indirect means, a given class was included at least twice as a base class for another class. At least one of these is not virtual. Although legal, this may be an oversight. Such base classes are usually marked virtual resulting in one rather than two separate instances of the base class. This is done for two reasons. First, it saves memory; second, references to members of such a base class will not be ambiguous.</description>
    </rule>
    <rule key="1749">
        <name>L1749: base class &apos;Symbol&apos; of class &apos;Symbol&apos; need not be virtual</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The designated base class is a direct base class of the second class and the derivation was specified as &apos;virtual&apos;. But the base class was not doubly included (using this link) within any class in the entire project. Since a virtual link is less efficient than a normal link this may well be an unenlightened use of &apos;virtual&apos;. [23, Item 24]. The message is inhibited if unit checkout (-u) is selected.</description>
    </rule>
    <rule key="1750">
        <name>L1750: local template &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;local&apos; template is one that is not defined in a header file. The template was not used in the module in which it was defined.</description>
    </rule>
    <rule key="1752">
        <name>L1752: catch parameter Integer is not a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for every catch parameter that is not a reference and is not numeric. The problem with pointers is a problem of ownership and delete responsibilities; the problem with a non-ref object is the problem of slicing away derivedness [23, Item 13].</description>
    </rule>
    <rule key="1753">
        <name>L1753: Overloading special operator &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued whenever an attempt is made to declare one of these operators as having some user-defined meaning: operator || operator &amp;amp;amp;&amp;amp;amp; operator ,
    The difficulty is that the working semantics of the overloaded operator is bound to be sufficiently different from the built-in operators, as to result in possible confusion on the part of the programmer. With the built-in versions of these operators, evaluation is strictly left-to-right. With the overloaded versions, this is not guaranteed. More critically, with the built-in versions of &amp;amp;amp;&amp;amp;amp; and ||, evaluation of the 2nd argument is conditional upon the result of the first. This will never be true of the overloaded version. [23, Item 7].</description>
    </rule>
    <rule key="1754">
        <name>L1754: Expected symbol &apos;Symbol&apos; to be declared for class &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The first Symbol is of the form: operator op= where op is a binary operator. A binary operator op was declared for type X where X is identified by the second Symbol. For example, the appearance of: X operator+( const X &amp;, const X &amp; );
    somewhere in the program would suggest that a += version appear as a member function of class X. This is not only to fulfill reasonable expectations on the part of the programmer but also because operator+= is likely to be more efficient than operator+ and because operator+ can be written in terms of operator+=. [23, Item 22]
    The message is also given for member binary operators. In all cases the message is not given unless the return value matches the first argument (this is the implicit argument in the case of a member function).</description>
    </rule>
    <rule key="1755">
        <name>L1755: global template &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A &apos;global&apos; template is one defined in a header file. This message is given for templates defined in non-library header files. The template is not used in any of the modules comprising the program. The message is suppressed for unit checkout (-u).</description>
    </rule>
    <rule key="1757">
        <name>L1757: Discarded instance of post decrement/increment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A postfix increment or postfix decrement operator was used in a context in which the result of the operation was discarded. For example: X a;
    ... a++;
    In such contexts it is just as correct to use prefix decrement/increment. For example this could be replaced with: X a;
    ... ++a;
    The prefix form is (or should be) more efficient than the postfix form because, in the case of user-defined types, it should return a reference rather than a value (see 1758 and 1759). This presumes that the side effects of the postfix form are equivalent to those of the prefix form. If this is not the case then either make them equivalent (the preferred choice) or turn this message off. [23, Item 6].</description>
    </rule>
    <rule key="1758">
        <name>L1758: Prefix increment/decrement operator &apos;Symbol&apos; returns a non-reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>To conform with most programming expectations, a prefix increment/decrement operator should return a reference. Returning a reference is both more flexible and more efficient [23, Item 6].
    The expected form is as shown below: class X { X &amp; operator++(); // prefix operator X operator++( int ); // postfix operator ... };</description>
    </rule>
    <rule key="1759">
        <name>L1759: Postfix increment/decrement operator &apos;Symbol&apos; returns a reference.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>To conform with most programming expectations, a postfix increment/decrement operator should return a value as opposed to a reference. [23, Item 6].</description>
    </rule>
    <rule key="1760">
        <name>L1760: Redundant template &apos;Symbol&apos; defined identically at Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A template was defined identically in the same module. Was this a mistake?</description>
    </rule>
    <rule key="1761">
        <name>L1761: Declaration of function &apos;Symbol&apos; hides overloaded function &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declaration hides an overloaded function. This does not contribute to the overloaded-ness of the function but completely hides all the overloaded functions in some prior scope. If this is your intent suppress this message.</description>
    </rule>
    <rule key="1762">
        <name>L1762: Member function &apos;Symbol&apos; could be made const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated (non-static) member function did not modify member data and did not call non-const functions. Moreover, it does not make any deep modification to the class member. A modification is considered deep if it modifies information indirectly through a class member pointer. Therefore it could and probably should be declared as a const member function. See also Info 1763 and Elective Note 1962.</description>
    </rule>
    <rule key="1763">
        <name>L1763: Member function &apos;Symbol&apos; marked as const indirectly modifies class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The designated symbol is a member function declared as const. Though technically valid, the const may be misleading because the member function modifies (or exposes) information indirectly referenced by the object. For example: class X { char *pc; char &amp; get(int i) const { return pc[i]; } };
    results in Info 1763 for function X::get. This is because the function exposes information indirectly held by the class X.
    Experts [24] recommend that a pair of functions be made available in this situation: class X { char *pc; const char &amp; get(int i) const { return pc[i]; } char &amp; get(int i) { return pc[i]; } };
    In this way, if the object is const then only the const function will be called which will return the protected reference. Related messages are also 1762 and 1962. See also [12, Item 29] for a further description.</description>
    </rule>
    <rule key="1764">
        <name>L1764: Reference parameter &apos;Symbol&apos; (Location) could be declared const reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>As an example:
    int f( int &amp; k ) { return k; }
    can be redeclared as:
    int f( const int &amp; k ) { return k; }
    Declaring a parameter a reference to const offers advantages that a mere reference does not. In particular, you can pass constants, temporaries and const types into such a parameter where otherwise you may not. In addition it can offer better documentation.
    Other situations in which a const can be added to a declaration are covered in messages 818, 952, 953 and 954.</description>
    </rule>
    <rule key="1768">
        <name>L1768: Virtual function &apos;Symbol&apos; has an access (String) different from the access (String) in the base class (String)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An overriding virtual function has an access (public, protected or private) in the derived class different from the access of the overridden virtual function in the base class. Was this an oversight? Since calls to the overriding virtual function are usually made through the base class, making the access different is unusual (though legal).</description>
    </rule>
    <rule key="1769">
        <name>L1769: Member or base class &apos;Symbol&apos; has no constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An initializer of the form Symbol() is ignored. Symbol is either a class member with a class, struct, or union type or is a base class. In either case the class (or struct or union) has no constructor and hence what appears to be an initialization is not. See also messages 1557 and 1558.</description>
    </rule>
    <rule key="1770">
        <name>L1770: function &apos;Symbol&apos; defined without function &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A typical Info 1770 message is: function &apos;operator new(unsigned)&apos; defined without function &apos;operator delete&apos;
    There are three others: operator delete without an operator new, operator new[] without an operator delete[], and operator delete[] without an operator new[].
    In general it is not a good idea to create one of these functions without the other in the pairing. [23, Item 27]
    You can suppress any of these without suppressing them all. Simply do a -esym(1770,name) where name is the first function named in the message.</description>
    </rule>
    <rule key="1771">
        <name>L1771: function &apos;Symbol&apos; replaces global function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for operator new and operator delete (and for their [] cousins) when a definition for one of these functions is found. Redefining the built-in version of these functions is not considered sound programming practice. [23, Item 27]</description>
    </rule>
    <rule key="1772">
        <name>L1772: Assignment operator &apos;Symbol&apos; is not returning *this</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The assignment operator should return *this. This is to allow for multiple assignments as in:
    a = b = c;
    It is also better to return the object that has just been modified rather than the argument. [12, Item 15]</description>
    </rule>
    <rule key="1773">
        <name>L1773: Attempt to cast away const (or volatile)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An attempt was made to cast away const. This can break the integrity of the const system. This message will be suppressed if you use const_cast. Thus: char *f( const char * p ) { if( test() ) return (char *) p; // Info 1773 else return const_cast&lt;char *&gt;(p); // OK }
    See [12, Item 21].</description>
    </rule>
    <rule key="1774">
        <name>L1774: Could use dynamic_cast to downcast ptr to polymorphic type &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A downcast was detected of a pointer to a polymorphic type (i.e., one with virtual functions). A dynamic_cast could be used to cast this pointer safely. For example: class B { virtual ~B(); }; class D : public B {}; ... D *f( B *p ) { return dynamic_cast&lt;D*&gt;(p); }
    In the above example, if p is not a pointer to a D then the dynamic cast will result in a NULL pointer value. In this way, the validity of the conversion can be directly tested.
    B needs to be a polymorphic type in order to use dynamic_cast. If B is not polymorphic, message 1939 is issued.</description>
    </rule>
    <rule key="1775">
        <name>L1775: catch block does not catch any declared exception</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A catch handler does not seem to catch any exceptions. For example: try { f(); } catch( B&amp; ) {} catch( D&amp; ) {} // Info 1775 catch( ... ) {} catch( char * ) {} // Info 1775
    If f() is declared to throw type D, and if B is a public base class of D, then the first catch handler will process that exception and the second handler will never be used. The fourth handler will also not be used since the third handler will catch all exceptions not caught by the first two.
    If f() is not declared to throw an exception then Info 1775 will be issued for all four catch handlers.</description>
    </rule>
    <rule key="1776">
        <name>L1776: Converting string literals to Type is not const safe (Context)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A string literal, according to Standard C++ is typed an array of const char. This message is issued when such a literal is assigned to a non-const pointer. For example:
    char *p = &quot;string&quot;;
    will trigger this message. This pointer could then be used to modify the string literal and that could produce some very strange behavior.
    Such an assignent is legal but &quot;deprecated&quot; by the C++ Standard. The reason for not ruling it illegal is that numerous existing functions have their arguments typed as char * and this would break working code.
    Note that this message is only given for string literals. If an expression is typed as pointer to const char in some way other than via string literal, then an assignment of that pointer to a non-const pointer will receive a more severe warning.</description>
    </rule>
    <rule key="1777">
        <name>L1770: Template recursion limit (Integer) reached, use -tr_limit(n)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It is possible to write a recursive template that will contain a recursive invocation without an escape clause. For example:
    template &lt;class T&gt; class A { A&lt; A &gt; x; }; A&lt;int&gt; a; This will result in attempts to instantiate: A&lt;int&gt; A&lt;A&lt;int&gt;&gt; A&lt;A&lt;A&lt;int&gt;&gt;&gt; ... Using the -vt option (turning on template verbosity) you will see the sequence in action. Accordingly we have devised a scheme to break the recursion when an arbitrary depth of recursion has been reached (at this writing 75). This depth is reported in the message. As the message suggests, this limit can be adjusted so that it equals some other value.
    When the limit is reached, a complete type is not used in the definition of the last specialization in the sequence but processing goes on. The message can be suppressed in most cases with no ill effects.</description>
    </rule>
    <rule key="1778">
        <name>L1778: Assignment of string literal to variable &apos;Symbol&apos; (Location) is not const safe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued when a string literal is assigned to a variable whose type is a non-const pointer. The name of the variable appears in the message as well as the location at which the variable was defined (or otherwise declared). For example: char *p; p = &quot;abc&quot;; The message is issued automatically (i.e. by default) for C++. For C, to obtain the message, you need to enable the Strings-are-Const flag (+fsc). This message is similar to message 1776 except that it is issued whenever a string constant is being assigned to a named destination.</description>
    </rule>
    <rule key="1780">
        <name>L1780: Returning address of reference parameter &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of a parameter that has been declared as being a reference to a const is being returned from a function. The danger of this is that the reference may designate a temporary variable that will not persist long after the call. For example: const int *f( const int &amp; n ) { return &amp;n; } int g(); const int *p = f( g() ); Here, p points to a temporary value whose duration is not guaranteed. If the reference is not const then you will get Elective Note 1940.
    This is an example of the Linton Convention as described by Murray [21].</description>
    </rule>
    <rule key="1781">
        <name>L1781: Passing address of reference parameter &apos;Symbol&apos; into caller address space</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of a parameter that has been declared as being a reference to a const is being assigned to a place outside the function. The danger of this is that the reference may designate a temporary variable that will not persist long after the call. For example: void f( const int &amp; n, const int **pp ) { *pp = &amp;n; } int g(); const int *p; ... f( g(), &amp;p ); Here, p will be made to point to a temporary value whose duration is not guaranteed. If the reference is not const then you will get Elective Note 1940.
    This is an example of the Linton Convention as described by Murray [21].</description>
    </rule>
    <rule key="1782">
        <name>L1782: Assigning address of reference parameter &apos;Symbol&apos; to a static variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of a parameter that has been declared as being a reference to a const is being assigned to a static variable. The danger of this is that the reference may designate a temporary variable that will not persist long after the call. For example: const int *p; void f( const int &amp; n ) { p = &amp;n; } int g(); ... f( g() ); Here, p will be made to point to a temporary value whose duration is not guaranteed. If the reference is not const then you will get Elective Note 1940.
    This is an example of the Linton Convention as described by Murray [21].</description>
    </rule>
    <rule key="1784">
        <name>L1784: Symbol &apos;Symbol&apos; previously declared as &quot;C&quot;, compare with Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A symbol is being redeclared in the same module. Whereas earlier it had been declared with an extern &quot;C&quot; linkage, in the cited declaration no such linkage appears. E.g. extern &quot;C&quot; void f(int); void f(int); // Info 1784 In this case the extern &quot;C&quot; prevails and hence this inconsistency probably represents a benign redeclaration. Check to see which linkage is most appropriate and amend or remove the declaration in error.</description>
    </rule>
    <rule key="1785">
        <name>L1785: Implicit conversion from Boolean (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A Boolean expression was assigned (via assignment, return, argument passing or initialization) to an object of some other type. Was this the programmer&apos;s intent? The use of a cast will prevent this message from being issued.</description>
    </rule>
    <rule key="1786">
        <name>L1786: Implicit conversion to Boolean (Context) (Type to Type)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-Boolean expression was assigned (via assignment, return, argument passing or initialization) to an object of type Boolean. Was this the programmer&apos;s intent? The use of a cast will prevent this message from being issued.</description>
    </rule>
    <rule key="1787">
        <name>L1787: Access declarations are deprecated in favor of using declarations</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The C++ standard ([10] section 7.3.3) specifically deprecates the use of access declarations. The preferred syntax is the using declaration. For example: class D : public B { B::a; // message 1787 using B::a; // preferred form produces no message };</description>
    </rule>
    <rule key="1788">
        <name>L1788: Variable &apos;Symbol&apos; (Location) (type &apos;Name&apos;) is referenced only by its constructor or destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable has not been referenced other than by the constructor which formed its initial value or by its destructor or both. The location of the symbol and also its type is given in the message. For example: class A { A(); }; void f() { A a; } will produce a 1788 for variable &apos;a&apos; and for type &apos;A&apos;.
    It very well may be that this is exactly what the programmer wants to do in which case you may suppress this message for this variable using the option -esym(1788,a). It may also be that the normal use of class A is to employ it in this fashion. That is, to obtain the effects of construction and, possibly, destruction but have no other reference to the variable. In this case the option of choice would be -esym(1788,A).</description>
    </rule>
    <rule key="1789">
        <name>L1789: Template constructor &apos;Symbol&apos; cannot be a copy constructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for classes for which a copy constructor was not defined but a template constructor was defined. The C++ standard specifically states that a template constructor will not be used as a copy constructor. Hence a default copy constructor is created for such a class while the programmer may be deluded into thinking that the template will be employed for this purpose. [28, Item 5].</description>
    </rule>
    <rule key="1790">
        <name>L1790: Base class &apos;Symbol&apos; has no non-destructor virtual functions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A public base class contained no virtual functions except possibly virtual destructors. There is a school of thought that public inheritance should only be used to interject custom behavior at the event of virtual function calls. To quote from Marshall Cline, &quot;Never inherit publicly to reuse code (in the base class); inherit publicly in order to be reused (by code that uses base objects polymorphically)&quot; [28, Item 22].</description>
    </rule>
    <rule key="1791">
        <name>L1791: No token on this line follows the &apos;return&apos; keyword</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A line is found that ends with a return keyword and with no other tokens following. Did the programmer forget to append a semi-colon? The problem with this is that the next expression is then consumed as part of the return statement. Your return might be doing more that you thought. For example: void f( int n, int m ) { if( n &lt; 0 ) return // do not print when n is negative print( n ); print( m ); } Assuming print() returns void, this is entirely legal but is probably not what you intended. Instead of printing n and m, for n not negative you print just m. For n negative you print n.
    To avoid this problem always follow the return keyword with something on the same line. It could be a semi-colon, an expression or, for very large expressions, some portion of an expression.</description>
    </rule>
    <rule key="1792">
        <name>L1792: Assignment operator for class &apos;Symbol&apos; does not return a const reference to class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The typical use of an assignment operator for class C is to assign new information to variables of class C. If this were the entire story there would be no need for the assignment operator to return anything. However, it is conventional to support chains of assignment as in: C x, y, z; ... x = y = z; // parsed as x = (y = z); For this reason assignment normally returns a reference to the object assigned the value. For example, assignment (y = z) would return a reference to y.
    Since it is almost never the case that this variable is to be reassigned, i.e. we almost never wish to write: (x = y) = z; // unusual as a general rule it is better to make the assignment operator return a const reference. This will generate a warning when the unusual case is attempted.
    But experts differ. Some maintain that in order to support non-const member functions operating directly on the result of an assignment as in: (x = y).mangle(); where, as its name suggests, mangle is non-const it would be necessary for the return value of assignment to be non-const. Others would argue that this code could easily be replaced by a pair of expressions but if you want to support this style of programming then you should suppress this message.</description>
    </rule>
    <rule key="1793">
        <name>L1793: While calling &apos;Symbol&apos;: Initializing the implict object parameter &apos;Type&apos; (a non-const reference) with a non-lvalue</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-static and non-const member function was called and an rvalue (a temporary object) of class type was used to initialize the implicit object parameter. This is legal (and possibly intentional) but suspicious. Consider the following. struct A { void f(); }; ... A().f(); // Info 1793 ... In the above the &apos;non-static, non-const member function&apos; is A::f(). The &apos;implicit object parameter&apos; for the call to A::f() is A(), a temporary. Since the A::f() is non-const it presumably modifies A(). But since A() is a temporary, any such change is lost. It would at first blush appear to be a mistake.
    The Standard normally disallows binding a non-const reference to an rvalue (see Error 1058 in the manual), but as a special case allows it for the binding of the implicit object parameter in member function calls. Some popular libraries take advantage of this rule in a legitimate way. For example, the GNU implementation of std::vector&lt;bool&gt;::operator[] returns a temporary object of type std::_Bit_reference -- a class type with a non-const member operator=(). _Bit_reference serves a dual purpose. If a value is assigned to it, it modifies the original class through its operator=(). If a value is extracted from it, it obtains that value from the original class through its operator bool().
    Probably the best policy to take with this message is to examine instances of it and if this is a library invocation or a specially designed class, then suppress the message with a -esym() option.</description>
    </rule>
    <rule key="1794">
        <name>L1794: Using-declaration introduces &apos;Name&apos; (Location), which has the same parameter list as &apos;Name&apos; (Location), which was also introduced here by previous using-declaration &apos;Name&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This kind of scenario is perhaps best explained by way of example: struct A{}; // Library 1: namespace N { int f(const A&amp;); int f(char*); } // Library 2: namespace Q { int f(const A&amp;); int f(int); } // Non-library code: using N::f; using Q::f; // Info 1794 here According to the ISO Standard, 14. Added Bibliography, [34], the names of N::f(A) and Q::f(A) will coexist in the global namespace (along with the names of the other overloads of f). This alone does not make the program ill-formed. (For that you would have to make some use of the name &apos;f&apos; that resulted in overload resolution where f(A) is selected.) However, a user of N and Q may be surprised to find that both library namespaces supply a function f that operates on ::A objects, and that both have been introduced into the same scope. So to avoid confusion, the user may opt to do away with the using-declarations and just refer to the various f()&apos;s with qualified-ids.</description>
    </rule>
    <rule key="1795">
        <name>L1795: Defined template &apos;Symbol&apos; was not instantiated.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named template was defined but not instantiated. As such, the template either represents superfluous code or indicates a logic error.
    The &apos;template&apos; in the message could also be a temploid. A temploid is defined as either a template or a member of a temploid.</description>
    </rule>
    <rule key="1796">
        <name>L1796: Explicit specialization of overloaded function template &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A pair of overloaded function templates was followed by an explicit specialization. For example: template&lt; class T &gt; void f( T ); template&lt; class T &gt; void f( T* ); template&lt;&gt; void f( char * p ) { printf( &quot;%s\n&quot;, p ); }
    Confusion can arise in determining which of the two function templates the specialization is actually specializing. This will lead to unexpected results when processing overload resolution since the specialization does not directly compete with the templates. Both function templates compete with each other and it can be difficult to ascertain whether the specialization is invoked in any particular call.</description>
    </rule>
    <rule key="1901">
        <name>L1901: Creating a temporary of type &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>PC-lint/FlexeLint judges that a temporary needs to be created. This occurs, typically, when a conversion is required to a user object (i.e. class object). Where temporaries are created, can be an issue of some concern to programmers seeking a better understanding of how their programs are likely to behave. But compilers differ in this regard.</description>
    </rule>
    <rule key="1902">
        <name>L1902: useless &apos;;&apos; follows &apos;}&apos; in function definition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It is possible to follow a function body with a useless semi-colon. This is not necessarily &apos;lint&apos; to be removed but may be a preferred style of programming (as semi-colons are placed at the end of other declarations).</description>
    </rule>
    <rule key="1904">
        <name>L1904: Old-style C comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>For the real bridge-burner one can hunt down and remove all instances of the /* ... */ form of comment. [12, Item 4]</description>
    </rule>
    <rule key="1905">
        <name>L1905: implicit default constructor generated for class &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A default constructor was not defined for a class but a base class or a member has a non-trivial default constructor and so a non-trivial default constructor is generated for this class.</description>
    </rule>
    <rule key="1907">
        <name>L1907: implicit destructor generated for class &apos;Name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named class does not itself have an explicit destructor but either had a base class that has a destructor or has a member class that has a destructor (or both). In this case a destructor will be generated by the compiler. [11, ?12.4]</description>
    </rule>
    <rule key="1908">
        <name>L1908: &apos;virtual&apos; assumed for destructor&apos;~Name()&apos; (inherited from base class &apos;Name()</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The destructor cited was inherited from a base class with a virtual destructor. This word &apos;virtual&apos; was omitted from the declaration. It is common practice to omit this keyword when implied. A warning is issued (1512) when a base class&apos;s destructor is not virtual. See also 1909.</description>
    </rule>
    <rule key="1909">
        <name>L1909: &apos;virtual&apos; assumed, see: function &apos;Symbol&apos; (Location)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named function overrides a base class virtual function and so is virtual. It is common practice to omit the virtual keyword in these cases although some feel that this leads to sloppy programming. This message allows programmers to detect and make explicit which functions are actually virtual.</description>
    </rule>
    <rule key="1911">
        <name>L1911: Implicit call of constructor &apos;Symbol&apos; (see text)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The Symbol in the message is the name of a constructor called to make an implicit conversion. This message can be helpful in tracking down hidden sources of inefficiencies. [11, ?12.1]</description>
    </rule>
    <rule key="1912">
        <name>L1912: Implicit call of conversion function from class &apos;Name&apos; to type &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A conversion function (one of the form Symbol::operator Type ()) was implicitly called. This message can be helpful in tracking down hidden sources of inefficiencies.</description>
    </rule>
    <rule key="1914">
        <name>L1914: Default constructor &apos;Symbol&apos; (Location) not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A default constructor was not referenced. When a member function of a class is not referenced, you will normally receive an Informational message (1714) to that effect. When the member function is the default constructor, however, we give this Elective Note instead.
    The rationale for this different treatment lay in the fact that many authors recommend defining a default constructor as a general principle. Indeed we give an Informational message (1712) when a default constructor is not defined for a class. Therefore, if you are following a modus operandi of not always defining a default constructor you may want to turn off message 1712 and turn on message 1914 instead.</description>
    </rule>
    <rule key="1915">
        <name>L1915: Overriding virtual function &apos;Symbol&apos; is not marked with override</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A virtual function that overrides a base class function was not declared with the override virt-specifier. This message is only emitted for C++11 and higher.</description>
    </rule>
    <rule key="1916">
        <name>L1916: Ellipsis encountered</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An ellipsis was encountered while processing the prototype of some function declaration. An ellipsis is a way of breaking the typing system of C or C++.</description>
    </rule>
    <rule key="1917">
        <name>L1917: Empty prototype for String, assumed &apos;(void)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given when an empty prototype is detected either for a function definition or for a namespace declaration (the String specifies which). Whereas we give an Informational Message (1717) when a (non-member) declaration contains no prototype, we give a much milder Elective Note when a definition does the same. For example:
    int f(); // Info 1717 int f() { return 1; } // Elective Note 1917
    The reason for this is that the declaration form has a different meaning in C and C++. In C it is an incomplete declaration saying nothing about arguments. In C++ the declaration says there are no arguments. The definition, however, means the same in both languages. See also message 1918. [11, ?8.2.5]</description>
    </rule>
    <rule key="1918">
        <name>L1918: empty prototype for member declaration, assumed (void)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A function declaration within a class contains an empty prototype. This case is similar to Info 1717 which complains about an empty prototype outside a class. It receives a lighter classification (Elective Note) because an empty prototype within a class cannot be ambiguous because C does not allow functions within classes. [11, ?8.2.5]</description>
    </rule>
    <rule key="1919">
        <name>L1919: Multiple assignment operators for class &apos;Symbol&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>For a given class more than one function was declared whose name was &apos;operator =&apos;. This is not necessarily a bad thing. For example, a String class may very well have an assignment from char * and such an assignment may be advisable from an efficiency standpoint. However, it represents a loss of elegance because there will almost certainly be a char * constructor and an assignment operator which will represent another way of achieving the same effect.</description>
    </rule>
    <rule key="1920">
        <name>L1920: Casting to a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The ARM[11] (Section 5.4) states that reference casts are often &apos;misguided&apos;. However, too many programs are openly using reference casts to place such casts in the Informational category. [11, ?5.4]</description>
    </rule>
    <rule key="1921">
        <name>L1921: Symbol &apos;Symbol&apos; not checking argument against sizeof(class)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This note is given for either operator new or operator delete when defined as member functions. As member functions they are called when new (or delete) is applied to a class type or any derived class type. The difficulty is with the derived class type. Any specialized allocator is likely to be useless for a derived class type and hence experts suggest that a test be made of the size_t argument against sizeof(class). Specifically PC-lint/FlexeLint is looking for one of:
    if( arg == sizeof(class) ) if( arg != sizeof(class) ) if( sizeof(class) == arg ) if( sizeof(class) != arg )
    or the equivalent. If any such function is found that is a member of a class that is the base of a derivation, then in addition to Note 1921, we issue Warning 1531. (see Steve Simpson, &quot;More on Memory Management&quot;, Dr. Dobb&apos;s Journal, August 1994, p. 10).</description>
    </rule>
    <rule key="1922">
        <name>L1922: Symbol &apos;Symbol&apos; not checking argument for NULL</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is given for a function operator delete which is not checking its parameter for being the NULL pointer. We would normally expect to see some such check as:
    if( arg ) if( arg == 0 ) if( arg != NULL )
    etc. Classes which have destructors will normally filter out passing the NULL pointer into the operator delete so that this message is only in the Elective Note category. If there is no destructor you obtain a warning. See Warning 1532.</description>
    </rule>
    <rule key="1923">
        <name>L1923: macro &apos;Symbol&apos; could become const variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The designated macro could probably be replaced by a const variable. A const variable is preferred in some quarters where, for example, a local debugger may not understand macros but would understand variables. [12, Item 1].
    The message is issued for macros containing at least one constant or constant equivalent (an earlier const-able macro or const variable) and no other variables or tokens such as &apos;;&apos; of a non-expression nature.</description>
    </rule>
    <rule key="1924">
        <name>L1924: C-style cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A C-style cast was detected. This can be replaced by one of the newer C++ casts having the form: Name&lt;Type&gt;(Expression) where Name is one of static_cast, dynamic_cast, const_cast or reinterpret_cast. [23, Item 2].</description>
    </rule>
    <rule key="1925">
        <name>L1925: Symbol &apos;Symbol&apos; is a public data member</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The indicated Symbol is a public data member of a class. If the class is introduced with the keyword struct the message is not issued. In some quarters the use of public data members is deprecated. The rationale is that if function calls replace data references in the public interface, the implementation can change without affecting the interface. [12, Item 20]</description>
    </rule>
    <rule key="1926">
        <name>L1926: Symbol &apos;Symbol&apos;s default constructor implicitly called</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member of a class (identified by Symbol) did not appear in the constructor initialization list. Since it had a default constructor this constructor was implicitly called. Is this what the user intended? Some authorities suggest that all members should appear in the constructor initialization list. [12, Item 12].</description>
    </rule>
    <rule key="1927">
        <name>L1927: Symbol &apos;Symbol&apos; did not appear in the constructor initializer list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A member of a class (identified by Symbol) did not appear in a constructor initialization list. If the item remains uninitialized through the whole of the constructor, a Warning 1401 is issued. Some authorities suggest that all members should appear in the constructor initialization list. [12, Item 12].</description>
    </rule>
    <rule key="1928">
        <name>L1928: Symbol &apos;Name&apos; did not appear in the constructor initializer list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A base class (identified by Symbol) did not appear in a constructor initialization list. If a constructor does not appear, then the default constructor is called. This may or may not be valid behavior. If a base class is missing from a copy constructor&apos;s initializer list, then a more severe Warning (1538) is issued. [12, Item 12].</description>
    </rule>
    <rule key="1929">
        <name>L1929: function &apos;Symbol&apos; returning a reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A non-member function was found to be returning a reference. This is not normally considered good practice because responsibility for deleting the object is not easily assigned. [12, Item 23].</description>
    </rule>
    <rule key="1930">
        <name>L1930: Conversion operator &apos;Symbol&apos; found</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A conversion operator is a member function of the form: operator Type ();
    This will be called implicitly by the compiler whenever an object (of the class type) is to be converted to type Type. Some programmers consider such implicit calls to be potentially harmful leading to programming situations that are difficult to diagnose. See for example [23, Item 5].</description>
    </rule>
    <rule key="1931">
        <name>L1931: Constructor &apos;Symbol&apos; can be used for implicit conversions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constructor was found that could be used for implicit conversions. For example: class X { public: X(int); ... };
    Here, any int (or type convertible to int) could be automatically converted to X. This can sometimes cause confusing behavior [23, Item 5]. If this is not what was intended, use the keyword &apos;explicit&apos; as in: explicit X(int);
    This will also serve to suppress this message.</description>
    </rule>
    <rule key="1932">
        <name>L1932: Base class &apos;Symbol&apos; is not abstract.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An abstract class is a class with at least one pure virtual specifier. At least one author has argued [23, Item 33] that all base classes should be abstract although this suggestion flies in the face of existing practice.</description>
    </rule>
    <rule key="1933">
        <name>L1933: Call to unqualified virtual function &apos;Symbol&apos; from non-static member function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A classical C++ gotcha is the calling of a virtual function from within a constructor or a destructor. When we discover a direct call from a constructor or destructor to a virtual function we issue Warning 1506. But what about indirect calls. Suppose a constructor calls a function that in turn, perhaps through several levels of call, calls a virtual function. This could be difficult to detect. Dan Saks [24] has suggested a compromise Guideline that &quot;imposes few, if any, practical restrictions&quot;. The Guideline, implemented by this Elective Note, issues a message whenever an unqualified virtual function is called by any other (non-static) member function (for the same &apos;this&apos; object). For example: class X { virtual void f(); void g(); };
    void X::g() { f(); // Note 1933 X::f(); // ok -- non virtual call. }
    Even if total abstinence is unwarranted, turning on message 1933 occasionally can be helpful in detecting situations when constructors or destructors call virtual functions.</description>
    </rule>
    <rule key="1934">
        <name>L1934: Shift operator &apos;Symbol&apos; should be non-member function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It has been suggested [12, Item 19] that you should never make a shift operator a member function unless you&apos;re defining ostream or istream (the message is suppressed in these two cases). The reason is that there is a temptation on the part of the novice to, for example, define output to ostream as a class member function left shift that takes ostream as an argument. This is exactly backwards. The shift operator normally employs the destination (or source) on the left.
    On the other hand, if the class you are defining is the source or destination then defining the shift operators is entirely appropriate.</description>
    </rule>
    <rule key="1935">
        <name>L1935: Dynamic initialization for class object &apos;Symbol1&apos; (references &apos;Symbol2&apos;)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static class-like object whose name is Symbol1 is dynamically initialized by referencing Symbol2 (the latter is normally a constructor for the former). The reason for noting this initialization is that the order of inter-module dynamic initializations is not defined. (Within a module, however, the intializations are done in the order of appearance.) Hence, if the constructor is itself dependent on dynamic initialization occurring in another module the behavior is undefined. For example: class X { X(): ... };
    X x:
    This will elicit Elective Note 1935 that x is being initialized dynamically by a call to X::X(). Now, if this constructor were to be accessing information that depended on the order of evaluation (such as accessing the value of x itself) the result would be undefined. We have no evidence of this at this point. and for this reason the message is in the Elective Note category. However, programmers with a suspected order-of-initialization problem will probably want to turn this on. See also 1936, 1937, 1544 and 1545.</description>
    </rule>
    <rule key="1936">
        <name>L1936: Dynamic initialization for scalar &apos;Symbol1&apos; (references &apos;Symbol2&apos;)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static scalar whose name is Symbol1 is dynamically initialized and references Symbol2 during the initialization. For example, let a module consist only of: int f(); int n = f();
    Here we report that n is dynamically initialized by f(). There may be other symbols referenced, Symbol2 is just the first. The reason for noting this initialization is that the order of inter-module dynamic initializations is not defined. (Within a module, however, the initializations are done in the order of appearance.) If Symbol2 were a variable, then PC-lint/FlexeLint could determine that the variable is dynamically initialized in another module and issue a 1544 or 1545 as appropriate. However, the symbol referenced could be a function (as in the example) and PC-lint/FlexeLint does not analyze the complete function call graph to determine whether there is a dependency on another dynamic initialization. See also 1935 and 1937.</description>
    </rule>
    <rule key="1937">
        <name>L1937: Static variable &apos;Symbol&apos; has a destructor.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A static scalar whose name is Symbol has a destructor. Destructors of static objects are invoked in a predictable order only for objects within the same module (the reverse order of construction). For objects in different modules this order is indeterminate. Hence, if the correct operation of a destructor depends on the existence of an object in some other module an indeterminacy could result. See also 1935, 1936, 1544 and 1545.</description>
    </rule>
    <rule key="1938">
        <name>L1938: constructor &apos;Symbol&apos; accesses global data.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A constructor is accessing global data. It is generally not a good idea for constructors to access global data because order of initialization dependencies can be created. If the global data is itself initialized in another module and if the constructor is accessed during initialization, a &apos;race&apos; condition is established. [12, Item 47]</description>
    </rule>
    <rule key="1939">
        <name>L1939: Down cast detected</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A down cast is a cast from a pointer (or reference) to a base class to a pointer (or reference) to a derived class. A cast down the class hierarchy is fraught with danger. Are you sure that the alleged base class pointer really points to an object in the derived class. Some amount of down casting is necessary but a wise programmer will reduce this to a minimum. [12, Item 39]</description>
    </rule>
    <rule key="1940">
        <name>L1940: Address of reference parameter &apos;Symbol&apos; transferred outside of function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The address of a reference parameter is being transferred (either via a return statement, assigned to a static, or assigned through a pointer parameter) to a point where it can persist beyond the lifetime of the function. These are all violations of the Linton Convention (see Murray [21]).
    The particular instance at hand is with a reference to a non-const and as such is not considered as dangerous as with a reference to a const. (See 1780, 1781 and 1782 in Section 13.8 Informational Messages for those cases). For example: int *f( int &amp;n ) { return &amp;n; } int g(); int *p = f( g() ); would create a problem were it not for the fact that this is diagnosed as a non-lvalue being assigned to a reference to non-const.</description>
    </rule>
    <rule key="1941">
        <name>L1941: Assignment operator for class &apos;Symbol&apos; does not return a const reference to class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The typical use of an assignment operator for class C is to assign new information to variables of class C. If this were the entire story there would be no need for the assignment operator to return anything. However, it is conventional to support chains of assignment as in: C x, y, z; ... x = y = z; // parsed as x = (y = z); For this reason assignment normally returns a reference to the object assigned the value. For example, assignment (y = z) would return a reference to y.
    Since it is almost never the case that this variable is to be reassigned, i.e. we almost never wish to write: (x = y) = z; // unusual as a general rule it is better to make the assignment operator return a const reference. This will generate a warning when the unusual case is attempted.
    But experts differ. Some maintain that in order to support non-const member functions operating directly on the result of an assignment as in: (x = y).mangle(); where, as its name suggests, mangle is non-const it would be necessary for the return value of assignment to be non-const. Another reason to not insist on the const qualifier is that the default assignment operator returns simply a reference to object and not a reference to const object. In an age of generic programming, compatibility may more important than the additional protection that the const would offer.</description>
    </rule>
    <rule key="1942">
        <name>L1942: Unqualified name &apos;Symbol&apos; subject to misinterpretation owing to dependent base class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An unqualified name used within a class template was not found within the class and, moreover, the class has at least one dependent base class. There is a potential ambiguity here. According to the standard, the dependent base class should not be searched either at template definition time or at template instantiation time. Nonetheless, some implementations do make that search at instantiation time. Even if the compiler is conforming, the implementator or even a reader of the code may think the base class is searched leading to confusion.
    To eliminate the ambiguity, the name should be fully qualified (or referenced using this). For example: class X; template&lt; class T &gt; class A : T { X *p; bool f() { return y; } }; Both the reference to X (on line 5) and to y (one line 6) will be flagged. One possible modification is: class X; template&lt; class T &gt; class A : T { ::X *p; bool f() { return this-&gt;y; } }; This solidifies and disambiguates the code. The reference to X is guaranteed to be the X on line 1 and can no longer be high-jacked by the base class. Also, since y is not a member of A, the class will not instantiate unless y is found to be a member of the base class.</description>
    </rule>
    <rule key="1960">
        <name>L1960: Violates MISRA C++ Required Rule Name, String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>In addition to a C coding standard, MISRA has also compiled a C++ one.
    We suggest use of the options file au-misra-cpp.lnt to activate these and other MISRA C++ messages.
    The list of checks made are as follows:
    (Rule 0-1-8) Void return type for function without external side-effects.
    (Rule 2-13-2) Octal constant or escape sequence used.
    (Rule 2-13-4) Lower case literal suffix.
    (Rule 3-1-1) Object/function definitions in headers.
    (Rule 3-1-2) Function not declared at file scope. 
    (Rule 3-2-3)  Object/function previously declared in location.
    (Rule 3-9-3)  Bit representation of a floating point type used.
    (Rule 4-5-1)  Boolean expression used with non-permitted operator.
    (Rule 4-5-3)  Plain char used with prohibited operator.
    (Rule 5-0-3) Implicit conversion of cvalue.
    (Rule 5-0-4) Implicit conversion changes signedness. 
    (Rule 5-0-5) Implicit conversion between integer and floating point types.
    (Rule 5-0-6) Implicit conversion to smaller type.
    (Rule 5-0-7) Cast of cvalue between integer and floating point types.
    (Rule 5-0-8) Cast of cvalue to larger type.
    (Rule 5-0-9) Cast of cvalue changes signedness.
    (Rule 5-0-10) Recasting required for operators &apos;~&apos; and &apos;&lt;&lt;&apos;.
    (Rule 5-0-11) Disallowed use of non-character value.
    (Rule 5-0-12  Disallowed use of non-numeric value.
    (Rule 5-0-15) Pointer arithmetic other than array indexing used.
    (Rule 5-0-19) More than two pointer indirection levels used. 
    (Rule 5-0-21) Bitwise operator applied to signed underlying type.
    (Rule 5-2-1)  Non-postfix expression used with logical operator.
    (Rule 5-2-5)  Attempt to cast away const/volatile from a pointer or reference.
    (Rule 5-2-12) Array-pointer decay when passing the array to a function.
    (Rule 5-3-1)  Boolean expression required for operator.
    (Rule 5-3-2) Prohibited operator applied to unsigned underlying type:
    (Rule 5-3-3) Overloading unary &amp;.
    (Rule 5-3-4) &apos;sizeof&apos; used on expressions with side effect.
    (Rule 5-14-1) Side effects on right hand side of logical operator.
    (Rule 5-18-1) Comma operator used.
    (Rule 6-2-3) Null statement not in line by itself.
    (Rules 6-3-1 and 6-4-1) Left brace expected for if, else, for, do, switch and while.
    (Rule 6-4-2) No &apos;else&apos; at end of &apos;if ... else if&apos; chain.
    (Rule 6-4-7) Boolean value in switch expression.
    (Rule 6-6-2) Gotos jumping to an earlier point in the code.
    (Rule 6-6-3) continue statement should not be used.
    (Rule 6-6-4) More than one &apos;break&apos; terminates loop.
    (Rule 7-3-1) Global declarations other than main(), namespace declarations, extern &quot;C&quot; declarations and arithmetic typedefs.
    (Rule 7-3-2) Using the identifier main for functions other than the global one.
    (Rule 7-3-3) Unnamed namespaces in headers.
    (Rule 7-3-4) No using-directives allowed.
    (Rule 7-3-6) using-directives or using declarations (except class and/or block scope using declarations) in header files.
    (Rule 8-0-1) Multiple declarators in a declaration.
    (Rule 8-4-1) Function has variable number of arguments.
    (Rule 8-4-2) Function parameter list differs.
    (Rule 8-4-4) Function identifier used without &apos;&amp;&apos; or parenthisized parameter list.
    (Rule 8-5-3) Should initialize either all enum members or only the first.
    (Rule 9-5-1) Unions shall not be used.
    (Rule 11-0-1) Non-private data member within a no-POD structure.
    (Rule 12-8-2) Public copy constructor in abstract class.
    (Rule 14-8-1) Explicit specialization of overloaded function templates.
    (Rule 15-1-2) Explicit throw of the Null macro.
    (Rule 15-1-3) Empty throw outside of a catch block.
    (Rule 15-3-7) Catch handler after catch(...) in a try-catch sequence.
    (Rule 16-0-1) Only preprocessor statements and comments before &apos;#include&apos;.
    (Rule 16-0-2) &apos;#define/#undef&apos; used within a block.
    (Rule 16-0-3) Use of &apos;#undef&apos; is discouraged.
    (Rule 16-0-4) Use of function-like macros is discouraged.
    (Rule 16-1-1) Non-standard use of &apos;defined&apos; preprocessor operator.
    (Rule 16-2-4) Header file name with non-standard character:
    (Rule 16-3-1) Multiple use of &apos;#&apos; and/or &apos;##&apos; operators in macro definition.
    (Rule 17-0-2) Re-use of reserved identifier.
    You may disable individual rules to your taste by using the Rule number in an esym option; see Message 960.</description>
    </rule>
    <rule key="1961">
        <name>L1961: virtual member function &apos;Symbol&apos; could be made const</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is similar to message 1762 (member function could be made const) except that it is issued for a virtual function. You may not want to make virtual functions const because then any overriding function would have to be const as well. Consider, for example: class A { virtual void f() {} /* ... */ }; class B : public A { int a; void f() { a = 0; } };
    Here, class B overrides A&apos;s function f() and, in doing so, modifies member a. If A::f() had been declared const, this would not have been possible.
    Nonetheless, a particularly rigorous user may want to hunt down such virtual functions and make them all const and so this Note is provided.
    This message is also similar to Note 1962 which is issued for functions that make deep modifications. Note 1962 takes priority over 1961. That is, a virtual function that makes a deep modification (but no shallow modifications) will have Note 1962 issued but not Note 1961.</description>
    </rule>
    <rule key="1962">
        <name>L1962: Non-const member function &apos;Symbol&apos; contains a deep modification.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The designated member function could be declared const but shouldn&apos;t be because it contains a deep modification. For example: class X { char *p; public: void f() { *p = 0; } x(); };
    will elicit this message indicating that X::f() contains a deep modification. A modification is considered shallow if it modifies (or exposes for modification) a class member directly. A modification is considered deep if it modifies information indirectly through a class member pointer. This Elective Note is available for completeness so that a programmer can find all functions that could result in a class being modified. It does not indicate that the programming is deficient. In particular, if the function is marked const an Info 1763 will be issued. See also 1762, 1763.</description>
    </rule>
    <rule key="1963">
        <name>L1963: Violates MISRA C++ Advisory Rule Name, String</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for some violations of the MISRA C++ advisory guidelines. We suggest use of the options file au-misra-cpp.lnt to activate these and other MISRA C++ messages.
    The list of checks made are as follows: (Rule 2-5-1) Possible digraph used. (Rule 5-0-2) Dependence placed on C&apos;s operator precedence. (Rule 14-8-2) Mixing template and non-template functions in a viable sets. (Rule 15-0-2) Throwing a pointer expression. (Rule 16-2-5) Header file name with non-standard character. (Rule 16-3-2) No use of &apos;#&apos; or &apos;##&apos;.</description>
    </rule>
    <rule key="9001">
        <name>L9001: Octal constant used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An octal constant appears in the code. Octal constants may be inadvertently interpreted by engineers as decimal values.
    This message is not issued for a constant zero written as a single digit.</description>
    </rule>
    <rule key="9003">
        <name>L9003: could define variable &apos;Symbol&apos; at block scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A variable was declared at global scope but only utilized within one function.
    Moving the declaration of this variable to that function reduces the chance the variable will be used incorrectly.</description>
    </rule>
    <rule key="9004">
        <name>L9004: object/function &apos;Symbol&apos; previously declared</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The named symbol was declared in multiple locations, not counting the point of definition for that symbol.
    Declaring a symbol in one location and in one file helps to ensure consistency between declaration and definition as well as avoiding the risk of conflicting definitions across modules.</description>
    </rule>
    <rule key="9005">
        <name>L9005: attempt to cast away const/volatile from a pointer or reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A cast attempted to remove the qualifiers from an object to which a pointer points or a reference refers.
    Doing so can result in undesired or unexpected modification of the object in question and may result in an exception being thrown.</description>
    </rule>
    <rule key="9006">
        <name>L9006: &apos;sizeof&apos; used on expression with side effect</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>If the operand of the sizeof operator is an expression, it is not usually evaluated.  
    Attempting to apply sizeof to such an expression can result, therefore, in code one expects to be evaluated actually not being evaluated and the side-effects not taking place.</description>
    </rule>
    <rule key="9007">
        <name>L9007: side effects on right hand of logical operator, &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The right hand side of the || and &amp;&amp; operators is evaluated only if the left hand side evaluates to a certain value.
    Consequently, code which expects the right hand side to be evaluated regardless of the left hand side can produce unanticipated results.</description>
    </rule>
    <rule key="9008">
        <name>L9008: comma operator used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The comma operator is thought by some to reduce readability in code.</description>
    </rule>
    <rule key="9009">
        <name>L9009: floating point variable used as loop counter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The use of floating point variables as loop counters can produce surprising behavior if the accumulation of rounding errors results in a different number of iterations than anticipated.</description>
    </rule>
    <rule key="9011">
        <name>L9011: more than one &apos;break&apos; terminates loop</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>More than one break statement was seen in a loop. Minimizing the number of exits from a loop is thought by some to reduce visual complexity of the code.</description>
    </rule>
    <rule key="9012">
        <name>L9012: sub-statement should be a compound statement</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Multiple authors have advised making sure the body of every iteration-statement and selection-statement be a compound-statement.
    However, no { was seen to begin the compound-statement.</description>
    </rule>
    <rule key="9013">
        <name>L9013: no &apos;else&apos; at end of &apos;if ... else if&apos; chain</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An if ... else if
       chain was seen without a final else statement. Providing such a statement helps to act as an analog to the default case of a switch-statement.</description>
    </rule>
    <rule key="9014">
        <name>L9014: default missing from switch statement</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A switch-statement was found without a default case.  Providing such a case provides defensive programming.</description>
    </rule>
    <rule key="9015">
        <name>L9015: macro argument is used both with and without &apos;#/##&apos; and is subject to further replacement</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A macro argument was used both as an operand to the stringizing or pasting operators and not used as such.
    Moreover, this macro argument is subject to further replacement.  This could cause confusion.</description>
    </rule>
    <rule key="9016">
        <name>L9016: pointer arithmetic other than array indexing used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Array indexing is thought, by some, to be more readily understood and less error prone than other forms of pointer arithmetic.</description>
    </rule>
    <rule key="9017">
        <name>L9017: pointer arithmetic by increment or decrement used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>While at least one standards organization cautions against using any pointer arithmetic besides array indexing, the use of increment or decrement operators with pointers may represent an intuitive application and illustration of the underlying logic.
    Consequently, such constructs are separated from the prior message #9016 and placed under this one, allowing more fine tuning of Lint diagnostics.</description>
    </rule>
    <rule key="9018">
        <name>L9018: declaration of union type or object of union type, &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Depending upon padding, alignment, and endianness of union, as well as the size and bit-order of their members, the use of unions can result in unspecified, undefined, or implementation defined behavior, prompting some to advise against their use.</description>
    </rule>
    <rule key="9019">
        <name>L9019: declaration of &apos;String&apos; before #include</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The symbol mentioned in String was seen in a module with a subsequent #include directive.
    It can be argued that collecting all #include directives at the beginning of the module helps improve code readability and helps reduce the risk of undefined behavior resulting from any use of the ISO standard library before the relevant #include directive.</description>
    </rule>
    <rule key="9020">
        <name>L9020: header file name with non-standard character &apos;String&apos; </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The use of non-standard characters in #include directives results in undefined behavior.</description>
    </rule>
    <rule key="9021">
        <name>L9021: use of &apos;#undef&apos; is discouraged: &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The use of the #undef directive can lead to confusion about whether or not a particular macro exists at a randomly given point of code.</description>
    </rule>
    <rule key="9022">
        <name>L9022: unparenthesized macro parameter in definition of macro &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Multiple authors have cautioned against the use of unparenthesized macro parameters in cases where the parameter is used as an expression.
    If care is not taken, unparenthesized macro parameters can result in operator precedence rules producing expressions other than intended.</description>
    </rule>
    <rule key="9023">
        <name>L9023: Multiple use of &apos;#/##&apos; operators in definition of macro &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Multiple use of such operators is thought by some to increase the risk of undefined behavior.</description>
    </rule>
    <rule key="9024">
        <name>L9024: &apos;#/##&apos; operator used in macro &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>The use of such operators is thought to reduce code clarity and increase the risk of undefined behavior.</description>
    </rule>
    <rule key="9025">
        <name>L9025: More than two pointer indirection levels used for type &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Three or more levels of pointer indirection may make it harder to understand the code.</description>
    </rule>
    <rule key="9026">
        <name>L9026: Function-like macro, &apos;String&apos;, defined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Multiple authors have expressed reasons why a function, when possible, should be used in place of a function-like macro.</description>
    </rule>
    <rule key="9027">
        <name>L9027: Unpermitted operand to operator &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Out of concern for unspecified, undefined, and/or implementation defined behavior, some standards urge restrictions on certain types of operands when used with certain operators.</description>
    </rule>
    <rule key="9028">
        <name>L9028: Unpermitted arithmetic involving an essentially character type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concept of essentially character type and placed restrictions on the use of expressions with such a type.</description>
    </rule>
    <rule key="9029">
        <name>L9029: Mismatched essential type categories for binary operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concept of essential type and placed restrictions on the use of expressions with certain types with respect to binary operators.</description>
    </rule>
    <rule key="9030">
        <name>L9030: Impermissible cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concept of essential type and placed restrictions on the use of casts between certain types.</description>
    </rule>
    <rule key="9031">
        <name>L9031: Composite expression assigned to a wider essential type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concepts of composite expression and essential type and placed restrictions on assignments of the former.</description>
    </rule>
    <rule key="9032">
        <name>L9032: Composite expression with smaller essential type than other operand</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concepts of composite expression and essential type and placed restrictions on operands to binary operators when at least one of the operands meets the definition of the former concept.</description>
    </rule>
    <rule key="9033">
        <name>L9033: Impermissible cast of composite expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concepts of composite expression and essential type and placed restrictions on casts of the former. This message, when given, is also followed by text explaining why the cast is considered &quot;impermissible&quot;.</description>
    </rule>
    <rule key="9034">
        <name>L9034: Expression assigned to a narrower or different essential type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concept of essential type and placed restrictions on assignments in relation to such types.</description>
    </rule>
    <rule key="9035">
        <name>L9035: Variable length array declared</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some have expressed concern over the use of variable length arrays, noting how, even in common use cases of arrays, use of such arrays can result in undefined or unspecified behavior.</description>
    </rule>
    <rule key="9036">
        <name>L9036: Conditional expression should have essentially Boolean type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA C 2012 has defined the concept of essentially Boolean type and requires that the conditional expressions of all if and iteration-statements comply with this definition.</description>
    </rule>
    <rule key="9037">
        <name>L9037: Conditional of #if does not evaluate to 0 or 1</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some urge such a practice in the interest of strong typing.</description>
    </rule>
    <rule key="9038">
        <name>L9038: Flexible array member declared</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Flexible array members can alter the behavior of sizeof in surprising ways. Additionally, flexible array members often require dynamic memory allocation which may be problematic in safety critical code.</description>
    </rule>
    <rule key="9039">
        <name>L9039: Prohibited escape sequence usage</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An octal or hexadecimal escape sequence has been detected within a string or character literal which is not immediately followed by another escape sequence or end of literal.  Such escape sequence usage has been deprecated on the grounds of potential confusion when attempting to read such code.</description>
    </rule>
    <rule key="9041">
        <name>L9041: goto &apos;Symbol&apos; appears in block &apos;String&apos; which is not nested in block &apos;String&apos; which contains the label.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It has been deemed safer by some experts that the block (i.e. compound statement) containing the goto should be the same as or nested within the block containing the label.  Thus
     
           {  label:  {  goto label;  }  }
     
       is permitted but
     
           {  goto label;  {  label:  }  }
     
       is not.  To assist the programmer, the message refers to the blocks using an identification code (Example: &quot;1.2.1&quot;).  This identification scheme is defined as follows.
         (a) The outer block has an identification of 1.
         (b) If a particular block is identified by x then its immediate subblocks, if any, are identified as x.1, x.2, x.3, etc.

       Thus in the following &apos;code&apos;,
     
           {  {  }  { { label: } { } } }
     
       label: lies in block 1.2.1.</description>
    </rule>
    <rule key="9042">
        <name>L9042: departure from MISRA switch syntax</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A switch-statement was found which does not comply with the MISRA switch-statement syntax.</description>
    </rule>
    <rule key="9043">
        <name>L9043: static keyword between brackets of array declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some advocate against using the keyword static in array declarations due to a perceived increased risk of undefined behavior.</description>
    </rule>
    <rule key="9044">
        <name>L9044: function parameter modified</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It has been advocated that function parameters be first copied to local variables where they can be modified rather than modifying the parameters directly.</description>
    </rule>
    <rule key="9045">
        <name>L9045: non-hidden definition of type &apos;Type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some advise against including structure definitions unless the definition is required for the current module.</description>
    </rule>
    <rule key="9046">
        <name>L9046: Typographical ambiguity with respect to symbol, &apos;Symbol&apos;, Reasons, Location</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Some have warned against the use o identifiers which may be considered typographically ambiguous. 
    In addition to the name of the previously seen symbol, the reasons Lint considers the identifiers to be ambiguous and the location of said previous symbol are provided in the message, if available.</description>
    </rule>
    <rule key="9047">
        <name>L9047: FILE pointer dereferenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>At least one standards organization urges against this practice, directly or indirectly.</description>
    </rule>
    <rule key="9048">
        <name>L9048: unsigned integer literal without a &apos;U&apos; suffix</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An integer literal of unsigned type was found without a &apos;U&apos; suffix.</description>
    </rule>
    <rule key="9049">
        <name>L9049: increment/decrement operation combined with other operation with side-effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>An expression was seen involving an increment or decrement operator and the expression also contained potential side-effects other than those resulting from said operator.</description>
    </rule>
    <rule key="9050">
        <name>L9050: dependence placed on C/C++ operator precedence</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Reliance on operator precedence was found in a particular expression.  Using parentheses, it is felt, helps clarify the order of evaluation.</description>
    </rule>
    <rule key="9051">
        <name>L9051: macro &apos;Symbol&apos; defined with the same name as a C keyword</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A macro was defined with the same name as an ISO C keyword. The use of such a macro causes undefined behavior.</description>
    </rule>
    <rule key="9052">
        <name>L9052: macro &apos;Symbol&apos; defined with the same name as a C++ keyword</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A macro was defined with the same name as an ISO C++ keyword. The use of such a macro causes undefined behavior.</description>
    </rule>
    <rule key="9053">
        <name>L9053: the shift value is at least the precision of the essential type of the left hand side</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>MISRA 2012 defines the notion of an &quot;essential type&quot;. A quantity with a certain essential type, as defined by MISRA, was left shifted by a number exceeding the number of bits used to represent that essential type.</description>
    </rule>
    <rule key="9054">
        <name>L9054: designated initializer used with array of unspecified dimension</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>It has been advocated, when array initializers contain designators, the dimension of the array should be explicitly stated in the declaration. The initializer of the array in  question has been found in violation of this recommendation.</description>
    </rule>
    <rule key="9055">
        <name>L9055: Most closely enclosing compound statement of a case/default is not the body of a switch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Switch labels nested inside of compound statements within the corresponding switch are legal but can reduce comprehension and lead to unstructured code.</description>
    </rule>
    <rule key="9056">
        <name>L9056: Inline function &apos;Symbol&apos; defined with storage-class specifier &apos;String&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>This message is issued for all inline functions defined with a storage-class specifier. 
    +estring can be used to find all inline functions defined with a specific specifier. For example, +estring(9056, extern) will report all inline functions defined with extern.</description>
    </rule>
    <rule key="9057">
        <name>L9057: Lowercase L follows &apos;u&apos; in literal suffix</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A lowercase letter &quot;l&quot; is used inside of a literal suffix following an upper or lowercase letter u. 
    With some fonts, the lowercase letter &quot;l can be easily confused with the number one. 
    This is less likely to happen when there is a &quot;u&quot; between the number and the &quot;l&quot; (as in 35ul), but some coding standards forbid the use of &quot;l&quot; in any literals. 
    Message 620 reports the more suspicious case where the &quot;l&quot; immediately follows a number (as in 35l).</description>
    </rule>
    <rule key="9058">
        <name>L9058: tag &apos;Symbol&apos; (Location) unused outside of typedefs</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A tag was used only in the course of creating a typedef. 
    Was the tag unused by mistake (say a recursive reference inside the body of the struct was accidentally omitted)?  Such tags are most often redundant and can be eliminated.</description>
    </rule>
    <rule key="9059">
        <name>L9059: C comment contains C++ comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A C++-style comment was seen inside a C-style comment.  This can be confusing.</description>
    </rule>
    <rule key="9060">
        <name>L9060: trigraph in comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A trigraph was seen inside a comment. Since trigraphs are translated before preprocessing, a trigraph sequence like ??/ can have surprising results, especially in a C++ style comment where the trigraph sequence translates into a backslash.</description>
    </rule>
    <rule key="9066">
        <name>L9066: C++ comment contains C comment</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>A C-style comment was seen inside a C++-style comment.  This can result in confusion.</description>
    </rule>
    <rule key="M1.1">
        <name>M1.1: Strict ANSI checking (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Strict ANSI checking, MISRA Rule 1.1</description>
    </rule>
    <rule key="M1.2">
        <name>M1.2: No undefined or unspecified behavior (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    No undefined or unspecified behavior, MISRA Rule 1.2</description>
    </rule>
    <rule key="M1.4">
        <name>M1.4: Identifier names must be unique in first 31 characters (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Identifier names must be unique in first 31 characters, MISRA Rule 1.4: </description>
    </rule>
    <rule key="M2.1">
        <name>M2.1: No in-line assembly language (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    No in-line assembly language, MISRA Rule 2.1</description>
    </rule>
    <rule key="M2.2">
        <name>M2.2: Do not use // comments (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Do not use // comments, MISRA Rule 2.2</description>
    </rule>
    <rule key="M2.3">
        <name>M2.3: No nested comments (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    No nested comments</description>
    </rule>
    <rule key="M2.4">
        <name>M2.4: No nested comments (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    No nested comments</description>
    </rule>
    <rule key="M3.4">
        <name>M3.4: Report on pragma use (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Report on pragma use</description>
    </rule>
    <rule key="M3.6">
        <name>M3.6: libraries should conform to MISRA standard (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    libraries should conform to MISRA standard</description>
    </rule>
    <rule key="M4.1">
        <name>M4.1: do not use non-ANSI escape sequences (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use non-ANSI escape sequences</description>
    </rule>
    <rule key="M4.2">
        <name>M4.2: do not use trigraphs (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use trigraphs</description>
    </rule>
    <rule key="M5.1">
        <name>M5.1: identifier names must be unique in first 31 characters (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    identifier names must be unique in first 31 characters</description>
    </rule>
    <rule key="M5.2">
        <name>M5.2: complain about name hiding (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    complain about name hiding</description>
    </rule>
    <rule key="M5.3">
        <name>M5.3: Do not reuse typedef names (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Do not reuse typedef names</description>
    </rule>
    <rule key="M5.4">
        <name>M5.4: Do not reuse tag names (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Do not reuse tag names</description>
    </rule>
    <rule key="M5.5">
        <name>M5.5: Complain about name hiding (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Complain about name hiding</description>
    </rule>
    <rule key="M5.6">
        <name>M5.6: Complain about name hiding (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Complain about name hiding</description>
    </rule>
    <rule key="M5.7">
        <name>M5.7: Do not reuse identifier names (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Do not reuse identifier names</description>
    </rule>
    <rule key="M6.1">
        <name>M6.1: disallowed use of plain char (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    disallowed use of plain char</description>
    </rule>
    <rule key="M6.2">
        <name>M6.2: disallowed use of plain char (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    disallowed use of plain char</description>
    </rule>
    <rule key="M6.3">
        <name>M6.3: do not use modifiers (int, char, etc) outside of a typedef (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use modifiers (int, char, etc) outside of a typedef</description>
    </rule>
    <rule key="M6.4">
        <name>M6.4: bitfield type should be unsigned int or signed int (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    bitfield type should be unsigned int or signed int</description>
    </rule>
    <rule key="M6.5">
        <name>M6.5: small bit field should be unsigned int (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    small bit field should be unsigned int</description>
    </rule>
    <rule key="M7.1">
        <name>M7.1: Octal constant used (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Octal constant used. </description>
    </rule>
    <rule key="M8.1">
        <name>M8.1: use function prototypes (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use function prototypes </description>
    </rule>
    <rule key="M8.2">
        <name>M8.2: function has no explicit type (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    function has no explicit type</description>
    </rule>
    <rule key="M8.3">
        <name>M8.3: declaration and definition should have identical parameter types (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    declaration and definition should have identical parameter types</description>
    </rule>
    <rule key="M8.4">
        <name>M8.4: symbol redeclared (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    symbol redeclared</description>
    </rule>
    <rule key="M8.5">
        <name>M8.5: No definitions of objects or function in header files (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    No definitions of objects or function in header files.</description>
    </rule>
    <rule key="M8.6">
        <name>M8.6: Function not declared at file scope (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Function not declared at file scope.</description>
    </rule>
    <rule key="M8.7">
        <name>M8.7: could define variable at block scope (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    could define variable at block scope</description>
    </rule>
    <rule key="M8.8">
        <name>M8.8: object/function previously declared (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    object/function previously declared</description>
    </rule>
    <rule key="M8.9">
        <name>M8.9: symbol previously defined (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    symbol previously defined</description>
    </rule>
    <rule key="M8.10">
        <name>M8.10: symbol could be made static (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    symbol could be made static</description>
    </rule>
    <rule key="M8.11">
        <name>M8.11: symbol previously used as static (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    symbol previously used as static</description>
    </rule>
    <rule key="M8.12">
        <name>M8.12: array has 0 dimension (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    array has 0 dimension</description>
    </rule>
    <rule key="M9.1">
        <name>M9.1: symbol not initialized (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    symbol not initialized</description>
    </rule>
    <rule key="M9.2">
        <name>M9.2: omitted braces within an initializer (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    omitted braces within an initializer</description>
    </rule>
    <rule key="M9.3">
        <name>M9.3: Should initialize either all enum members or only the first (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Should initialize either all enum members or only the first.</description>
    </rule>
    <rule key="M10.1">
        <name>M10.1: loss of precision / possible loss of fraction (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    The value of an expression of integer type shall not be implicitly converted to a different underlying type if:
    a) it is not a conversion to a wider integer type of the same signedness, or
    b) the expression is complex, or
    c) the expression is not constant and is a function argument, or
    d) the expression is not constant and is a return expression</description>
    </rule>
    <rule key="M10.2">
        <name>M10.2: prototype coercion (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    prototype coercion</description>
    </rule>
    <rule key="M10.3">
        <name>M10.3: prohibited cast of complex integer expression (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    prohibited cast of complex integer expression</description>
    </rule>
    <rule key="M10.4">
        <name>M10.4: prohibited cast of complex floating point (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    prohibited cast of complex floating point</description>
    </rule>
    <rule key="M10.5">
        <name>M10.5: recasting required for &lt;&lt; and - operators (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    recasting required for &lt;&lt; and - operators</description>
    </rule>
    <rule key="M10.6">
        <name>M10.6: unsigned integer literals require a &#8222;U&#8223; suffix (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    unsigned integer literals require a &#8222;U&#8223; suffix</description>
    </rule>
    <rule key="M11.1">
        <name>M11.1: cast pointer to non-pointer (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    cast pointer to non-pointer</description>
    </rule>
    <rule key="M11.2">
        <name>M11.2: cast pointer to non-pointer (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    cast pointer to non-pointer</description>
    </rule>
    <rule key="M11.3">
        <name>M11.3: cast pointer to non-pointer (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    cast pointer to non-pointer</description>
    </rule>
    <rule key="M11.4">
        <name>M11.4: cast pointer to pointer (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    cast pointer to pointer</description>
    </rule>
    <rule key="M11.5">
        <name>M11.5: attempt to cast away const/volatile from a pointer or reference (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    attempt to cast away const/volatile from a pointer or reference</description>
    </rule>
    <rule key="M12.1">
        <name>M12.1: dependence on C&apos;s operator precedence (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    dependence on C&apos;s operator precedence</description>
    </rule>
    <rule key="M12.2">
        <name>M12.2: order of evaluation (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    order of evaluation</description>
    </rule>
    <rule key="M12.3">
        <name>M12.3: &apos;sizeof&apos; used on expressions with side effect (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    &apos;sizeof&apos; used on expressions with side effect</description>
    </rule>
    <rule key="M12.4">
        <name>M12.4: Side effects on right hand side of logical operator (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Side effects on right hand side of logical operator.</description>
    </rule>
    <rule key="M12.5">
        <name>M12.5: non-primary expression used with logical operator (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    non-primary expression used with logical operator</description>
    </rule>
    <rule key="M12.6">
        <name>M12.6: boolean expression required for logical operator (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    boolean expression required for logical operator</description>
    </rule>
    <rule key="M12.7">
        <name>M12.7: Bitwise operator applied to signed underlying type (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Bitwise operator applied to signed underlying type.</description>
    </rule>
    <rule key="M12.8">
        <name>M12.8: excessive shift value (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    excessive shift value</description>
    </rule>
    <rule key="M12.9">
        <name>M12.9: Prohibited operator applied to unsigned underlying type (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Prohibited operator applied to unsigned underlying type.</description>
    </rule>
    <rule key="M12.10">
        <name>M12.10: Comma operator used outside of &apos;for&apos; expression (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Comma operator used outside of &apos;for&apos; expression.</description>
    </rule>
    <rule key="M12.11">
        <name>M12.11: overflow in computing constant (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    overflow in computing constant</description>
    </rule>
    <rule key="M12.12">
        <name>M12.12: bit representation of a floating point type used (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    bit representation of a floating point type used</description>
    </rule>
    <rule key="M12.13">
        <name>M12.13: increment or decrement combined with another operator (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    increment or decrement combined with another operator</description>
    </rule>
    <rule key="M13.1">
        <name>M13.1: boolean test of assignment (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    boolean test of assignment</description>
    </rule>
    <rule key="M13.2">
        <name>M13.2: boolean test of assignment (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    boolean test of assignment</description>
    </rule>
    <rule key="M13.3">
        <name>M13.3: testing floats for equality (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    testing floats for equality, partially covered</description>
    </rule>
    <rule key="M13.4">
        <name>M13.4: Floating point variable used as loop counter (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Floating point variable used as loop counter.</description>
    </rule>
    <rule key="M13.5">
        <name>M13.5: &quot;for&quot; loop expressions do not match (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    &quot;for&quot; loop expressions do not match</description>
    </rule>
    <rule key="M13.6">
        <name>M13.6: detect loop variables modified within the loop (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    detect loop variables modified within the loop</description>
    </rule>
    <rule key="M13.7">
        <name>M13.7: constant value Boolean (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    constant value Boolean</description>
    </rule>
    <rule key="M14.1">
        <name>M14.1: unreachable code (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    unreachable code</description>
    </rule>
    <rule key="M14.2">
        <name>M14.2: non-null statement has no effect (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    non-null statement has no effect</description>
    </rule>
    <rule key="M14.3">
        <name>M14.3: Null statement not in line by itself (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Null statement not in line by itself.</description>
    </rule>
    <rule key="M14.4">
        <name>M14.4: do not use goto (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use goto</description>
    </rule>
    <rule key="M14.5">
        <name>M14.5: continue statement should not be used (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    continue statement should not be used.</description>
    </rule>
    <rule key="M14.6">
        <name>M14.6: More than one &apos;break&apos; terminates loop (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    More than one &apos;break&apos; terminates loop.</description>
    </rule>
    <rule key="M14.7">
        <name>M14.7: return before function end (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    return before function end</description>
    </rule>
    <rule key="M14.8">
        <name>M14.8: use braces around body of switch, else, for, do, while (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use braces around body of switch, else, for, do, while</description>
    </rule>
    <rule key="M14.9">
        <name>M14.9: use braces around body of if, else, else if (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use braces around body of if, else, else if</description>
    </rule>
    <rule key="M14.10">
        <name>M14.10: No &apos;else&apos; at end of &apos;if ... else if&apos; chain (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    No &apos;else&apos; at end of &apos;if ... else if&apos; chain.</description>
    </rule>
    <rule key="M15.0">
        <name>M15.0: use MISRA switch syntax (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use MISRA switch syntax</description>
    </rule>
    <rule key="M15.1">
        <name>M15.1: need a switch (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    need a switch</description>
    </rule>
    <rule key="M15.2">
        <name>M15.2: use break to terminate case (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use break to terminate case</description>
    </rule>
    <rule key="M15.3">
        <name>M15.3: case label follows default in switch statement (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    case label follows default in switch statement</description>
    </rule>
    <rule key="M15.4">
        <name>M15.4: Boolean value in switch expression (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Boolean value in switch expression</description>
    </rule>
    <rule key="M15.5">
        <name>M15.5: switch does not have a case (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    switch does not have a case</description>
    </rule>
    <rule key="M16.1">
        <name>M16.1: Function has variable number of arguments (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Function has variable number of arguments.</description>
    </rule>
    <rule key="M16.2">
        <name>M16.2: do not use recursive functions (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use recursive functions</description>
    </rule>
    <rule key="M16.3">
        <name>M16.3: use identifiers for all parameters in a prototype (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use identifiers for all parameters in a prototype</description>
    </rule>
    <rule key="M16.4">
        <name>M16.4: function parameter list differs from prior declaration (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    function parameter list differs from prior declaration</description>
    </rule>
    <rule key="M16.5">
        <name>M16.5: function declaration is missing type info (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    function declaration is missing type info</description>
    </rule>
    <rule key="M16.6">
        <name>M16.6: too few or too many arguments for prototype (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    too few or too many arguments for prototype</description>
    </rule>
    <rule key="M16.7">
        <name>M16.7: use const on parameters where appropriate (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use const on parameters where appropriate</description>
    </rule>
    <rule key="M16.8">
        <name>M16.8: function should return a value (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    function should return a value</description>
    </rule>
    <rule key="M16.9">
        <name>M16.9: function identifier used without &quot;&amp;&quot; or parenthesized parameter list (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    function identifier used without &quot;&amp;&quot; or parenthesized parameter list</description>
    </rule>
    <rule key="M16.10">
        <name>M16.10: ignoring return value of function (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    ignoring return value of function</description>
    </rule>
    <rule key="M17.1">
        <name>M17.1: pointer arithmetic used on non-array (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    pointer arithmetic used on non-array</description>
    </rule>
    <rule key="M17.2">
        <name>M17.2: relational or subtract operator applied to pointers (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    relational or subtract operator applied to pointers</description>
    </rule>
    <rule key="M17.3">
        <name>M17.3: relational or subtract operator applied to pointers (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    relational or subtract operator applied to pointers</description>
    </rule>
    <rule key="M17.4">
        <name>M17.4: pointer arithmetic by increment or decrement (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    pointer arithmetic by increment or decrement</description>
    </rule>
    <rule key="M17.5">
        <name>M17.5: more than two pointer indirection levels used (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    more than two pointer indirection levels used</description>
    </rule>
    <rule key="M17.6">
        <name>M17.6: assigning address of auto to outer scope symbol or to static (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    assigning address of auto to outer scope symbol or to static</description>
    </rule>
    <rule key="M18.1">
        <name>M18.1: vacuous type for variable (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    vacuous type for variable</description>
    </rule>
    <rule key="M18.4">
        <name>M18.4: Unions shall not be used,MISRA Rule 18.4</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Unions shall not be used.</description>
    </rule>
    <rule key="M19.1">
        <name>M19.1: only preprocessor statements and comments before &apos;#include&apos; (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    only preprocessor statements and comments before &apos;#include&apos;</description>
    </rule>
    <rule key="M19.2">
        <name>M19.2: header file name with non-standard character (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    header file name with non-standard character</description>
    </rule>
    <rule key="M19.3">
        <name>M19.3: need &lt; or &quot; after #include (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    need &lt; or &quot; after #include</description>
    </rule>
    <rule key="M19.4">
        <name>M19.4: expression-like macro not parenthesized (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    expression-like macro not parenthesized</description>
    </rule>
    <rule key="M19.5">
        <name>M19.5: &apos;#define/#undef&apos; used within a block (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    &apos;#define/#undef&apos; used within a block.</description>
    </rule>
    <rule key="M19.6">
        <name>M19.6: Use of &apos;#undef&apos; prohibited (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Use of &apos;#undef&apos; prohibited</description>
    </rule>
    <rule key="M19.7">
        <name>M19.7: use function instead of function-like macro (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    use function instead of function-like macro</description>
    </rule>
    <rule key="M19.8">
        <name>M19.8: syntax error in call of macro (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    syntax error in call of macro</description>
    </rule>
    <rule key="M19.9">
        <name>M19.9: preprocessor directives in macro invocation (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    preprocessor directives in macro invocation</description>
    </rule>
    <rule key="M19.10">
        <name>M19.10: expression-like macro not parenthesized (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    expression-like macro not parenthesized</description>
    </rule>
    <rule key="M19.11">
        <name>M19.11: undefined preprocessor variable (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    undefined preprocessor variable</description>
    </rule>
    <rule key="M19.12">
        <name>M19.12: Multiple use of &apos;#&apos; and/or &apos;##&apos; operators in macro definition (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Multiple use of &apos;#&apos; and/or &apos;##&apos; operators in macro definition.</description>
    </rule>
    <rule key="M19.13">
        <name>M19.13: do not use of # or ## operators in macro definition (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use of # or ## operators in macro definition</description>
    </rule>
    <rule key="M19.14">
        <name>M19.14: Non-standard use of &apos;defined&apos; preprocessor operator (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    Non-standard use of &apos;defined&apos; preprocessor operator.</description>
    </rule>
    <rule key="M19.15">
        <name>M19.15: repeated include file (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    repeated include file</description>
    </rule>
    <rule key="M19.16">
        <name>M19.16: #endif or #else is not followed by EOL (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    #endif or #else is not followed by EOL</description>
    </rule>
    <rule key="M19.17">
        <name>M19.17: #if not closed within file (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    #if not closed within file</description>
    </rule>
    <rule key="M20.1">
        <name>M20.1: do not redefine standard functions (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not redefine standard functions</description>
    </rule>
    <rule key="M20.2">
        <name>M20.2: re-use of reserved identifier (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    re-use of reserved identifier</description>
    </rule>
    <rule key="M20.3">
        <name>M20.3: calls to standard library functions are checked (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    calls to standard library functions are checked</description>
    </rule>
    <rule key="M20.4">
        <name>M20.4: do not use dynamic heap allocation (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use dynamic heap allocation</description>
    </rule>
    <rule key="M20.5">
        <name>M20.5: do not use errno (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use errno</description>
    </rule>
    <rule key="M20.6">
        <name>M20.6: do not use offsetof (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use offsetof</description>
    </rule>
    <rule key="M20.7">
        <name>M20.7: do not use longjmp, setjmp (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use longjmp, setjmp</description>
    </rule>
    <rule key="M20.8">
        <name>M20.8: do not use signal, raise (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use signal, raise</description>
    </rule>
    <rule key="M20.9">
        <name>M20.9: do not use stdio.h (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use stdio.h</description>
    </rule>
    <rule key="M20.10">
        <name>M20.10: do not use atof, atio, atoll (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use atof, atio, atoll</description>
    </rule>
    <rule key="M20.11">
        <name>M20.11: do not use abort, exit, getenv, system (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use abort, exit, getenv, system</description>
    </rule>
    <rule key="M20.12">
        <name>M20.12: do not use time, strftime, clock, difftime, mktime (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    do not use time, strftime, clock, difftime, mktime</description>
    </rule>
    <rule key="M21.1">
        <name>M21.1: static analysis by using PC-lint/FlexeLint (MISRA C)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>
    static analysis by using PC-lint/FlexeLint</description>
    </rule>
    <rule key="M0-1-1">
        <name>M0-1-1: Unreachable (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unreachable</description>
    </rule>
    <rule key="M0-1-2">
        <name>M0-1-2: infeasible path (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>infeasible path</description>
    </rule>
    <rule key="M0-1-3">
        <name>M0-1-3: unused variable (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unused variable</description>
    </rule>
    <rule key="M0-1-4">
        <name>M0-1-4: symbol not referenced or accessed (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>symbol not referenced or accessed</description>
    </rule>
    <rule key="M0-1-5">
        <name>M0-1-5: unused type declaration (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unused type declaration</description>
    </rule>
    <rule key="M0-1-6">
        <name>M0-1-6: last value assigned to variable not used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>last value assigned to variable not used</description>
    </rule>
    <rule key="M0-1-7">
        <name>M0-1-7: ignoring return value of function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>ignoring return value of function</description>
    </rule>
    <rule key="M0-1-8">
        <name>M0-1-8: Void return type for function without external side-effects (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Void return type for function without external side-effects.</description>
    </rule>
    <rule key="M0-1-9">
        <name>M0-1-9: dead(redundant) code (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>dead(redundant) code</description>
    </rule>
    <rule key="M0-1-10">
        <name>M0-1-10: unused function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unused function</description>
    </rule>
    <rule key="M0-1-11">
        <name>M0-1-11: unused function parameter (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unused function parameter</description>
    </rule>
    <rule key="M0-1-12">
        <name>M0-1-12: unused function parameter (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unused function parameter</description>
    </rule>
    <rule key="M0-2-1">
        <name>M0-2-1: unions shall not be used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unions shall not be used</description>
    </rule>
    <rule key="M0-3-2">
        <name>M0-3-2: ignoring return value of function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>ignoring return value of function</description>
    </rule>
    <rule key="M1-0-1">
        <name>M1-0-1: strict ANSI / ISO (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>strict ANSI / ISO</description>
    </rule>
    <rule key="M2-3-1">
        <name>M2-3-1: do not use trigraphs (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>do not use trigraphs</description>
    </rule>
    <rule key="M2-5-1">
        <name>M2-5-1: possible digraph used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>possible digraph used</description>
    </rule>
    <rule key="M2-7-1">
        <name>M2-7-1: do not nest comments (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>do not nest comments</description>
    </rule>
    <rule key="M2-10-1">
        <name>M2-10-1: suspicious constant (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>suspicious constant. Partially covered</description>
    </rule>
    <rule key="M2-10-2">
        <name>M2-10-2: report on name hiding (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>report on name hiding</description>
    </rule>
    <rule key="M2-10-6">
        <name>M2-10-6: symbol redeclared (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>symbol redeclared</description>
    </rule>
    <rule key="M2-13-1">
        <name>M2-13-1: non-ANSI escape sequence (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>non-ANSI escape sequence</description>
    </rule>
    <rule key="M2-13-2">
        <name>M2-13-2: octal constant or escape sequence used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>octal constant or escape sequence used</description>
    </rule>
    <rule key="M2-13-3">
        <name>M2-13-3: unsigned octal &amp; hexadecimal literals require a &#8216;U&#8217; suffix (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>unsigned octal &amp; hexadecimal literals require a &#8216;U&#8217; suffix</description>
    </rule>
    <rule key="M2-13-4">
        <name>M2-13-4: Lower case literal suffix (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Lower case literal suffix.</description>
    </rule>
    <rule key="M2-13-5">
        <name>M2-13-5: mixing narrow and wide string literals in concatenation (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>mixing narrow and wide string literals in concatenation</description>
    </rule>
    <rule key="M3-1-1">
        <name>M3-1-1: Object/function definitions in headers (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Object/function definitions in headers.</description>
    </rule>
    <rule key="M3-1-2">
        <name>M3-1-2: Function not declared at file scope (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Function not declared at file scope.</description>
    </rule>
    <rule key="M3-1-3">
        <name>M3-1-3: Array has dimension 0 (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Array has dimension 0.</description>
    </rule>
    <rule key="M3-2-1">
        <name>M3-2-1: Symbol is redeclared or redefined (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Symbol is redeclared or redefined.</description>
    </rule>
    <rule key="M3-2-2">
        <name>M3-2-2: Symbol is redeclared or redefined (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>symbol is redeclared or redefined.</description>
    </rule>
    <rule key="M3-2-3">
        <name>M3-2-3: Object/function type previously declared (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Object/function type previously declared.</description>
    </rule>
    <rule key="M3-2-4">
        <name>M3-2-4: Symbol is redeclared or redefined (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Symbol is redeclared or redefined.</description>
    </rule>
    <rule key="M3-3-1">
        <name>M3-3-1: Header declaration for symbol could be moved from header tomodule
    / symbol could be made static (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Header declaration for symbol could be moved from header tomodule
    / symbol could be made static.</description>
    </rule>
    <rule key="M3-3-2">
        <name>M3-3-2: Static symbol not declared static (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Static symbol not declared static.</description>
    </rule>
    <rule key="M3-9-2">
        <name>M3-9-2: Type or modifier used outside of typedef (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Type or modifier used outside of typedef.</description>
    </rule>
    <rule key="M3-9-3">
        <name>M3-9-3: Bit representation of a floating point type used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bit representation of a floating point type used.</description>
    </rule>
    <rule key="M4-5-1">
        <name>M4-5-1: Boolean expression used with non-permitted operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Boolean expression used with non-permitted operator.</description>
    </rule>
    <rule key="M4-5-3">
        <name>M4-5-3: Plain char used with prohibited operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Plain char used with prohibited operator.</description>
    </rule>
    <rule key="M4-10-2">
        <name>M4-10-2: Implicit conversion from 0 to pointer (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion from 0 to pointer.</description>
    </rule>
    <rule key="M5-0-1">
        <name>M5-0-1: Order of evaluation (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Order of evaluation.</description>
    </rule>
    <rule key="M5-0-2">
        <name>M5-0-2: Dependence placed on C&#8217;s operator precedence (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Dependence placed on C&#8217;s operator precedence.</description>
    </rule>
    <rule key="M5-0-3">
        <name>M5-0-3: Implicit conversion of cvalue (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion of cvalue.</description>
    </rule>
    <rule key="M5-0-4">
        <name>M5-0-4: Implicit conversion changes signedness (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion changes signedness.</description>
    </rule>
    <rule key="M5-0-5">
        <name>M5-0-5: Implicit conversion between integer and floating point types (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion between integer and floating point types.</description>
    </rule>
    <rule key="M5-0-6">
        <name>M5-0-6: Implicit conversion to smaller type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion to smaller type.</description>
    </rule>
    <rule key="M5-0-7">
        <name>M5-0-7: Cast of cvalue between integer and floating point types (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Cast of cvalue between integer and floating point types.</description>
    </rule>
    <rule key="M5-0-8">
        <name>M5-0-8: Cast of cvalue to larger type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Cast of cvalue to larger type.</description>
    </rule>
    <rule key="M5-0-9">
        <name>M5-0-9: Cast of cvalue changes signedness (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Cast of cvalue changes signedness.</description>
    </rule>
    <rule key="M5-0-10">
        <name>M5-0-10: Recasting required for operators &apos;~&apos; and &apos;&lt;&lt;&apos; (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Recasting required for operators &apos;~&apos; and &apos;&lt;&lt;&apos;.</description>
    </rule>
    <rule key="M5-0-11">
        <name>M5-0-11: Type other than plain char (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Type other than plain char.</description>
    </rule>
    <rule key="M5-0-12">
        <name>M5-0-12: Disallowed use of non-numeric value (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Disallowed use of non-numeric value.</description>
    </rule>
    <rule key="M5-0-13">
        <name>M5-0-13: Implicit conversion (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion.</description>
    </rule>
    <rule key="M5-0-14">
        <name>M5-0-14: Implicit conversion (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Implicit conversion.</description>
    </rule>
    <rule key="M5-0-15">
        <name>M5-0-15: pointer arithmetic other than array indexing used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>pointer arithmetic other than array indexing used.</description>
    </rule>
    <rule key="M5-0-16">
        <name>M5-0-16: Out-of-bounds pointer (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Out-of-bounds pointer.</description>
    </rule>
    <rule key="M5-0-17">
        <name>M5-0-17: Subtract operator applied to pointers (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Subtract operator applied to pointers.</description>
    </rule>
    <rule key="M5-0-18">
        <name>M5-0-18: Relational operator applied to pointers (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Relational operator applied to pointers.</description>
    </rule>
    <rule key="M5-0-19">
        <name>M5-0-19: More than two pointer indirection levels used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>More than two pointer indirection levels used.</description>
    </rule>
    <rule key="M5-0-21">
        <name>M5-0-21: Bitwise operator applied to signed underlying type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bitwise operator applied to signed underlying type .</description>
    </rule>
    <rule key="M5-2-1">
        <name>M5-2-1: non-postfix expression used with logical operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>non-postfix expression used with logical operator.</description>
    </rule>
    <rule key="M5-2-2">
        <name>M5-2-2: use dynamic_cast to downcast polymorphic type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>use dynamic_cast to downcast polymorphic type.</description>
    </rule>
    <rule key="M5-2-4">
        <name>M5-2-4: C-style cast (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>C-style cast.</description>
    </rule>
    <rule key="M5-2-5">
        <name>M5-2-5: attempt to cast away const/volatile from a pointer or reference (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>attempt to cast away const/volatile from a pointer or reference.</description>
    </rule>
    <rule key="M5-2-6">
        <name>M5-2-6: Suspicious cast / unusual pointer cast (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Suspicious cast / unusual pointer cast.</description>
    </rule>
    <rule key="M5-2-7">
        <name>M5-2-7: Pointer conversion to an unrelated type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Pointer conversion to an unrelated type.</description>
    </rule>
    <rule key="M5-2-8">
        <name>M5-2-8: Cast from integer or pointer to void to a pointer to an object (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Cast from integer or pointer to void to a pointer to an object.</description>
    </rule>
    <rule key="M5-2-9">
        <name>M5-2-9: Cast from pointer to integral type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Cast from pointer to integral type.</description>
    </rule>
    <rule key="M5-2-10">
        <name>M5-2-10: Increment or decrement combined with another operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Increment or decrement combined with another operator.</description>
    </rule>
    <rule key="M5-2-11">
        <name>M5-2-11: overloading special operators &#8211; comma &amp;&amp; || (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>overloading special operators &#8211; comma &amp;&amp; ||.</description>
    </rule>
    <rule key="M5-2-12">
        <name>M5-2-12: Array-pointer decay when passing the array to a function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Array-pointer decay when passing the array to a function.</description>
    </rule>
    <rule key="M5-3-1">
        <name>M5-3-1: boolean expression required for operator: &apos;||&apos;; the -strong(B,...) option can help provide Boolean-by-enforcement (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>boolean expression required for operator: &apos;||&apos;; the -strong(B,...) option can help provide Boolean-by-enforcement.</description>
    </rule>
    <rule key="M5-3-2">
        <name>M5-3-2: Prohibited operator applied to unsigned underlying type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Prohibited operator applied to unsigned underlying type.</description>
    </rule>
    <rule key="M5-3-3">
        <name>M5-3-3: Overloading unary &amp; (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Overloading unary &amp;</description>
    </rule>
    <rule key="M5-3-4">
        <name>M5-3-4: &apos;sizeof&apos; used on expressions with side effect (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>&apos;sizeof&apos; used on expressions with side effect.</description>
    </rule>
    <rule key="M5-8-1">
        <name>M5-8-1: excessive shift value (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>excessive shift value</description>
    </rule>
    <rule key="M5-14-1">
        <name>M5-14-1: Side effects on right hand side of logical operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Side effects on right hand side of logical operator.</description>
    </rule>
    <rule key="M5-18-1">
        <name>M5-18-1: Comma operator used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Comma operator used.</description>
    </rule>
    <rule key="M5-19-1">
        <name>M5-19-1: Overflow in computing constant (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Overflow in computing constant.</description>
    </rule>
    <rule key="M6-2-1">
        <name>M6-2-1: Assignment operator used in sub-expression (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Assignment operator used in sub-expression.</description>
    </rule>
    <rule key="M6-2-2">
        <name>M6-2-2: Testing floats for equality (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Testing floats for equality.</description>
    </rule>
    <rule key="M6-2-3">
        <name>M6-2-3: Null statement not in line by itself (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Null statement not in line by itself.</description>
    </rule>
    <rule key="M6-3-1">
        <name>M6-3-1: Left brace expected for if, else, for, do, switch and while (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Left brace expected for if, else, for, do, switch and while.</description>
    </rule>
    <rule key="M6-4-1">
        <name>M6-4-1: Left brace expected for if, else, for, do, switch and while (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Left brace expected for if, else, for, do, switch and while.</description>
    </rule>
    <rule key="M6-4-2">
        <name>M6-4-2: No &apos;else&apos; at end of &apos;if ... else if&apos; chain (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>No &apos;else&apos; at end of &apos;if ... else if&apos; chain.</description>
    </rule>
    <rule key="M6-4-5">
        <name>M6-4-5: Control flows into case/default (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Control flows into case/default.</description>
    </rule>
    <rule key="M6-4-6">
        <name>M6-4-6: Switch statement has no default or case follows default (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Switch statement has no default or case follows default.</description>
    </rule>
    <rule key="M6-4-7">
        <name>M6-4-7: Boolean value in switch expression (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Boolean value in switch expression.</description>
    </rule>
    <rule key="M6-4-8">
        <name>M6-4-8: Switch does not have a case (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Switch does not have a case.</description>
    </rule>
    <rule key="M6-5-3">
        <name>M6-5-3: Reuse of for loop variable could cause chaos (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Reuse of for loop variable could cause chaos.</description>
    </rule>
    <rule key="M6-6-2">
        <name>M6-6-2: Gotos jumping to an earlier point in the code (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Gotos jumping to an earlier point in the code.</description>
    </rule>
    <rule key="M6-6-3">
        <name>M6-6-3: continue statement should not be used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>continue statement should not be used.</description>
    </rule>
    <rule key="M6-6-4">
        <name>M6-6-4: More than one &apos;break&apos; terminates loop (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>More than one &apos;break&apos; terminates loop.</description>
    </rule>
    <rule key="M6-6-5">
        <name>M6-6-5: Return before function end (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Return before function end.</description>
    </rule>
    <rule key="M7-1-1">
        <name>M7-1-1: Use const on parameters where appropriate (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Use const on parameters where appropriate.</description>
    </rule>
    <rule key="M7-1-2">
        <name>M7-1-2: Use const on parameters where appropriate (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Use const on parameters where appropriate.</description>
    </rule>
    <rule key="M7-3-1">
        <name>M7-3-1: Global declarations other than main(), namespace declarations, extern &quot;C&quot; declarations and arithmetic typedefs (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Global declarations other than main(), namespace declarations, extern &quot;C&quot; declarations and arithmetic typedefs.</description>
    </rule>
    <rule key="M7-3-2">
        <name>M7-3-2: Using the identifier main for functions other than the global one (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Using the identifier main for functions other than the global one.</description>
    </rule>
    <rule key="M7-3-3">
        <name>M7-3-3: Unnamed namespaces in headers (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unnamed namespaces in headers.</description>
    </rule>
    <rule key="M7-3-4">
        <name>M7-3-4: No using-directives allowed (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>No using-directives allowed.</description>
    </rule>
    <rule key="M7-3-6">
        <name>M7-3-6: Using-directives or using declarations (except class and/or block scope using declarations) in header files (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Using-directives or using declarations (except class and/or block scope using declarations) in header files.</description>
    </rule>
    <rule key="M7-4-2">
        <name>M7-4-2: Only use the asm declaration to introduce assembly code (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Only use the asm declaration to introduce assembly code.</description>
    </rule>
    <rule key="M7-5-1">
        <name>M7-5-1: Returning address of auto variable (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Returning address of auto variable.</description>
    </rule>
    <rule key="M7-5-2">
        <name>M7-5-2: Assigning address of auto to static (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Assigning address of auto to static.</description>
    </rule>
    <rule key="M7-5-3">
        <name>M7-5-3: Returning address of reference to a const parameter address of reference parameter transferred outside of function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Returning address of reference to a const parameter address of reference parameter transferred outside of function.</description>
    </rule>
    <rule key="M7-5-4">
        <name>M7-5-4: Worst case function for stack usage (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Worst case function for stack usage.</description>
    </rule>
    <rule key="M8-0-1">
        <name>M8-0-1: Multiple declarators in a declaration (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Multiple declarators in a declaration.</description>
    </rule>
    <rule key="M8-3-1">
        <name>M8-3-1: Virtual function has default parameter (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Virtual function has default parameter.</description>
    </rule>
    <rule key="M8-4-1">
        <name>M8-4-1: Function has variable number of arguments (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Function has variable number of arguments.</description>
    </rule>
    <rule key="M8-4-2">
        <name>M8-4-2: Function parameter list differs from prior declaration (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Function parameter list differs from prior declaration.</description>
    </rule>
    <rule key="M8-4-3">
        <name>M8-4-3: Function should return a value (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Function should return a value.</description>
    </rule>
    <rule key="M8-4-4">
        <name>M8-4-4: Function parameter list differs from prior declaration (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Function parameter list differs from prior declaration.</description>
    </rule>
    <rule key="M8-5-1">
        <name>M8-5-1: Symbol not initialized (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Symbol not initialized.</description>
    </rule>
    <rule key="M8-5-2">
        <name>M8-5-2: Omitted braces within an initializer (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Omitted braces within an initializer.</description>
    </rule>
    <rule key="M8-5-3">
        <name>M8-5-3: Should initialize either all enum members or only the first (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Should initialize either all enum members or only the first.</description>
    </rule>
    <rule key="M9-3-1">
        <name>M9-3-1: Const member function anomaly (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Const member function anomaly.</description>
    </rule>
    <rule key="M9-3-2">
        <name>M9-3-2: Member function returns non-const address (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Member function returns non-const address.</description>
    </rule>
    <rule key="M9-3-3">
        <name>M9-3-3: Member function could be made const (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Member function could be made const.</description>
    </rule>
    <rule key="M9-5-1">
        <name>M9-5-1: Unions shall not be used (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unions shall not be used.</description>
    </rule>
    <rule key="M9-6-2">
        <name>M9-6-2: Bit field type should be int (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bit field type should be int.</description>
    </rule>
    <rule key="M9-6-3">
        <name>M9-6-3: Bit field type should be int (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Bit field type should be int.</description>
    </rule>
    <rule key="M9-6-4">
        <name>M9-6-4: Small bit field is signed rather than unsigned (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Small bit field is signed rather than unsigned.</description>
    </rule>
    <rule key="M10-1-1">
        <name>M10-1-1: Base class need not be virtual (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Base class need not be virtual.</description>
    </rule>
    <rule key="M10-1-3">
        <name>M10-1-3: Non-virtual base class included twice in class (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Non-virtual base class included twice in class.</description>
    </rule>
    <rule key="M10-3-2">
        <name>M10-3-2: &apos;virtual&apos; assumed for function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>&apos;virtual&apos; assumed for function.</description>
    </rule>
    <rule key="M11-0-1">
        <name>M11-0-1: Non-private data member within a non-POD structure (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Non-private data member within a non-POD structure.</description>
    </rule>
    <rule key="M12-1-1">
        <name>M12-1-1: Call to virtual function within a constructor or destructor (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Call to virtual function within a constructor or destructor.</description>
    </rule>
    <rule key="M12-1-2">
        <name>M12-1-2: Symbol did not appear in constructor initializer list (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Symbol did not appear in constructor initializer list.</description>
    </rule>
    <rule key="M12-8-1">
        <name>M12-8-1: Constructor access global data (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Constructor access global data.</description>
    </rule>
    <rule key="M12-8-2">
        <name>M12-8-2: Public copy constructor in abstract class (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Public copy constructor in abstract class.</description>
    </rule>
    <rule key="M14-5-1">
        <name>M14-5-1: Generic function template associated with type (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Generic function template associated with type.</description>
    </rule>
    <rule key="M14-5-2">
        <name>M14-5-2: Template constructor cannot be a copy constructor (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Template constructor cannot be a copy constructor.</description>
    </rule>
    <rule key="M14-5-3">
        <name>M14-5-3: Operator =() for class is not assignment operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Operator =() for class is not assignment operator.</description>
    </rule>
    <rule key="M14-6-1">
        <name>M14-6-1: Unqualified name subject to misinterpretation (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unqualified name subject to misinterpretation.</description>
    </rule>
    <rule key="M14-7-1">
        <name>M14-7-1: Template was defined but not instantiated (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Template was defined but not instantiated.</description>
    </rule>
    <rule key="M14-7-3">
        <name>M14-7-3: Specialization occurs in different file than template (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Specialization occurs in different file than template.</description>
    </rule>
    <rule key="M14-8-1">
        <name>M14-8-1: Explicit specialization of overloaded function templates (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Explicit specialization of overloaded function templates.</description>
    </rule>
    <rule key="M14-8-2">
        <name>M14-8-2: Mixing template and non-template functions in a viable set (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Mixing template and non-template functions in a viable set.</description>
    </rule>
    <rule key="M15-0-2">
        <name>M15-0-2: Throwing a pointer expression (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Throwing a pointer expression.</description>
    </rule>
    <rule key="M15-0-3">
        <name>M15-0-3: Case/default within loop; may have been misplaced (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Case/default within loop; may have been misplaced.</description>
    </rule>
    <rule key="M15-1-2">
        <name>M15-1-2: Explicit throw of the NULL macro (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Explicit throw of the NULL macro.</description>
    </rule>
    <rule key="M15-1-3">
        <name>M15-1-3: Empty throw outside of a catch block (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Empty throw outside of a catch block.</description>
    </rule>
    <rule key="M15-3-1">
        <name>M15-3-1: Exception thrown within destructor (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Exception thrown within destructor.</description>
    </rule>
    <rule key="M15-3-4">
        <name>M15-3-4: Uncaught exception not on throw-list (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Uncaught exception not on throw-list.</description>
    </rule>
    <rule key="M15-3-5">
        <name>M15-3-5: Catch parameter is not a reference (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Catch parameter is not a reference.</description>
    </rule>
    <rule key="M15-3-7">
        <name>M15-3-7: Catch handler after catch(...) in a try-catch sequence (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Catch handler after catch(...) in a try-catch sequence.</description>
    </rule>
    <rule key="M15-4-1">
        <name>M15-4-1: Exception specification conflict (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Exception specification conflict.</description>
    </rule>
    <rule key="M15-5-1">
        <name>M15-5-1: Exception thrown within destructor (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Exception thrown within destructor.</description>
    </rule>
    <rule key="M15-5-2">
        <name>M15-5-2: Exception not in throw-list of function (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Exception not in throw-list of function.</description>
    </rule>
    <rule key="M15-5-3">
        <name>M15-5-3: Exception thrown within destructor / uncaught exception not on throw-list (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Exception thrown within destructor / uncaught exception not on throw-list.</description>
    </rule>
    <rule key="M16-0-1">
        <name>M16-0-1: Only preprocessor statements and comments before &apos;#include&apos; (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Only preprocessor statements and comments before &apos;#include&apos;.</description>
    </rule>
    <rule key="M16-0-2">
        <name>M16-0-2: &apos;#define/#undef&apos; used within a block (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>&apos;#define/#undef&apos; used within a block.</description>
    </rule>
    <rule key="M16-0-3">
        <name>M16-0-3: Use of &apos;#undef&apos; is discouraged (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Use of &apos;#undef&apos; is discouraged.</description>
    </rule>
    <rule key="M16-0-4">
        <name>M16-0-4: Use of function-like macros is discouraged (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Use of function-like macros is discouraged.</description>
    </rule>
    <rule key="M16-0-5">
        <name>M16-0-5: Apparent preprocessor directive in macro (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>apparent preprocessor directive in macro.</description>
    </rule>
    <rule key="M16-0-6">
        <name>M16-0-6: Unparenthesized parameter in macro is passed an expression (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unparenthesized parameter in macro is passed an expression.</description>
    </rule>
    <rule key="M16-0-7">
        <name>M16-0-7: Undefined preprocessor variable (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Undefined preprocessor variable.</description>
    </rule>
    <rule key="M16-0-8">
        <name>M16-0-8: Unrecognized name after # / endif or else not followed by EOL (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Unrecognized name after # / endif or else not followed by EOL.</description>
    </rule>
    <rule key="M16-1-1">
        <name>M16-1-1: Non-standard use of &apos;defined&apos; preprocessor operator (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Non-standard use of &apos;defined&apos; preprocessor operator.</description>
    </rule>
    <rule key="M16-1-2">
        <name>M16-1-2: #if not closed off within file (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>#if not closed off within file.</description>
    </rule>
    <rule key="M16-2-2">
        <name>M16-2-2: Macro could become const variable (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Macro could become const variable.</description>
    </rule>
    <rule key="M16-2-3">
        <name>M16-2-3: Header file lacks standard include guard (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Header file lacks standard include guard.</description>
    </rule>
    <rule key="M16-2-4">
        <name>M16-2-4: Header file name with non-standard character (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Header file name with non-standard character.</description>
    </rule>
    <rule key="M16-2-5">
        <name>M16-2-5: header file name with non-standard character (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>header file name with non-standard character.</description>
    </rule>
    <rule key="M16-2-6">
        <name>M16-2-6: need &amp;&lt; or &quot; after #include (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>need &amp;&lt; or &quot; after #include.</description>
    </rule>
    <rule key="M16-3-1">
        <name>M16-3-1: Multiple use of &apos;#&apos; and/or &apos;##&apos; operators in macro definition/FlexeLint (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Multiple use of &apos;#&apos; and/or &apos;##&apos; operators in macro definition.</description>
    </rule>
    <rule key="M16-3-2">
        <name>M16-3-2: no use of &apos;#&apos; or &apos;##&apos; (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>no use of &apos;#&apos; or &apos;##&apos;.</description>
    </rule>
    <rule key="M17-0-1">
        <name>M17-0-1: complain about #define standard functions (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>complain about #define standard functions.</description>
    </rule>
    <rule key="M17-0-2">
        <name>M17-0-2: Re-use of C++ identifier pattern (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Re-use of C++ identifier pattern.</description>
    </rule>
    <rule key="M17-0-4">
        <name>M17-0-4: Use of +elib options to lint library code (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Use of +elib options to lint library code.</description>
    </rule>
    <rule key="M17-0-5">
        <name>M17-0-5: Do not use setjmp and longjmp (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use setjmp and longjmp.</description>
    </rule>
    <rule key="M18-0-1">
        <name>M18-0-1: Do not use C library (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use C library.</description>
    </rule>
    <rule key="M18-0-2">
        <name>M18-0-2: Do not use atof, atoi, atol (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use atof, atoi, atol.</description>
    </rule>
    <rule key="M18-0-3">
        <name>M18-0-3: Do not use abort, exit, getenv, system (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use abort, exit, getenv, system.</description>
    </rule>
    <rule key="M18-0-4">
        <name>M18-0-4: Do not use functions in ctime header (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use functions in ctime header.</description>
    </rule>
    <rule key="M18-0-5">
        <name>M18-0-5: Do not use inbounded functions in cstring header (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use inbounded functions in cstring header.</description>
    </rule>
    <rule key="M18-2-1">
        <name>M18-2-1: Do not use offsetof (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use offsetof.</description>
    </rule>
    <rule key="M18-4-1">
        <name>M18-4-1: Do not use dynamic heap memory allocation functions  (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use dynamic heap memory allocation functions.</description>
    </rule>
    <rule key="M18-7-1">
        <name>M18-7-1: Do not use csignal functions (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use csignal functions.</description>
    </rule>
    <rule key="M19-3-1">
        <name>M19-3-1: Do not use errno (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use errno.</description>
    </rule>
    <rule key="M27-0-1">
        <name>M27-0-1: Do not use cstdio functions (MISRA C++)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>pclint</repo>
        <description>Do not use cstdio functions.</description>
    </rule>
    <rule key="drand48">
        <name>drand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="erand48">
        <name>erand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="initstate">
        <name>initstate</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="jrand48">
        <name>jrand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="lcong48">
        <name>lcong48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="lrand48">
        <name>lrand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="mrand48">
        <name>mrand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="nrand48">
        <name>nrand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="random">
        <name>random</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="seed48">
        <name>seed48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="setstate">
        <name>setstate</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="srand">
        <name>srand</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="srand48">
        <name>srand48</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="strfry">
        <name>strfry</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="memfrob">
        <name>memfrob</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="crypt">
        <name>crypt</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="srandom">
        <name>srandom</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Standard random number generators should not be used to generate
      randomness used for security reasons. For security sensitive
      randomness a cryptographic randomness generator that provides
      sufficient entropy should be used.
    </description>
    </rule>
    <rule key="memcpy">
        <name>memcpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="fixed size global buffer">
        <name>fixed size global buffer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Extra care should be taken to ensure that character arrays that
      are allocated on the stack are used safely. They are prime targets
      for buffer overflow attacks.
    </description>
    </rule>
    <rule key="fixed size local buffer">
        <name>fixed size local buffer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      A potential race condition vulnerability exists here. Normally
      a call to this function is vulnerable only when a match check precedes
      it. No check was detected, however one could still exist that could
      not be detected.
    </description>
    </rule>
    <rule key="strncpy">
        <name>strncpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string. Also, consider using strlcpy() instead, if
      it is available to you.
    </description>
    </rule>
    <rule key="chroot">
        <name>chroot</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>INFO</severity>
        <repo>rats</repo>
        <description>
      Do not forget to chdir() to an appropriate directory before
      calling chroot()!
    </description>
    </rule>
    <rule key="gets">
        <name>gets</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Gets is unsafe!! No bounds checking is performed, buffer is
      easily overflowable by user. Use fgets(buf, size, stdin) instead.
    </description>
    </rule>
    <rule key="system">
        <name>system</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Argument 1 to this function call should be checked to ensure
      that it does not come from an untrusted source without first verifying
      that it contains nothing dangerous.
    </description>
    </rule>
    <rule key="popen">
        <name>popen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Argument 1 to this function call should be checked to ensure
      that it does not come from an untrusted source without first verifying
      that it contains nothing dangerous.
    </description>
    </rule>
    <rule key="getenv">
        <name>getenv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Environment variables are highly untrustable input. They may be
      of any length, and contain any data. Do not make any assumptions
      regarding content or length. If at all possible avoid using them, and
      if it is necessary, sanitize them and truncate them to a reasonable
      length.
    </description>
    </rule>
    <rule key="printf">
        <name>printf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as
      argument 1 to this function call does not come from an untrusted
      source that could have added formatting characters that the code is
      not prepared to handle.
    </description>
    </rule>
    <rule key="sprintf">
        <name>sprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="wsprintf">
        <name>wsprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="wsprintfA">
        <name>wsprintfA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="wsprintfW">
        <name>wsprintfW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_snprintf">
        <name>_snprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_snwprintf">
        <name>_snwprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="lstrcpy">
        <name>lstrcpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="lstrcpyA">
        <name>lstrcpyA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="lstrcpyW">
        <name>lstrcpyW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="wcscpy">
        <name>wcscpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_mbscpy">
        <name>_mbscpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_tcscpy">
        <name>_tcscpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="StrCpy">
        <name>StrCpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="StrCpyA">
        <name>StrCpyA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="StrCpyW">
        <name>StrCpyW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="lstrcat">
        <name>lstrcat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="wcscat">
        <name>wcscat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_mbscat">
        <name>_mbscat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_tcscat">
        <name>_tcscat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="StrCat">
        <name>StrCat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="StrCatA">
        <name>StrCatA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="StrCatW">
        <name>StrCatW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="strxfrm">
        <name>strxfrm</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wcsxfrm">
        <name>wcsxfrm</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_tcsxfrm">
        <name>_tcsxfrm</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="lstrcpyn">
        <name>lstrcpyn</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCpyN">
        <name>StrCpyN</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCpyNA">
        <name>StrCpyNA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCpyNW">
        <name>StrCpyNW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="lstrcpynW">
        <name>lstrcpynW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wcsncpy">
        <name>wcsncpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_mbsncpy">
        <name>_mbsncpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_tcsncpy">
        <name>_tcsncpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_mbsnbcat">
        <name>_mbsnbcat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wcsncat">
        <name>wcsncat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_tcsncat">
        <name>_tcnscat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="MultiByteToWideChar">
        <name>MultiByteToWideChar</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      The last argument is the number of wide chars, not the number of
      bytes. Getting this wrong can cause a buffer overflow since you will
      indicate that the buffer is twice the size it actually is. Don&apos;t
      forget about NULL termination.
    </description>
    </rule>
    <rule key="WideCharToMultiByte">
        <name>WideCharToMultiByte</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrNCat">
        <name>StrNCat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCatBuff">
        <name>StrCatBuff</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCatBuffA">
        <name>StrCatBuffA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCatBuffW">
        <name>StrCatBuffW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCatN">
        <name>StrCatN</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCatNA">
        <name>StrCatNA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrCatNW">
        <name>StrCatNW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatByteSize">
        <name>StrFormatByteSize</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatByteSizeA">
        <name>StrFormatByteSizeA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatByteSizeW">
        <name>StrFormatByteSizeW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatByteSize64">
        <name>StrFormatByteSize64</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatByteSize64A">
        <name>StrFormatByteSize64A</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatByteSize64W">
        <name>StrFormatByteSize64W</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatKBSize">
        <name>StrFormatKBSize</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatKBSizeA">
        <name>StrFormatKBSizeA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFormatKBSizeW">
        <name>StrFormatKBSizeW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFromTimeInterval">
        <name>StrFromTimeInterval</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFromTimeIntervalA">
        <name>StrFromTimeIntervalA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="StrFromTimeIntervalW">
        <name>StrFromTimeIntervalW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wvnsprintf">
        <name>wvnsprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wvnsprintfA">
        <name>wvnsprintfA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wvnsprintfW">
        <name>wvnsprintfW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wnsprintf">
        <name>wnsprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wnsprintfA">
        <name>wnsprintfA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="wnsprintfW">
        <name>wnsprintfW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="PathAddExtension">
        <name>PathAddExtension</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAddExtensionA">
        <name>PathAddExtensionA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAddExtensionW">
        <name>PathAddExtensionW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAddBackslash">
        <name>PathAddBackslash</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAddBackslashA">
        <name>PathAddBackslashA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAddBackslashW">
        <name>PathAddBackslashW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAppend">
        <name>PathAppend</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAppendA">
        <name>PathAppendA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathAppendW">
        <name>PathAppendW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathCanonicalize">
        <name>PathCanonicalize</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathCanonicalizeA">
        <name>PathCanonicalizeA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathCanonicalizeW">
        <name>PathCanonicalizeW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathCombine">
        <name>PathCombine</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathCombineA">
        <name>PathCombineA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="PathCombineW">
        <name>PathCombineW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Buffer size must be _MAX_PATH+1 or larger for this function to
      be safe.
    </description>
    </rule>
    <rule key="LoadLibrary">
        <name>LoadLibrary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      LoadLibrary will search several places for a library if no path
      is specified, allowing trojan DLL&apos;s to be inserted elsewhere even if
      the intended DLL is correctly protected from overwriting. Make sure to
      specify the full path.
    </description>
    </rule>
    <rule key="LoadLibraryA">
        <name>LoadLibraryA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      LoadLibrary will search several places for a library if no path
      is specified, allowing trojan DLL&apos;s to be inserted elsewhere even if
      the intended DLL is correctly protected from overwriting. Make sure to
      specify the full path.
    </description>
    </rule>
    <rule key="LoadLibraryW">
        <name>LoadLibraryW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      LoadLibrary will search several places for a library if no path
      is specified, allowing trojan DLL&apos;s to be inserted elsewhere even if
      the intended DLL is correctly protected from overwriting. Make sure to
      specify the full path.
    </description>
    </rule>
    <rule key="GetExtensionVersion">
        <name>GetExtensionVersion</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      GetExtensionVersion() is called by IIS in the system&apos;s security
      context. Be very careful what you do here, as you are basically suid
      root for the machine. If you are calling the function rather than
      implementing it, how about *not* calling it in the system&apos;s security
      context if possible?
    </description>
    </rule>
    <rule key="OemToChar">
        <name>OemToChar</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="OemToCharA">
        <name>OemToCharA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="OemToCharW">
        <name>OemToCharW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="OemToCharBuff">
        <name>OemToCharBuff</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="OemToCharBuffA">
        <name>OemToCharBuffA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="OemToCharBuffW">
        <name>OemToCharBuffW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="OemToAnsi">
        <name>OemToAnsi</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="OemToAnsiA">
        <name>OemToAnsiA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="OemToAnsiW">
        <name>OemToAnsiW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="OemToAnsiBuff">
        <name>OemToAnsiBuff</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="OemToAnsiBuffA">
        <name>OemToAnsiBuffA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="OemToAnsiBuffW">
        <name>OemToAnsiBuffW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="GetTempPath">
        <name>GetTempPath</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      GetTempPath() may return the current directory or the windows
      directory. Be careful what you place in these locations. Important
      files may be overwritten, and trojan DLL&apos;s may be dropped in these
      locations. Never use a user-input file name when writing to a location
      given by GetTempPath().
    </description>
    </rule>
    <rule key="GetTempPathA">
        <name>GetTempPathA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      GetTempPath() may return the current directory or the windows
      directory. Be careful what you place in these locations. Important
      files may be overwritten, and trojan DLL&apos;s may be dropped in these
      locations. Never use a user-input file name when writing to a location
      given by GetTempPath().
    </description>
    </rule>
    <rule key="GetTempPathW">
        <name>GetTempPathW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      GetTempPath() may return the current directory or the windows
      directory. Be careful what you place in these locations. Important
      files may be overwritten, and trojan DLL&apos;s may be dropped in these
      locations. Never use a user-input file name when writing to a location
      given by GetTempPath().
    </description>
    </rule>
    <rule key="GetTempFileName">
        <name>GetTempFileName</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many calls for generating temporary file names are insecure
      (susceptible to race conditions). Use a securely generated file name,
      for example, by pulling 64 bits of randomness from /dev/random, base
      64 encoding it and using that as a file suffix.
    </description>
    </rule>
    <rule key="GetTempFileNameA">
        <name>GetTempFileNameA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many calls for generating temporary file names are insecure
      (susceptible to race conditions). Use a securely generated file name,
      for example, by pulling 64 bits of randomness from /dev/random, base
      64 encoding it and using that as a file suffix.
    </description>
    </rule>
    <rule key="GetTempFileNameW">
        <name>GetTempFileNameW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many calls for generating temporary file names are insecure
      (susceptible to race conditions). Use a securely generated file name,
      for example, by pulling 64 bits of randomness from /dev/random, base
      64 encoding it and using that as a file suffix.
    </description>
    </rule>
    <rule key="ShellExecute">
        <name>ShellExecute</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="ShellExecuteA">
        <name>ShellExecuteA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="ShellExecuteW">
        <name>ShellExecuteW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="ShellExecuteEx">
        <name>ShellExecuteEx</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="ShellExecuteExA">
        <name>ShellExecuteExA</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="ShellExecuteExW">
        <name>ShellExecuteExW</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wsystem">
        <name>_wsystem</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_texecl">
        <name>_texecl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_execl">
        <name>_execl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wexecl">
        <name>_wexecl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_texecle">
        <name>_texecle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_execle">
        <name>_execle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wexecle">
        <name>_wexecle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_texeclp">
        <name>_texeclp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_execlp">
        <name>_execlp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wexeclp">
        <name>_wexeclp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_texeclpe">
        <name>_texeclpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_execlpe">
        <name>_execlpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wexeclpe">
        <name>_wexeclpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_texecv">
        <name>_texecv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_execv">
        <name>_execv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wexecv">
        <name>_wexecv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_texecve">
        <name>_texecve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_execve">
        <name>_execve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wexecve">
        <name>_wexecve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_texecvp">
        <name>_texecvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_execvp">
        <name>_execvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wexecvp">
        <name>_wexecvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_texecvpe">
        <name>_texecvpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_execvpe">
        <name>_execvpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wexecvpe">
        <name>_wexecvpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_tspawnl">
        <name>_tspawnl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_spawnl">
        <name>_spawnl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wspawnl">
        <name>_wspawnl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_spawnle">
        <name>_spawnle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wspawnle">
        <name>_wspawnle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_tspawnlp">
        <name>_tspawnlp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_spawnlp">
        <name>_spawnlp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wspawnlp">
        <name>_wspawnlp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_tspawnlpe">
        <name>_tspawnlpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_spawnlpe">
        <name>_spawnlpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wspawnlpe">
        <name>_wspawnlpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_tspawnv">
        <name>_tspawnv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_spawnv">
        <name>_spawnv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wspawnv">
        <name>_wspawnv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_tspawnve">
        <name>_tspawnve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_spawnve">
        <name>_spawnve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_wspawnve">
        <name>_wspawnve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_tspawnle">
        <name>_tspawnle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      While this _exec variant does not search the path for a program
      (good!), it will run .com files before .exe files and the like. Make
      sure to specify a file extension.
    </description>
    </rule>
    <rule key="_tspawnvp">
        <name>_tspawnvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_spawnvp">
        <name>_spawnvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wspawnvp">
        <name>_wspawnvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_tspawnvpe">
        <name>_tspawnvpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_spawnvpe">
        <name>_spawnvpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="_wspawnvpe">
        <name>_wspawnvpe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="scanf">
        <name>scanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 1 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="sscanf">
        <name>sscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="fscanf">
        <name>fscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="vfscanf">
        <name>vfscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="vsprintf">
        <name>vsprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="vscanf">
        <name>vscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 1 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="vsscanf">
        <name>vsscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="streadd">
        <name>streadd</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="strecpy">
        <name>strecpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="strtrns">
        <name>strtrns</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="realpath">
        <name>realpath</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Be sure the destination buffer is at least MAXPATHLEN big. This
      function may still internally overflow a static buffer, try to avoid
      using it. If you must, check the size the path your pass in is no
      longer than MAXPATHLEN.
    </description>
    </rule>
    <rule key="syslog">
        <name>syslog</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Truncate all input strings to a reasonable length before passing
      them to this function.
    </description>
    </rule>
    <rule key="getopt">
        <name>getopt</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Truncate all input strings to a reasonable length before passing
      them to this function.
    </description>
    </rule>
    <rule key="getopt_long">
        <name>getopt_long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Truncate all input strings to a reasonable length before passing
      them to this function.
    </description>
    </rule>
    <rule key="getpass">
        <name>getpass</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Truncate all input strings to a reasonable length before passing
      them to this function.
    </description>
    </rule>
    <rule key="getchar">
        <name>getchar</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check buffer boundaries if calling this function in a loop and
      make sure you are not in danger of writing past the allocated space.
    </description>
    </rule>
    <rule key="fgetc">
        <name>fgetc</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check buffer boundaries if calling this function in a loop and
      make sure you are not in danger of writing past the allocated space.
    </description>
    </rule>
    <rule key="getc">
        <name>getc</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check buffer boundaries if calling this function in a loop and
      make sure you are not in danger of writing past the allocated space.
    </description>
    </rule>
    <rule key="read">
        <name>read</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check buffer boundaries if calling this function in a loop and
      make sure you are not in danger of writing past the allocated space.
    </description>
    </rule>
    <rule key="bcopy">
        <name>bcopy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="fgets">
        <name>fgets</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="cin">
        <name>cin</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      cin is unsafe. No bounds checking is performed. Buffer is
      easily overflowable by user.
    </description>
    </rule>
    <rule key="snprintf">
        <name>snprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="strccpy">
        <name>strccpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="strcadd">
        <name>strcadd</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="_vsnprintf">
        <name>_vsnprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="tmpfile">
        <name>tmpfile</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many calls for generating temporary file names are insecure
      (susceptible to race conditions). Use a securely generated file name,
      for example, by pulling 64 bits of randomness from /dev/random, base
      64 encoding it and using that as a file suffix.
    </description>
    </rule>
    <rule key="tmpnam">
        <name>tmpnam</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many calls for generating temporary file names are insecure
      (susceptible to race conditions). Use a securely generated file name,
      for example, by pulling 64 bits of randomness from /dev/random, base
      64 encoding it and using that as a file suffix.
    </description>
    </rule>
    <rule key="tempnam">
        <name>tempnam</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Many calls for generating temporary file names are insecure
      (susceptible to race conditions). Use a securely generated file name,
      for example, by pulling 64 bits of randomness from /dev/random, base
      64 encoding it and using that as a file suffix.
    </description>
    </rule>
    <rule key="getlogin">
        <name>getlogin</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      The results of this call are easy to forge.
    </description>
    </rule>
    <rule key="cuserid">
        <name>cuserid</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      This may be forgable. Whether it is or not, even the man page
      recommends against using this.
    </description>
    </rule>
    <rule key="ttyname">
        <name>ttyname</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      The results are easy for an attacker to forge, and not reliable.
    </description>
    </rule>
    <rule key="signal">
        <name>signal</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      When setting signal handlers, do not use the same function to
      handle multiple signals. There exists the possibility a race condition
      will result if 2 or more different signals are sent to the process at
      nearly the same time. Also, when writing signal handlers, it is best
      to do as little as possible in them. The best strategy is to use the
      signal handler to set a flag, that another part of the program tests
      and performs the appropriate action(s) when it is set.
    </description>
    </rule>
    <rule key="gethostbyname">
        <name>gethostbyname</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      WDNS results can easily be forged by an attacker (or arbitrarily
      set to large values, etc), and should not be trusted.
    </description>
    </rule>
    <rule key="gethostbyaddr">
        <name>gethostbyaddr</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      WDNS results can easily be forged by an attacker (or arbitrarily
      set to large values, etc), and should not be trusted.
    </description>
    </rule>
    <rule key="realloc">
        <name>realloc</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Don&apos;t use on memory intended to be secure, because the old
      structure will not be zeroed out.
    </description>
    </rule>
    <rule key="fork">
        <name>fork</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Remember that sensitive data get copied on fork. For example, a
      random number generator&apos;s internal state will get duplicated, and the
      child may start outputting identical number streams.
    </description>
    </rule>
    <rule key="vfork">
        <name>vfork</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Some implementations may be broken. Additionally, Remember that
      sensitive data get copied on fork. For example, a random number
      generator&apos;s internal state will get duplicated, and the child may
      start outputting identical number streams. Use fork() instead.
    </description>
    </rule>
    <rule key="_mbsnbcpy">
        <name>_mbsnbcpy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="CopyMemory">
        <name>CopyMemory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When
      using functions that accept a number n of bytes to copy, such as
      strncpy, be aware that if the destination buffer size = n it may not
      NULL-terminate the string.
    </description>
    </rule>
    <rule key="strlen">
        <name>strlen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      This function does not properly handle non-NULL terminated
      strings. This does not result in exploitable code, but can lead to
      access violations.
    </description>
    </rule>
    <rule key="_tcslen">
        <name>_tcslen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      This function does not properly handle non-NULL terminated
      strings. This does not result in exploitable code, but can lead to
      access violations.
    </description>
    </rule>
    <rule key="_mbslen">
        <name>_mbslen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      This function does not properly handle non-NULL terminated
      strings. This does not result in exploitable code, but can lead to
      access violations.
    </description>
    </rule>
    <rule key="wcslen">
        <name>wcslen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      This function does not properly handle non-NULL terminated
      strings. This does not result in exploitable code, but can lead to
      access violations.
    </description>
    </rule>
    <rule key="CreateProcess">
        <name>CreateProcess</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="CreateProcessAsUser">
        <name>CreateProcessAsUser</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="CreateProcessWithLogon">
        <name>CreateProcessWithLogon</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="WinExec">
        <name>WinExec</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Many program execution commands under Windows will search the
      path for a program if you do not explicitly specify a full path to the
      file. This can allow trojans to be executed instead. Also, be sure to
      specify a file extension, since otherwise multiple extensions will be
      tried by the operating system, providing another opportunity for
      trojans.
    </description>
    </rule>
    <rule key="RpcImpersonateClient">
        <name>RpcImpersonateClient</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="ImpersonateLoggedOnUser">
        <name>ImpersonateLoggedOnUser</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="CoImpersonateClient">
        <name>CoImpersonateClient</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="ImpersonateNamedPipeClient">
        <name>ImpersonateNamedPipeClient</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="ImpersonateDdeClientWindow">
        <name>ImpersonateDdeClientWindow</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="ImpersonateSecurityContext">
        <name>ImpersonateSecurityContext</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="QuerySecurityContextToken">
        <name>QuerySecurityContextToken</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="SetThreadToken">
        <name>SetThreadToken</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Impersonation functions return error codes when they fail.
      These error codes must be checked otherwise code could be run with
      extra privileges when an impersonation has failed.
    </description>
    </rule>
    <rule key="SetSecurityDescriptorDacl">
        <name>SetSecurityDescriptorDacl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      If the third argument, pDacl, is NULL there is no protection
      from attack. As an example, an attacker could set a Deny All to
      Everyone ACE on such an object.
    </description>
    </rule>
    <rule key="AfxLoadLibrary">
        <name>AfxLoadLibrary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      LoadLibrary will search several places for a library if no path
      is specified, allowing trojan DLL&apos;s to be inserted elsewhere even if
      the intended DLL is correctly protected from overwriting. Make sure to
      specify the full path.
    </description>
    </rule>
    <rule key="LoadLibraryEx">
        <name>LoadLibraryEx</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      LoadLibrary will search several places for a library if no path
      is specified, allowing trojan DLL&apos;s to be inserted elsewhere even if
      the intended DLL is correctly protected from overwriting. Make sure to
      specify the full path.
    </description>
    </rule>
    <rule key="InitializeCriticalSection">
        <name>InitializeCriticalSection</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      This function can throw exceptions in low memory conditions. Use
      InitialCriticalSectionAndSpinCount instead.
    </description>
    </rule>
    <rule key="EnterCriticalSection">
        <name>EnterCriticalSection</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      This function can throw exceptions in low memory conditions. Use
      InitialCriticalSectionAndSpinCount instead.
    </description>
    </rule>
    <rule key="catgets">
        <name>catgets</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Environment variables are highly untrustable input. They may be
      of any length, and contain any data. Do not make any assumptions
      regarding content or length. If at all possible avoid using them, and
      if it is necessary, sanitize them and truncate them to a reasonable
      length. catgets() can utilize the NLSPATH environment variable.
    </description>
    </rule>
    <rule key="gettext">
        <name>gettext</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      Environment variables are highly untrustable input. They may be
      of any length, and contain any data. Do not make any assumptions
      regarding content or length. If at all possible avoid using them, and
      if it is necessary, sanitize them and truncate them to a reasonable
      length. catgets() can utilize the NLSPATH environment variable.
    </description>
    </rule>
    <rule key="umask">
        <name>umask</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      umask() can easily be used to create files with unsafe
      privileges. It should be set to restrictive values.
    </description>
    </rule>
    <rule key="AddAccessAllowedAce">
        <name>AddAccessAllowedAce</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>rats</repo>
        <description>
      This function does not set the inheritance bits in the Access
      Control Entry, making it vulnerable.
    </description>
    </rule>
    <rule key="access">
        <name>access</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The check should not be used to condition a
      file system call (such as fopen) on the same resource.
    </description>
    </rule>
    <rule key="lstat">
        <name>lstat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The check should not be used to condition a
      file system call (such as open) on the same resource.
    </description>
    </rule>
    <rule key="stat">
        <name>stat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The check should not be used to condition a
      file system call (such as open) on the same resource.
      Prefer fstat() when possible
    </description>
    </rule>
    <rule key="creat">
        <name>creat</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
    </description>
    </rule>
    <rule key="mknod">
        <name>mknod</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
    </description>
    </rule>
    <rule key="mkfifo">
        <name>mkfifo</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
    </description>
    </rule>
    <rule key="pathconf">
        <name>pathconf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
      Prefer the use of fpathconf() when possible.
    </description>
    </rule>
    <rule key="opendir">
        <name>opendir</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
    </description>
    </rule>
    <rule key="dirname">
        <name>dirname</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
    </description>
    </rule>
    <rule key="basename">
        <name>basename</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource. An
      application-specific sanity check should probably occur after the call
      if it needs to be secured.
    </description>
    </rule>
    <rule key="scandir">
        <name>scandir</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="fopen">
        <name>fopen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="open">
        <name>open</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="chmod">
        <name>chmod</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
      Prefer the use of fchmod() when possible.
    </description>
    </rule>
    <rule key="chown">
        <name>chown</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
      Prefer the use of fchown() when possible.
    </description>
    </rule>
    <rule key="chgrp">
        <name>chgrp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="rename">
        <name>rename</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="mkdir">
        <name>mkdir</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="mkdirp">
        <name>mkdirp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="rmdirp">
        <name>rmdirp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="rmdir">
        <name>rmdir</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="remove">
        <name>remove</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="unlink">
        <name>unlink</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="link">
        <name>link</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="lchown">
        <name>lchown</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="execve">
        <name>execve</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="execl">
        <name>execl</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="execlp">
        <name>execlp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="execle">
        <name>execle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="execv">
        <name>execv</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="execvp">
        <name>execvp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="freopen">
        <name>freopen</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="mktemp">
        <name>mktemp</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>rats</repo>
        <description>
      The function can be part of a TOCTOU (Time of check to time of use)
      race condition. The call should not be conditional to a preceding
      file system check (such as stat) on the same resource.
    </description>
    </rule>
    <rule key="fprintf">
        <name>fprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 2
      to this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="vfprintf">
        <name>vfprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 2
      to this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="vprintf">
        <name>vprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 1
      to this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="_ftprintf">
        <name>_ftprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 2 to
      this function call does not come from an untrusted source that could have added
      formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="_stscanf">
        <name>_stscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="swprintf">
        <name>swprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_stprintf">
        <name>_stprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_tprintf">
        <name>_tprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 1 to
      this function call does not come from an untrusted source that could have added
      formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="wprintf">
        <name>wprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 1 to
      this function call does not come from an untrusted source that could have added
      formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="_cprintf">
        <name>_cprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 1 to
      this function call does not come from an untrusted source that could have added
      formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="_cscanf">
        <name>_cscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_ftscanf">
        <name>_ftscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="_vsnwprintf">
        <name>_vsnwprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Double check that your buffer is as big as you specify. When using functions
      that accept a number n of bytes to copy, such as strncpy, be aware that if the
      dest buffer size = n it may not NULL-terminate the string.&quot;
    </description>
    </rule>
    <rule key="fwprintf">
        <name>fwprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 2 to
      this function call does not come from an untrusted source that could have added
      formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="fwscanf">
        <name>fwscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to
      this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to
      handle. Additionally, the format string could contain `%s&apos; without
      precision that could result in a buffer overflow.
    </description>
    </rule>
    <rule key="getwd">
        <name>getwd</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 1 to this function
      call does not come from an untrusted source that could have added formatting
      characters that the code is not prepared to handle.  Additionally, the format
      string could contain `%s&apos; without precision that could result in a buffer overflow
    </description>
    </rule>
    <rule key="vfwprintf">
        <name>vfwprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 2
      to this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="vswprintf">
        <name>vswprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to this function
      call does not come from an untrusted source that could have added formatting
      characters that the code is not prepared to handle.  Additionally, the format
      string could contain `%s&apos; without precision that could result in a buffer overflow
    </description>
    </rule>
    <rule key="vwprintf">
        <name>vwprintf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the non-constant format string passed as argument 1
      to this function call does not come from an untrusted source that could
      have added formatting characters that the code is not prepared to handle.
    </description>
    </rule>
    <rule key="wscanf">
        <name>wscanf</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>rats</repo>
        <description>
      Check to be sure that the format string passed as argument 2 to this function
      call does not come from an untrusted source that could have added formatting
      characters that the code is not prepared to handle.  Additionally, the format
      string could contain `%s&apos; without precision that could result in a buffer overflow
    </description>
    </rule>
    <rule key="F001">
        <name>(CR) detected in isolation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      As a commonly accepted practice, line breaks are denoted by a
      single &apos;\n&apos; (LF) character or by two characters &quot;\r\n&quot; (CRLF).
      A single appearance of &apos;\r&apos; (CR) is discouraged.
    </description>
    </rule>
    <rule key="F002">
        <name>File names should be well formed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The source file names should be well-formed in the sense of
      their allowed maximum length and directory depth. Directory and
      file names should start with alphabetic character or
      underscore. In addition, directory names should not contain dots
      and file names can have only one dot.
    </description>
    </rule>
    <rule key="L001">
        <name>Avoid trailing whitespace</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Trailing whitespace is any whitespace character (space or tab)
      that is placed at the end of the source line, after other
      characters or alone. The presence of trailing whitespace
      artificially influences some source code metrics and is
      therefore discouraged. As a special case, the trailing
      whitespace in the otherwise empty lines is allowed provided that
      the amount of whitespace is identical to the indent in the
      previous line.
    </description>
    </rule>
    <rule key="L002">
        <name>Don&apos;t use tab characters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Horizontal tabs are not consistently handled by editors and
      tools. Avoiding them ensures that the intended formatting of the
      code is preserved.
    </description>
    </rule>
    <rule key="L003">
        <name>No leading and no trailing empty lines</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Leading and trailing empty lines confuse users of various tools
      (like head and tail) and artificially influence some source code
      metrics.
    </description>
    </rule>
    <rule key="L004">
        <name>Line too long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The source code line should not exceed some reasonable length.
    </description>
    </rule>
    <rule key="L005">
        <name>Too many consecutive empty lines</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The empty lines (if any) help to introduce more &quot;light&quot; in the
      source code, but they should not be overdosed in the sense that
      too many consecutive empty lines make the code harder to follow.
      Lines containing only whitespace are considered to be empty in
      this context.
    </description>
    </rule>
    <rule key="L006">
        <name>Source file is too long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The source file should not exceed a reasonable length.
      Long source files can indicate an opportunity for refactoring.
    </description>
    </rule>
    <rule key="T001">
        <name>One-line comments should not have forced continuation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The one-line comment is a comment that starts with //.

      The usual intent is to let the comment continue till the end of
      the line, but the preprocessing rules of the language allow to
      actually continue the comment in the next line if line-splicing
      is forced with the backslash at the end of the line.

      But the line-splicing works only if the backslash is really the
      last character in the line - which is error prone because any
      white characters that might appear after the backslash will
      change the meaning of the program without being visible in the
      code.
    </description>
    </rule>
    <rule key="T002">
        <name>Reserved name used for macro</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The C++ Standard reserves some forms of names for language
      implementations. One of the most frequent violations is a
      definition of preprocessor macro that begins with underscore
      followed by a capital letter or containing two consecutive
      underscores.

      Even though the majority of known compilers use more obscure
      names for internal purposes and the above code is not likely to
      cause any significant problems, all such names are formally
      reserved and therefore should not be used.

      Apart from the use of underscore in macro names, preprocessor
      macros should not be used to redefine language keywords.
    </description>
    </rule>
    <rule key="T003">
        <name>Keyword not followed by a single space</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The keywords &quot;case&quot;, &quot;class&quot;, &quot;delete&quot;, &quot;enum&quot;, &quot;explicit&quot;,
      &quot;extern&quot;, &quot;goto&quot;, &quot;new&quot;, &quot;struct&quot;, &quot;union&quot; and &quot;using&quot;
      should be followed by a single space for better readability.
    </description>
    </rule>
    <rule key="T004">
        <name>Keyword not immediately followed by a colon</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The keywords &quot;default&quot;, &quot;private&quot;, &quot;protected&quot; and &quot;public&quot;
      should be immediately followed by a colon, unless used in the
      list of base classes.
    </description>
    </rule>
    <rule key="T005">
        <name>Keyword not immediately followed by a semicolon</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The break and continue keywords should be immediately followed
      by a semicolon, with no other tokens in between.
    </description>
    </rule>
    <rule key="T006">
        <name>Keyword not immediately followed by a semicolon or a single space</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The return and throw keywords should be immediately followed by
      a semicolon or a single space. An exception to this rule is
      allowed for exception specifications.
    </description>
    </rule>
    <rule key="T007">
        <name>Semicolon is isolated from other tokens</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The semicolon should not stand isolated by whitespace or
      comments from the rest of the code. As an exception from this
      rule, semicolons surrounded by spaces are allowed in for loops:
    </description>
    </rule>
    <rule key="T008">
        <name>Keyword not followed by a single space</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Keywords catch, for, if, switch and while should be followed by
      a single space and then an opening left parenthesis.
    </description>
    </rule>
    <rule key="T009">
        <name>Wrong spacing around comma</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      A comma, whether used as operator or in various lists, should
      not be preceded by whitespace on its left side, but should be
      followed by whitespace on its right side:
    </description>
    </rule>
    <rule key="T010">
        <name>Identifiers should not be composed of only &apos;l&apos; and &apos;O&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The characters &apos;l&apos; (which is lowercase &apos;L&apos;) and &apos;O&apos; (which is
      uppercase &apos;o&apos;) should not be the only characters used in the
      identifier, because this would make them visually similar to
      numeric literals.
    </description>
    </rule>
    <rule key="T011">
        <name>Opening/closing curly bracket mistake</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Corresponding curly brackets should be either in the same line
      or in the same column. This promotes clarity by emphasizing
      scopes, but allows concise style of one-line definitions and
      empty blocks.
    </description>
    </rule>
    <rule key="T012">
        <name>Negation operator used in its short form</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The negation operator (exclamation mark) reduces readability of
      the code due to its terseness. Prefer explicit logical
      comparisons or alternative tokens for increased readability:
    </description>
    </rule>
    <rule key="T013">
        <name>No copyright notice found</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The copyright notice is required by man coding standards and
      guidelines. In some countries every written artwork has some
      copyright, even if implicit. Prefer explicit notice to avoid any
      later confusion.
      This rule verifies that at least one comment in the source file
      contains the &quot;copyright&quot; word.
    </description>
    </rule>
    <rule key="T014">
        <name>No reference to the Boost Software License found</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The Boost Software License should be referenced in the source
      code. This rule verifies that at least one comment in the
      source file contains the &quot;Boost Software License&quot; phrase. Note
      that this rule is very specific to the Boost libraries and those
      project that choose to use the Boost license. It is therefore
      not part of the default profile.
    </description>
    </rule>
    <rule key="T015">
        <name>Incorrect HTML links</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The links embedded in comments and string literals should have
      correct form and should reference existing files.
    </description>
    </rule>
    <rule key="T016">
        <name>Min/max potential macro substitution problem</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      The calls to min and max functions should be protected against accidental macro substitution.
    </description>
    </rule>
    <rule key="T017">
        <name>Unnamed namespace not allowed in header file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Unnamed namespaces are not allowed in header files.
      The typical use of unnamed namespace is to hide module-internal
      names from the outside world. Header files are physically
      concatenated in a single translation unit, which logically
      merges all namespaces with the same name. Unnamed namespaces are
      also merged in this process, which effectively undermines their
      initial purpose.
      Use named namespaces in header files. Unnamed namespaces are
      allowed in implementation files only.
    </description>
    </rule>
    <rule key="T018">
        <name>Using namespace not allowed in header file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Using namespace directives are not allowed in header files.

      The using namespace directive imports names from the given
      namespace and when used in a header file influences the global
      namespace of all the files that directly or indirectly include
      this header file.

      It is imaginable to use the using namespace directive in a
      limited scope in a header file (for example in a template or
      inline function definition), but for the sake of consistency
      this is also discouraged.
    </description>
    </rule>
    <rule key="T019">
        <name>Full block {} expected in the control structure</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>vera++</repo>
        <description>
      Control structures managed by &apos;for&apos;, &apos;if&apos; and &apos;while&apos; constructs can
      be associated with a single instruction or with a complex block
      of code. Standardizing on the curly-braced blocks in all cases
      allows to avoid common pitfalls and makes the code visually more
      uniform.
    </description>
    </rule>
    <rule key="InvalidFree">
        <name>Invalid free</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      Calling free with the given address is illegal. This usually means
      that the block is already freed or that the block has never been
      allocated on the heap.
    </description>
    </rule>
    <rule key="MismatchedFree">
        <name>Mismatched free() / delete / delete []</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      Wrong deallocation function used to deallocate an allocated
      block. C++ rules are:
      - deallocate with &apos;free&apos; when allocated with &apos;malloc&apos;, &apos;calloc&apos;,
      &apos;realloc&apos;, &apos;valloc&apos; or &apos;memalign&apos;
      - deallocate with &apos;delete&apos; when allocated with &apos;new&apos;
      - deallocate with &apos;delete []&apos; when allocated with &apos;new []&apos;
    </description>
    </rule>
    <rule key="InvalidRead">
        <name>Invalid read</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      This happens when your program reads memory at a place which
      Memcheck reckons it shouldn&apos;t. The reasons include reading memory which
      isn&apos;t mapped, reading already freed memory etc.
    </description>
    </rule>
    <rule key="InvalidWrite">
        <name>Invalid write</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      This happens when your program writes memory at a place which
      Memcheck reckons it shouldn&apos;t. The reasons include writing to memory
      which isn&apos;t mapped, writing to already freed memory, writing to
      read-only memory etc.
    </description>
    </rule>
    <rule key="InvalidJump">
        <name>Invalid jump or move</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      The program tried to jump or move to an invalid address.
    </description>
    </rule>
    <rule key="Overlap">
        <name>Overlap of source and destination memory blocks</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      The following C library functions copy some data from one memory
      block to another (or something similar): memcpy, strcpy, strncpy,
      strcat, strncat. The blocks pointed to by their &apos;src&apos; and &apos;dst&apos; pointers
      aren&apos;t allowed to overlap.
    </description>
    </rule>
    <rule key="InvalidMemPool">
        <name>Invalid memory pool</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>valgrind</repo>
        <description>
      Invalid memory pool specified in client request.
    </description>
    </rule>
    <rule key="UninitCondition">
        <name>Condition depends on undefined value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      Programs behavior relies on a variable whose value is not initialized,
      i.e. the program has undefined behavior.
    </description>
    </rule>
    <rule key="UninitValue">
        <name>Use of undefined value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>valgrind</repo>
        <description>
      Other uses of undefined values (primarily memory addresses).
    </description>
    </rule>
    <rule key="SyscallParam">
        <name>Invalid system call parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>CRITICAL</severity>
        <repo>valgrind</repo>
        <description>
      A system call has been passed an &apos;out&apos; or &apos;in&apos; buffer which
      either isn&apos;t fully addressable or hasn&apos;t been properly initialized.
    </description>
    </rule>
    <rule key="ClientCheck">
        <name>Error in client request</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>valgrind</repo>
        <description>
      &quot;Error&quot; resulting from a client check request.
    </description>
    </rule>
    <rule key="Leak_DefinitelyLost">
        <name>Memory leak (definitely lost)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>valgrind</repo>
        <description>
      Memory block which was unfreed at programs exit and for which
      no pointer pointing at it could be found.  Such blocks are
      classified as &quot;lost&quot;, because the programmer could not possibly have
      freed it at program exit, since no pointer to it exists. This is
      likely a symptom of having lost the pointer at some earlier point in
      the program. Such cases should be fixed by the programmer.
    </description>
    </rule>
    <rule key="Leak_IndirectlyLost">
        <name>Memory leak (indirectly lost)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>valgrind</repo>
        <description>
      This means that the block is lost, not because there are no
      pointers to it, but rather because all the blocks that point to it are
      themselves lost. For example, if you have a binary tree and the root
      node is lost, all its children nodes will be indirectly lost.
    </description>
    </rule>
    <rule key="Leak_PossiblyLost">
        <name>Memory leak (possibly lost)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MAJOR</severity>
        <repo>valgrind</repo>
        <description>
      This means that a chain of one or more pointers to a block
      has been found, but at least one of the pointers is an
      interior-pointer. This could just be a random value in memory that
      happens to point into a block, and so you shouldn&apos;t consider this OK
      unless you know you have interior-pointers.
    </description>
    </rule>
    <rule key="Leak_StillReachable">
        <name>Memory leak (still reachable)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>MINOR</severity>
        <repo>valgrind</repo>
        <description>
      Blocks of memory which weren&apos;t lost (pointers pointing to them existed)
      but also weren&apos;t freed at process&apos; exit. Since the block are pointed at,
      the programmer could, at least in principle, have freed it before
      the exit.
    </description>
    </rule>
    <rule key="C4001">
        <name>warning C4001: nonstandard extension &apos;single line comment&apos; was used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Single-line comments are standard in C++ and nonstandard in
      C. Under strict ANSI compatibility (/Za), C files that contain
      single-line comments, generate C4001 due to the usage of a nonstandard
      extension. Since single-line comments are standard in C++, C files
      containing single-line comments do not produce C4001 when compiling
      with Microsoft extensions (/Ze).
    </description>
    </rule>
    <rule key="C4002">
        <name>warning C4002: too many actual parameters for macro &apos;identifier&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The number of actual parameters in the macro exceeds the number
      of formal parameters in the macro definition.  The preprocessor
      collects the extra parameters but ignores them during macro expansion.
    </description>
    </rule>
    <rule key="C4003">
        <name>warning C4003: not enough actual parameters for macro &apos;identifier&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The number of formal parameters in the macro definition exceeds
      the number of actual parameters in the macro. Macro expansion
      substitutes empty text for the missing parameters.
    </description>
    </rule>
    <rule key="C4005">
        <name>warning C4005: &apos;identifier&apos; : macro redefinition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The macro identifier is defined twice. The compiler uses the
      second macro definition.
    </description>
    </rule>
    <rule key="C4007">
        <name>warning C4007: &apos;function&apos; : must be &apos;attribute&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A required attribute for a function is not explicitly
      stated. For example, the function main must have the __cdecl
      attribute. The compiler forces the attribute.
    </description>
    </rule>
    <rule key="C4010">
        <name>warning C4010: single-line comment contains line-continuation character</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A single-line comment, which is introduced by //, contains a
      backslash (\) that serves as a line-continuation character. The
      compiler considers the next line to be a continuation and treats it as
      a comment.
    </description>
    </rule>
    <rule key="C4013">
        <name>warning C4013: &apos;function&apos; undefined; assuming extern returning int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler encountered a call to an undefined function.
    </description>
    </rule>
    <rule key="C4015">
        <name>warning C4015: &apos;identifier&apos; : type of bit field must be integral</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The bit field is not declared as an integer type. The compiler
      assumes the base type of the bit field to be unsigned. Bit fields must
      be declared as unsigned integer types.
    </description>
    </rule>
    <rule key="C4018">
        <name>warning C4018: &apos;expression&apos; : signed/unsigned mismatch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Comparing a signed and unsigned number required the compiler to
      convert the signed value to unsigned.
    </description>
    </rule>
    <rule key="C4020">
        <name>warning C4020: &apos;function&apos; : too many actual parameters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The number of actual parameters in a function call exceeds the
      number of formal parameters in the function prototype or
      definition. The compiler passes the extra actual parameters according
      to the calling convention of the function.
    </description>
    </rule>
    <rule key="C4022">
        <name>warning C4022: &apos;function&apos; : pointer mismatch for actual parameter &apos;number&apos;
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The pointer type of the actual parameter differs from the
      pointer type of the corresponding formal parameter. The actual
      parameter is passed without change.
    </description>
    </rule>
    <rule key="C4024">
        <name>warning C4024: &apos;function&apos; : different types for formal and actual parameter
    &apos;number&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Corresponding formal and actual parameters have different
      types. The compiler passes the actual parameter without change. The
      receiving function converts the parameter type to the type expected.
    </description>
    </rule>
    <rule key="C4028">
        <name>warning C4028: formal parameter &apos;number&apos; different from declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The type of the formal parameter does not agree with the
      corresponding parameter in the declaration. The type in the original
      declaration is used.
    </description>
    </rule>
    <rule key="C4029">
        <name>warning C4029: declared formal parameter list different from definition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Formal parameter types in the function declaration do not agree
      with those in the function definition. The compiler uses the parameter
      list from the definition.
    </description>
    </rule>
    <rule key="C4031">
        <name>warning C4031: second formal parameter list longer than the first list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function is redeclared with different formal parameters. The
      compiler uses the formal parameters given in the first declaration.
    </description>
    </rule>
    <rule key="C4032">
        <name>warning C4032: formal parameter &apos;number&apos; has different type when promoted
    </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The parameter type is not compatible, through default
      promotions, with the type in a previous declaration
    </description>
    </rule>
    <rule key="C4034">
        <name>warning C4034: sizeof returns 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The sizeof operator is applied to an operand of size zero
      (an empty structure, union, class, or enumerated type, or type void).
    </description>
    </rule>
    <rule key="C4042">
        <name>warning C4042: &apos;identifier&apos; : has bad storage class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified storage class cannot be used with this
      identifier in this context. The compiler uses the default storage
      class instead:
      - extern , if identifier is a function.
      - auto, if identifier is a formal parameter or local variable.
      - No storage class, if identifier is a global variable.
    </description>
    </rule>
    <rule key="C4047">
        <name>warning C4047: &apos;operator&apos; : &apos;identifier1&apos; differs in levels of indirection from
    &apos;identifier2&apos; </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A pointer can point to a variable (one level of
      indirection), to another pointer that points to a variable (two
      levels of indirection), and so on.
    </description>
    </rule>
    <rule key="C4048">
        <name>warning C4048: different declared array subscripts : &apos;identifier1&apos; and
    &apos;identifier2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An expression involves pointers to arrays of different
      size. The pointers are used without conversion.
    </description>
    </rule>
    <rule key="C4049">
        <name>warning C4049: compiler limit : terminating line number emission</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The file contains more than 16,777,215 source lines. The
      compiler stops numbering at 16,777,215.
      For code after line 16,777,215:
      - The image will contain no debug information for line numbers.
      - Some diagnostics may be reported with incorrect line numbers.
      - .asm listings (/FAs) may have incorrect line numbers.
      
    </description>
    </rule>
    <rule key="C4056">
        <name>warning C4056: overflow in floating point constant arithmetic</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Floating-point constant arithmetic generates a result
      that exceeds the maximum allowable value.
    </description>
    </rule>
    <rule key="C4061">
        <name>warning C4061: enumerator &apos;identifier&apos; in switch of enum &apos;enumeration&apos; is not
    explicitly handled by a case label</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The enumerate has no associated handler in a switch
      statement.
    </description>
    </rule>
    <rule key="C4062">
        <name>warning C4062: enumerator &apos;identifier&apos; in switch of enum &apos;enumeration&apos; is not
    handled</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The enumerate has no associated handler in a switch
      statement, and there is no default label.
    </description>
    </rule>
    <rule key="C4067">
        <name>warning C4067: unexpected tokens following preprocessor directive - expected a
    newline</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler found and ignored extra characters following
      a preprocessor directive. This warning appears only under ANSI
      compatibility (/Za).
    </description>
    </rule>
    <rule key="C4073">
        <name>warning C4073: initializers put in library initialization area</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Only third-party library developers should use the
      library initialization area, which is specified by &apos;#pragma
      init_seg&apos;.
    </description>
    </rule>
    <rule key="C4074">
        <name>warning C4074: initializers put in compiler reserved initialization area</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler initialization area, which is specified by
      &apos;#pragma init_seg&apos;, is reserved by Microsoft. Code in this area may
      be executed before initialization of the C run-time library.
    </description>
    </rule>
    <rule key="C4079">
        <name>warning C4079: unexpected token &apos;token&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An unexpected separator token occurs in a pragma argument
      list. The remainder of the pragma was ignored.
    </description>
    </rule>
    <rule key="C4083">
        <name>warning C4083: expected &apos;token&apos;; found identifier &apos;identifier&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An identifier occurs in the wrong place in a #pragma
      statement.
    </description>
    </rule>
    <rule key="C4088">
        <name>warning C4088: &apos;function&apos; : pointer mismatch in actual parameter &apos;number&apos;,
    formal parameter &apos;number&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The corresponding formal and actual parameters have a
      different level of indirection. The actual parameter is passed
      without change. The called function interprets its value as a
      pointer.
    </description>
    </rule>
    <rule key="C4089">
        <name>warning C4089: &apos;function&apos; : different types in actual parameter &apos;number&apos;,
    formal parameter &apos;number&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The corresponding formal and actual parameters have
      different types. The actual parameter is passed without change. The
      function casts the actual parameter to the type specified in the
      function definition.
    </description>
    </rule>
    <rule key="C4090">
        <name>warning C4090: &apos;operation&apos; : different &apos;modifier&apos; qualifiers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A variable used in an operation is defined with a
      specified modifier that prevents it from being modified without
      detection by the compiler. The expression is compiled without
      modification.
      This warning can be caused when a pointer to a const or volatile item is
      assigned to a pointer not declared as pointing to const or volatile.
    </description>
    </rule>
    <rule key="C4091">
        <name>warning C4091: &apos;keyword&apos; : ignored on left of &apos;type&apos; when no variable is
    declared</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected a situation where the user probably
      intended a variable to be declared, but the compiler was not able to
      declare the variable.
    </description>
    </rule>
    <rule key="C4092">
        <name>warning C4092: sizeof returns &apos;unsigned long&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The operand of the sizeof operator was very large, so
      sizeof returned an unsigned long. This warning occurs under the
      Microsoft extensions (/Ze). Under ANSI compatibility (/Za), the
      result is truncated instead.
    </description>
    </rule>
    <rule key="C4094">
        <name>warning C4094: untagged &apos;token&apos; declared no symbols</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an empty declaration using an
      untagged structure, union, or class. The declaration is ignored.
    </description>
    </rule>
    <rule key="C4096">
        <name>warning C4096: &apos;a&apos;: interface is not a COM interface; will not be emitted to
    IDL</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An interface definition that you may have intended as a
      COM interface was not defined as a COM interface and therefore will
      not be emitted to the IDL file.
    </description>
    </rule>
    <rule key="C4098">
        <name>warning C4098: &apos;function&apos; : void function returning a value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function declared with return type void has a return
      statement that returns a value. The compiler assumes the function
      returns a value of type int.
    </description>
    </rule>
    <rule key="C4099">
        <name>warning C4099: &apos;identifier&apos; : type name first seen using &apos;objecttype1&apos; now seen
    using &apos;objecttype2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An object declared as a structure is defined as a class,
      or an object declared as a class is defined as a structure. The
      compiler uses the type given in the definition.
    </description>
    </rule>
    <rule key="C4100">
        <name>warning C4100: &apos;identifier&apos; : unreferenced formal variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The formal parameter is not referenced in the body of the
      function. The unreferenced parameter is ignored.  C4100 can also be
      issued when code calls a destructor on a otherwise unreferenced
      parameter of primitive type. This is a limitation of the Visual C++
      compiler.
    </description>
    </rule>
    <rule key="C4101">
        <name>warning C4101: &apos;identifier&apos; : unreferenced local variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The local variable is never used.
    </description>
    </rule>
    <rule key="C4103">
        <name>warning C4103: &apos;filename&apos; : alignment changed after including header, may be due to missing #pragma pack(pop)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Packing affects the layout of classes, and commonly, if packing
      changes across header files, there can be problems. Use #pragma
      pack(pop) before exiting the header file to resolve this warning.
    </description>
    </rule>
    <rule key="C4114">
        <name>warning C4114: same type qualifier used more than once</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type declaration or definition uses a type qualifier (const,
      volatile, signed, or unsigned) more than once. This causes a warning
      with Microsoft extensions (/Ze) and an error under ANSI compatibility
      (/Za).
    </description>
    </rule>
    <rule key="C4116">
        <name>warning C4116: unnamed type definition in parentheses</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C4116: A structure, union, or enumerated type with no
      name is defined in a parenthetical expression. The type definition is
      meaningless.
    </description>
    </rule>
    <rule key="C4124">
        <name>warning C4124: __fastcall with stack checking is inefficient</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The __fastcall convention generates faster code, but stack
      checking causes slower code. When using __fastcall, turn off stack
      checking with the check_stack pragma or /Gs.
    </description>
    </rule>
    <rule key="C4129">
        <name>warning C4129: &apos;character&apos; : unrecognized character escape sequence</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The character following a backslash (\) in a character or string
      constant is not recognized as a valid escape sequence. The backslash
      is ignored and not printed. The character following the backslash is
      printed.  To print a single backslash, specify a double backslash
      (\\).
    </description>
    </rule>
    <rule key="C4133">
        <name>warning C4133: &apos;type&apos; : incompatible types - from &apos;type1&apos; to &apos;type2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning can be caused by trying to subtract two pointers of
      different types.  To avoid this warning, provide an appropriate type
      cast.
    </description>
    </rule>
    <rule key="C4142">
        <name>warning C4142: benign redefinition of type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type is redefined in a manner that has no effect on the
      generated code.  To fix by checking the following possible causes: - A
      member function of a derived class has a different return type from
      the corresponding member function of the base class.  - A type defined
      with the typedef command is redefined using different syntax.
    </description>
    </rule>
    <rule key="C4144">
        <name>warning C4144: &apos;expression&apos; : relational expression as switch expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified relational expression was used as the control
      expression of a switch statement. The associated case statements will
      be offered Boolean values.
    </description>
    </rule>
    <rule key="C4146">
        <name>warning C4146: unary minus operator applied to unsigned type, result still unsigned</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Unsigned types can hold only non-negative values, so unary minus
      (negation) does not usually make sense when applied to an unsigned
      type. Both the operand and the result are non-negative.  You can avoid
      C4146 by using INT_MIN from limits.h, which has the type signed int.
    </description>
    </rule>
    <rule key="C4150">
        <name>warning C4150: deletion of pointer to incomplete type &apos;type&apos;; no destructor called</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The delete operator is called to delete a type that was declared
      but not defined, so the compiler cannot find a destructor.
    </description>
    </rule>
    <rule key="C4154">
        <name>warning C4154: deletion of an array expression; conversion to pointer supplied</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You cannot use delete on an array, so the compiler converts the
      array to a pointer.
    </description>
    </rule>
    <rule key="C4156">
        <name>warning C4156: deletion of an array expression without using the array form of &apos;delete&apos;; array form substituted</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The non-array form of delete cannot delete an array. The
      compiler translated delete to the array form.  This warning occurs
      only under Microsoft extensions (/Ze).
    </description>
    </rule>
    <rule key="C4157">
        <name>warning C4157: pragma was ignored by C compiler</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Only the C++ compiler recognizes init_seg().
    </description>
    </rule>
    <rule key="C4159">
        <name>warning C4159: #pragma pragma(pop,...) : has popped previously pushed identifier &apos;identifier&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Your source code contains a push instruction with an identifier
      for a pragma followed by a pop instruction without an identifier. As a
      result, identifier is popped, and subsequent uses of identifier may
      cause unexpected behavior.
    </description>
    </rule>
    <rule key="C4162">
        <name>warning C4162: &apos;identifier&apos; : no function with C linkage found</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function with C linkage is declared but cannot be found. To
      resolve this warning, compile in a .c file (invoke the C compiler). If
      you must invoke the C++ compiler, place extern &quot;C&quot; before the function
      declaration.
    </description>
    </rule>
    <rule key="C4172">
        <name>warning C4172: returning address of local variable or temporary</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function returns the address of a local variable or temporary
      object. Local variables and temporary objects are destroyed when a
      function returns, so the address returned is not valid. Redesign the
      function so that it does not return the address of a local object.
    </description>
    </rule>
    <rule key="C4183">
        <name>warning C4183: &apos;identifier&apos;: missing return type; assumed to be a member function returning &apos;int&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The inline definition of a member function in a class or a
      structure does not have a return type. This member function is assumed
      to have a default return type of int.
    </description>
    </rule>
    <rule key="C4189">
        <name>warning C4189: &apos;identifier&apos; : local variable is initialized but not referenced</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A variable is declared and initialized but not used.
    </description>
    </rule>
    <rule key="C4190">
        <name>warning C4190: &apos;identifier1&apos; has C-linkage specified, but returns UDT &apos;identifier2&apos; which is incompatible with C</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function or pointer to function has a UDT (user-defined type,
      which is a class, structure, enum, union, or __value type) as return
      type and extern &quot;C&quot; linkage. This is legal if:
      - All calls to this function occur from C++.
      - The definition of the function is in C++.
    </description>
    </rule>
    <rule key="C4192">
        <name>warning C4192: automatically excluding &apos;name&apos; while importing type library &apos;library&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A #import library contains an item, name, that is also defined in the Win32 system headers. Due to limitations of type libraries, names such as IUnknown or GUID are often defined in a type library, duplicating the definition from the system headers. #import will detect these items and refuse to incorporate them in the .tlh and .tli header files.
      To override this behavior, use #import attributes no_auto_exclude and include().
    </description>
    </rule>
    <rule key="C4197">
        <name>warning C4197: &apos;type&apos; : top-level volatile in cast is ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected a cast to an r-value type which is qualified with volatile, or a cast of an r-value type to some type that is qualified with volatile. According to the C standard (6.5.3), properties associated with qualified types are meaningful only for l-value expressions.
    </description>
    </rule>
    <rule key="C4200">
        <name>warning C4200: nonstandard extension used : zero-sized array in struct/union</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A structure or union contains an array with zero size.
      Level-2 warning when compiling a C++ file and a Level-4 warning when compiling a C file.
    </description>
    </rule>
    <rule key="C4201">
        <name>warning C4201: nonstandard extension used : nameless struct/union</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Under Microsoft extensions (/Ze), you can specify a structure without a declarator as members of another structure or union. These structures generate an error under ANSI compatibility (/Za).
    </description>
    </rule>
    <rule key="C4202">
        <name>warning C4202: nonstandard extension used : &apos;...&apos;: prototype parameter in name list illegal</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An old-style function definition contains variable arguments. These definitions generate an error under ANSI compatibility (/Za).
    </description>
    </rule>
    <rule key="C4203">
        <name>warning C4203: nonstandard extension used : union with static member variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Static union members are valid using Microsoft extensions (/Ze). Such members are invalid in the ANSI standard (/Za). Conforming to the ANSI standard ensures more portable programs.
    </description>
    </rule>
    <rule key="C4204">
        <name>warning C4204: nonstandard extension used : non-constant aggregate initializer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With Microsoft extensions (/Ze), you can initialize aggregate types (arrays, structures, unions, and classes) with values that are not constants.
    </description>
    </rule>
    <rule key="C4205">
        <name>warning C4205: nonstandard extension used : static function declaration in function scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With Microsoft extensions (/Ze), static functions can be declared inside another function. The function is given global scope.
    </description>
    </rule>
    <rule key="C4206">
        <name>warning C4206: nonstandard extension used : translation unit is empty</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The file was empty after preprocessing.
      This extension can prevent your code from being portable to other compilers. It generates an error under ANSI compatibility (/Za) and only applies to C source code.
    </description>
    </rule>
    <rule key="C4207">
        <name>warning C4207: nonstandard extension used : extended initializer form</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With Microsoft extensions (/Ze), you can initialize an unsized array of char using a string within braces.
    </description>
    </rule>
    <rule key="C4208">
        <name>warning C4208: nonstandard extension used : delete [exp] - exp evaluated but ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With Microsoft extensions (/Ze), you can delete an array using a value within brackets with the delete operator. The value is ignored.
    </description>
    </rule>
    <rule key="C4210">
        <name>warning C4210: nonstandard extension used : function given file scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With the default Microsoft extensions (/Ze), function declarations have file scope.
    </description>
    </rule>
    <rule key="C4211">
        <name>warning C4211: nonstandard extension used : redefined extern to static</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With the default Microsoft extensions (/Ze), you can redefine an extern identifier as static.
    </description>
    </rule>
    <rule key="C4212">
        <name>warning C4212: nonstandard extension used : function declaration used ellipsis</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The function prototype has a variable number of arguments. The function definition does not.
    </description>
    </rule>
    <rule key="C4213">
        <name>warning C4213: nonstandard extension used : cast on l-value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With the default Microsoft extensions (/Ze), you can use casts on the left side of an assignment statement.
    </description>
    </rule>
    <rule key="C4214">
        <name>warning C4214: nonstandard extension used : bit field types other than int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With the default Microsoft extensions (/Ze), bitfield structure members can be of any integer type.
    </description>
    </rule>
    <rule key="C4215">
        <name>warning C4215: nonstandard extension used : long float</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The default Microsoft extensions (/Ze) treat long float as double. ANSI compatibility (/Za) does not. Use double to maintain compatibility.
    </description>
    </rule>
    <rule key="C4216">
        <name>warning C4216: nonstandard extension used : float long</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The default Microsoft extensions (/Ze) treat float long as double. ANSI compatibility (/Za) does not. Use double to maintain compatibility.
    </description>
    </rule>
    <rule key="C4218">
        <name>warning C4218: nonstandard extension used : must specify at least a storage class or a type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With the default Microsoft extensions (/Ze), you can declare a variable without specifying a type or storage class. The default type is int.
    </description>
    </rule>
    <rule key="C4220">
        <name>warning C4220: varargs matches remaining parameters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Under the default Microsoft extensions (/Ze), a pointer to a function matches a pointer to a function with similar, but variable, arguments
    </description>
    </rule>
    <rule key="C4221">
        <name>warning C4221: nonstandard extension used : &apos;identifier&apos; : cannot be initialized using address of automatic variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      With the default Microsoft extensions (/Ze), you can initialize an aggregate type (array, struct, or union) with the address of a local (automatic) variable.
    </description>
    </rule>
    <rule key="C4223">
        <name>warning C4223: nonstandard extension used : non-lvalue array converted to pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      In standard C, you cannot convert a non-lvalue array to a pointer. With the default Microsoft extensions (/Ze), you can.
    </description>
    </rule>
    <rule key="C4224">
        <name>warning C4224: nonstandard extension used : formal parameter &apos;identifier&apos; was previously defined as a type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The identifier was previously used as a typedef. This causes a warning under ANSI compatibility (/Za).
    </description>
    </rule>
    <rule key="C4226">
        <name>warning C4226: nonstandard extension used : &apos;keyword&apos; is an obsolete keyword</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The current version of Visual C++ does not use this keyword.
    </description>
    </rule>
    <rule key="C4227">
        <name>warning C4227: anachronism used : qualifiers on reference are ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Using qualifiers like const or volatile with C++ references is an outdated practice.
    </description>
    </rule>
    <rule key="C4228">
        <name>warning C4228: nonstandard extension used : qualifiers after comma in declarator list are ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Use of qualifiers like const or volatile after a comma when declaring variables is a Microsoft extension (/Ze).
    </description>
    </rule>
    <rule key="C4229">
        <name>warning C4229: anachronism used : modifiers on data are ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Using a Microsoft modifier such as __cdecl on a data declaration is an outdated practice.
    </description>
    </rule>
    <rule key="C4230">
        <name>warning C4230: anachronism used : modifiers/qualifiers interspersed; qualifier ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Using a qualifier before a Microsoft modifier such as __cdecl is an outdated practice.
    </description>
    </rule>
    <rule key="C4231">
        <name>warning C4231: nonstandard extension used : &apos;identifier&apos; before template explicit instantiation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When Microsoft extensions are enabled (/Ze), an extern template can be instantiated, generating this warning. Under ANSI compatibility (/Za), such instantiations cause an error.
    </description>
    </rule>
    <rule key="C4232">
        <name>warning C4232: nonstandard extension used : &apos;identifier&apos; : address of dllimport &apos;dllimport&apos; is not static, identity not guaranteed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Under Microsoft extensions (/Ze), you can give a nonstatic value as the address of a function declared with the dllimport modifier. Under ANSI compatibility (/Za), this causes an error.
    </description>
    </rule>
    <rule key="C4233">
        <name>warning C4233: nonstandard extension used : &apos;keyword&apos; keyword only supported in C++, not C</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler compiled your source code as C rather than C++, and you used a keyword that is only valid in C++. The compiler compiles your source file as C if the extension of the source file is .c or you use /Tc.
    </description>
    </rule>
    <rule key="C4234">
        <name>warning C4234: nonstandard extension used: &apos;keyword&apos; keyword reserved for future use</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler does not yet implement the keyword you used.
      This warning is automatically promoted to an error. If you wish to modify this behavior, use #pragma warning.
    </description>
    </rule>
    <rule key="C4235">
        <name>warning C4235: nonstandard extension used : &apos;keyword&apos; keyword not supported on this architecture</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler does not support the keyword you used.
      For example, the _asm keyword is not supported for the Itanium Processor Family (IPF) compiler. All assembly code must be written in a separate file or should be used through an intrinsic. See Intrinsics Available on Intel 64-bit Platforms for more information.
      This warning is automatically promoted to an error. If you wish to modify this behavior, use #pragma warning.
    </description>
    </rule>
    <rule key="C4237">
        <name>warning C4237: &apos;keyword&apos; keyword is not yet supported, but reserved for future use</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A keyword in the C++ specification is not implemented in the Visual C++ compiler, but the keyword is not available as a user-defined symbol.
    </description>
    </rule>
    <rule key="C4238">
        <name>warning C4238: nonstandard extension used : class rvalue used as lvalue</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      For compatibility with previous versions of Visual C++, Microsoft extensions (/Ze) allow you to use a class type as an rvalue in a context that implicitly or explicitly takes its address. In some cases, such as the example below, this can be dangerous.
    </description>
    </rule>
    <rule key="C4239">
        <name>warning C4239: nonstandard extension used : &apos;token&apos; : conversion from &apos;type&apos; to &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This type conversion is not allowed by the C++ standard, but it is permitted here as an extension. This warning is always followed by at least one line of explanation describing the language rule being violated.
    </description>
    </rule>
    <rule key="C4240">
        <name>warning C4240: nonstandard extension used : access to &apos;classname&apos; now defined to be &apos;access specifier&apos;, previously it was defined to be &apos;access specifier&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Under ANSI compatibility (/Za), you cannot change the access to a nested class. Under the default Microsoft extensions (/Ze), you can, with this warning.
    </description>
    </rule>
    <rule key="C4242">
        <name>warning C4242: &apos;identifier&apos; : conversion from &apos;type1&apos; to &apos;type2&apos;, possible loss of data</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The types are different. Type conversion may result in loss of data. The compiler makes the type conversion.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
      For additional information on C4242, see Common Compiler Errors.
    </description>
    </rule>
    <rule key="C4243">
        <name>warning C4243: &apos;conversion type&apos; conversion exists from &apos;type1&apos; to &apos;type2&apos;, but is inaccessible</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A pointer to a derived class is converted to a pointer to a base class, but the derived class inherits the base class with private or protected access.
    </description>
    </rule>
    <rule key="C4244">
        <name>warning C4244: &apos;argument&apos; : conversion from &apos;type1&apos; to &apos;type2&apos;, possible loss of data</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      (/W2)A floating point type was converted to an integer type. A possible loss of data may have occurred.
      If you get C4244, you should either change your program to use compatible types, or add some logic to your code, to ensure that the range of possible values will always be compatible with the types you are using.
      (/W3, /W4) An integer type is converted to a smaller integer type. This is a level-4 warning if type1 is int and type2 is smaller than int. Otherwise, it is a level 3 (assigned a value of type __int64 to a variable of type unsigned int). A possible loss of data may have occurred.
      If you get C4244, you should either change your program to use compatible types, or add some logic to your code, to ensure that the range of possible values will always be compatible with the types you are using.
    </description>
    </rule>
    <rule key="C4245">
        <name>warning C4245: &apos;conversion&apos; : conversion from &apos;type1&apos; to &apos;type2&apos;, signed/unsigned mismatch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You tried to convert a signed const that has a negative value to an unsigned.
    </description>
    </rule>
    <rule key="C4250">
        <name>warning C4250: &apos;class1&apos; : inherits &apos;class2::member&apos; via dominance</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Two or more members have the same name. The one in class2 is inherited because it is a base class for the other classes that contained this member.
      To suppress C4250, use the warning pragma.
      Because a virtual base class is shared among multiple derived classes, a name in a derived class dominates a name in a base class. For example, given the following class hierarchy, there are two definitions of func inherited within diamond: the vbc::func() instance through the weak class, and the dominant::func() through the dominant class. An unqualified call of func() through a diamond class object, always calls the dominate::func() instance. If the weak class were to introduce an instance of func(), neither definition would dominate, and the call would be flagged as ambiguous.
    </description>
    </rule>
    <rule key="C4251">
        <name>warning C4251: &apos;identifier&apos; : class &apos;type&apos; needs to have dll-interface to be used by clients of class &apos;type2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      To minimize the possibility of data corruption when exporting a class with __declspec(dllexport), ensure that:
      - All your static data is access through functions that are exported from the DLL.
      - No inlined methods of your class can modify static data.
      - No inlined methods of your class use CRT functions or other library functions use static data (see Potential Errors Passing CRT Objects Across DLL Boundaries for more information).
      - No methods of your class (regardless of inlining) can use types where the instantiation in the EXE and DLL have static data differences.
      You can avoid exporting classes by defining a DLL that defines a class with virtual functions, and functions you can call to instantiate and delete objects of the type. You can then just call virtual functions on the type.
      C4251 can be ignored if you are deriving from a type in the Standard C++ Library, compiling a debug release (/MTd) and where the compiler error message refers to _Container_base.
    </description>
    </rule>
    <rule key="C4254">
        <name>warning C4254: &apos;operator&apos; : conversion from &apos;type1&apos; to &apos;type2&apos;, possible loss of data</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A larger bit field was assigned to a smaller bit field. There could be a loss of data.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4255">
        <name>warning C4255: &apos;function&apos; : no function prototype given: converting &apos;()&apos; to &apos;(void)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler did not find an explicit list of arguments to a function. This warning is for the C compiler only.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4256">
        <name>warning C4256: &apos;function&apos; : constructor for class with virtual bases has &apos;...&apos;; calls may not be compatible with older versions of Visual C++</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Possible incompatibility.
      Consider the following code example. If the definition of the constructor S2::S2( int i, ... ) was compiled by using a version of the Visual C++ compiler before version 7, but the following example is compiled by using the current version, the call to the constructor for S3 would not work correctly because of a special-case calling-convention change. If both were compiled by using Visual C++ 6.0, the call would not work quite right either, unless no parameters were passed for the ellipsis.
      To fix this warning,
      - Don&apos;t use ellipsis in a constructor.
      - Make sure that all components in their project are built with the current version (including any libraries that may define or reference this class), then disable the warning using the warning pragma.
    </description>
    </rule>
    <rule key="C4258">
        <name>warning C4258: &apos;variable&apos; : definition from the for loop is ignored; the definition from the enclosing scope is used&quot;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Under /Ze and /Zc:forScope, variables defined in a for loop go out of scope after the for loop ends. This warning occurs if a variable with the same name as the loop variable, but defined in the enclosing loop, is used again in the scope containing the for loop.
    </description>
    </rule>
    <rule key="C4263">
        <name>warning C4263: &apos;function&apos; : member function does not override any base class virtual member function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A class function definition has the same name as a virtual function in a base class but not the same number or type of arguments. This effectively hides the virtual function in the base class.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4264">
        <name>warning C4264: &apos;virtual_function&apos; : no override available for virtual member function from base &apos;class&apos;; function is hidden</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4264 is always generated after C4263.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4265">
        <name>warning C4265: &apos;class&apos; : class has virtual functions, but destructor is not virtual</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When a class has virtual functions but a nonvirtual destructor, objects of the type might not be destroyed properly when the class is destroyed through a base class pointer.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4266">
        <name>warning C4266: &apos;function&apos; : no override available for virtual member function from base &apos;type&apos;; function is hidden</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A derived class did not override all overloads of a virtual function.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4267">
        <name>warning C4267: &apos;var&apos; : conversion from &apos;size_t&apos; to &apos;type&apos;, possible loss of data</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When compiling with /Wp64, or when compiling on a 64-bit operating system, type is 32 bits but size_t is 64 bits when compiling for 64-bit targets.
      To fix this warning, use size_tinstead of a type.
    </description>
    </rule>
    <rule key="C4268">
        <name>warning C4268: &apos;identifier&apos; : &apos;const&apos; static/global data initialized with compiler generated default constructor fills the object with zeros</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A const global or static instance of a non-trivial class is initialized with a compiler-generated default constructor.
    </description>
    </rule>
    <rule key="C4269">
        <name>warning C4269: &apos;identifier&apos; : &apos;const&apos; automatic data initialized with compiler generated default constructor produces unreliable results</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A const automatic instance of a non-trivial class is initialized with a compiler-generated default constructor.
    </description>
    </rule>
    <rule key="C4272">
        <name>warning C4272: &apos;function&apos; : is marked __declspec(dllimport); must specify native calling convention when importing a function.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      It is an error to export a function marked with the __clrcall calling convention, and the compiler issues this warning if you attempt to import a function marked __clrcall.
    </description>
    </rule>
    <rule key="C4273">
        <name>warning C4273: &apos;function&apos; : inconsistent DLL linkage</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Two definitions in a file differ in their use of dllimport.
    </description>
    </rule>
    <rule key="C4275">
        <name>warning C4275: non &#8211; DLL-interface classkey &apos;identifier&apos; used as base for DLL-interface classkey &apos;identifier&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An exported class was derived from a class that was not exported.
      To minimize the possibility of data corruption when exporting a class with __declspec(dllexport), ensure that:
      - All your static data is accessed through functions that are exported from the DLL.
      - No inlined methods of your class can modify static data.
      - No inlined methods of your class use CRT functions or other library functions use static data.
      - No inlined class functions use CRT functions, or other library functions, where, for example, you access static data.
      - No methods of your class (regardless of inlining) can use types where the instantiation in the EXE and DLL have static data differences.
      You can avoid exporting classes by defining a DLL that defines a class with virtual functions, and functions you can call to instantiate and delete objects of the type. You can then just call virtual functions on the type.
      C4275 can be ignored in Visual C++ if you are deriving from a type in the Standard C++ Library, compiling a debug release (/MTd) and where the compiler error message refers to _Container_base.
    </description>
    </rule>
    <rule key="C4276">
        <name>warning C4276: &apos;function&apos; : no prototype provided; assumed no parameters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When you take the address of a function with the __stdcall calling convention, you must give a prototype so the compiler can create the function&apos;s decorated name. Since function has no prototype, the compiler, when creating the decorated name, assumes the function has no parameters.
    </description>
    </rule>
    <rule key="C4278">
        <name>warning C4278: &apos;identifier&apos;: identifier in type library &apos;tlb&apos; is already a macro; use the &apos;rename&apos; qualifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When using #import, an identifier in the typelib you are importing is attempting to declare an identifier identifier. However, this is already a valid symbol.
      Use the #import rename attribute to assign an alias to the symbol in the type library.
    </description>
    </rule>
    <rule key="C4280">
        <name>warning C4280: &apos;operator &#8211;&gt;&apos; was self recursive through type &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Your code incorrectly allows operator&#8211;&gt; to call itself.
    </description>
    </rule>
    <rule key="C4281">
        <name>warning C4281: &apos;operator &#8211;&gt;&apos; recursion occurred through type &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Your code allows operator&#8211;&gt; to call itself.
    </description>
    </rule>
    <rule key="C4282">
        <name>warning C4282: then through type &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This continuation of warning C4281shows that operator&#8211;&gt; calls itself through type.
    </description>
    </rule>
    <rule key="C4283">
        <name>warning C4283: and through type &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This continuation of warning C4281 shows that operator&#8211;&gt; calls itself through type.
    </description>
    </rule>
    <rule key="C4285">
        <name>warning C4285: return type for &apos;identifier::operator &#8211;&gt;&apos; is recursive if applied using infix notation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified operator&#8211;&gt;() function cannot return the type for which it is defined or a reference to the type for which it is defined.
    </description>
    </rule>
    <rule key="C4286">
        <name>warning C4286: &apos;type1&apos; : is caught by base class (&apos;type2&apos;) on line number</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified exception type is handled by a previous handler. The type for the second catch is derived from the type of the first. Exceptions for a base class catch exceptions for a derived class.
    </description>
    </rule>
    <rule key="C4287">
        <name>warning C4287: &apos;operator&apos; : unsigned/negative constant mismatch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An unsigned variable was used in an operation with a negative number.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4288">
        <name>warning C4288: nonstandard extension used : &apos;var&apos; : loop control variable declared in the for-loop is used outside the for-loop scope; it conflicts with the declaration in the outer scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When compiling with /Ze and /Zc:forscope-, a variable declared in a for loop was used after the for-loop scope. A Microsoft extension to the C++ language allows this variable to remain in scope, and C4288 reminds you that the first declaration of the variable is not used.
      See /Zc:forScope for information about how to specify the Microsoft extension in for loops with /Ze.
    </description>
    </rule>
    <rule key="C4289">
        <name>warning C4289: nonstandard extension used : &apos;var&apos; : loop control variable declared in the for-loop is used outside the for-loop scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When compiling with /Ze and /Zc:forScope-, a variable declared in a for loop was used after the for-loop scope.
      See /Zc:forScope for information about how to specify standard behavior in for loops with /Ze.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4290">
        <name>warning C4290: C++ exception specification ignored except to indicate a function is not __declspec(nothrow)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function is declared using exception specification, which Visual C++ accepts but does not implement. Code with exception specifications that are ignored during compilation may need to be recompiled and linked to be reused in future versions supporting exception specifications.
      For more information, see Exception Specifications .
    </description>
    </rule>
    <rule key="C4291">
        <name>warning C4291: &apos;declaration&apos; : no matching operator delete found; memory will not be freed if initialization throws an exception</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A placement new is used for which there is no placement delete.
      When memory is allocated for an object with operator new, the object&apos;s constructor is called. If the constructor throws an exception, any memory that was allocated for the object should be deallocated. This cannot take place unless an operator delete function exists that matches the operator new.
      If you use the operator new without any extra arguments and compile with /GX, /EHs, or /EHa options to enable exception handling, the compiler will generate code to call operator delete if the constructor throws an exception.
      If you use the placement form of the new operator (the form with arguments in addition to the size of the allocation) and the object&apos;s constructor throws an exception, the compiler will still generate code to call operator delete; but it will only do so if a placement form of operator delete exists matching the placement form of the operator new that allocated the memory.
    </description>
    </rule>
    <rule key="C4293">
        <name>warning C4293: &apos;operator&apos; : shift count negative or too big, undefined behavior</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If a shift count is negative or too large, the behavior of the resulting image is undefined.
    </description>
    </rule>
    <rule key="C4295">
        <name>warning C4295: &apos; array &apos; : array is too small to include a terminating null character</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An array was initialized but the last character in the array is not a null; accessing the array may produce unexpected results.
    </description>
    </rule>
    <rule key="C4296">
        <name>warning C4296: &apos;operator&apos; : expression is always false</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An unsigned variable was used in a comparison operation with zero.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4297">
        <name>warning C4297: &apos;function&apos; : function assumed not to throw an exception but does</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function contains a nothrow declaration and one or more throw statements. To resolve C4297, do not attempt to throw exceptions in functions that are declared with nothrow or to remove the nothrow specification.
      For more information on exception specifications, see Exception Specifications. Also, see /EH (Exception Handling Model) for information on how to modify exception handling behavior at compile time.
      This warning is also generated for __declspec(dllexport) functions marked extern &quot;C&quot;, even if they are C++ functions.
    </description>
    </rule>
    <rule key="C4302">
        <name>warning C4302: &apos;conversion&apos; : truncation from &apos;type 1&apos; to &apos;type 2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected a conversion from a larger type to a smaller type. Information may be lost.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4303">
        <name>warning C4303: &apos;cast&apos; from &apos;type1&apos; to &apos;type2&apos; is deprecated, use static_cast, __try_cast or dynamic_cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C-style type casting or function-style casting is not supported when using Managed Extensions for C++. To cast, use either dynamic_cast Operator or static_cast Operator.
      C4303 is not reachable using /clr and the new syntax; see C-Style Casts with /clr for more information.
    </description>
    </rule>
    <rule key="C4305">
        <name>warning C4305: &apos;identifier&apos; : truncation from &apos;type1&apos; to &apos;type2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If you used the ATL Connection Point Wizard, see Knowledge Base article:
      Q250847 : ATL Connection Point Wizard Generated Code for Event with VARIANT Argument Gives C4305 Warning
    </description>
    </rule>
    <rule key="C4306">
        <name>warning C4306: &apos;identifier&apos; : conversion from &apos;type1&apos; to &apos;type2&apos; of greater size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The identifier is type cast to a larger pointer. The unfilled high bits of the new type will be zero-filled.
      This warning may indicate an unwanted conversion. The resulting pointer may not be valid.
    </description>
    </rule>
    <rule key="C4307">
        <name>warning C4307: &apos;operator&apos; : integral constant overflow</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The operator is used in an expression that results in an integer constant overflowing the space allocated for it. You may need to use a larger type for the constant. A signed int holds a smaller value than an unsigned int because the signed int uses one bit to represent the sign.
    </description>
    </rule>
    <rule key="C4308">
        <name>warning C4308: negative integral constant converted to unsigned type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An expression converts a negative integer constant to an unsigned type. The result of the expression is probably meaningless.
    </description>
    </rule>
    <rule key="C4309">
        <name>warning C4309: &apos;conversion&apos; : truncation of constant value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The type conversion causes a constant to exceed the space allocated for it. You may need to use a larger type for the constant.
    </description>
    </rule>
    <rule key="C4310">
        <name>warning C4310: cast truncates constant value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A constant value is cast to a smaller type. The compiler performs the cast, which truncates data.
    </description>
    </rule>
    <rule key="C4311">
        <name>warning C4311: &apos;variable&apos; : pointer truncation from &apos;type&apos; to &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning detects 64-bit portability issues. For example, if code is compiled on a 64-bit platform, the value of a pointer (64 bits) will be truncated if it is assigned to an int (32 bits).
      This warning is only issued when /Wp64 is used. See /Wp64 for more information. Also, see Rules for Using Pointers.
      For additional information on C4311, see Common Compiler Errors.
    </description>
    </rule>
    <rule key="C4312">
        <name>warning C4312: &apos;operation&apos; : conversion from &apos;type1&apos; to &apos;type2&apos; of greater size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning detects 64-bit portability issues. You attempted to assign a 32-bit value to a 64-bit type. For example, casting a 32-bit int or 32-bit long to a 64-bit pointer.
      This can be an unsafe conversion in some circumstances when sign extension occurs. If a negative number is assigned to a pointer type of a size greater than the int, sign extension will occur and the pointer value will refer to a memory address different from the value of the int.
      This warning is only issued when /Wp64 is used. See /Wp64 for more information. Also, see Rules for Using Pointers.
    </description>
    </rule>
    <rule key="C4313">
        <name>warning C4313: &apos;function&apos; : &apos;format specifier&apos; in format string conflicts with argument %d of type &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      There is a conflict between the format specified and the value that you are passing. For example, you passed a 32-bit pointer to %d format specifier, which can hold a 64-bit integer. This warning is only in effect with /Wp64.
    </description>
    </rule>
    <rule key="C4318">
        <name>warning C4318: passing constant zero as the length to memset</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You called the C run-time library&apos;s memset function with a zero character length. For example, memset(p,size,0). Instead, specify memset(p,0,size).
    </description>
    </rule>
    <rule key="C4319">
        <name>warning C4319: &apos;operator&apos; : zero extending &apos;type&apos; to &apos;type&apos; of greater size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The result of the ~ operator is unsigned and then converted to a larger type.
      In the following example, ~(a - 1) is evaluated as a 32-bit unsigned long expression and then converted to 64 bits by zero extension. This leads to pointer truncations.
    </description>
    </rule>
    <rule key="C4324">
        <name>warning C4324: &apos;struct_name&apos; : structure was padded due to __declspec(align())</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Padding was added at the end of a structure because you specified a __declspec(align) value.
    </description>
    </rule>
    <rule key="C4325">
        <name>warning C4325: attributes for standard section &apos; section &apos; ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You may not change the attributes of a standard section.
      This would overwrite the .sdata standard section which uses the short data type with the long data type.
      Standard sections whose attributes you may not change include,
      .data
      .sdata
      .bss
      .sbss
      .text
      .const
      .sconst
      .rdata
      .srdata
    </description>
    </rule>
    <rule key="C4326">
        <name>warning C4326: return type of &apos;function&apos; should be &apos;type1&apos; instead of &apos;type2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function returned a type other than type1. For example, using /Za, main did not return an int.
    </description>
    </rule>
    <rule key="C4329">
        <name>warning C4329: __declspec(align()) is ignored on enum</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Use of the align keyword of the __declspec modifier is not allowed on an enum
    </description>
    </rule>
    <rule key="C4333">
        <name>warning C4333: &apos;operator&apos; : right shift by too large amount, data loss</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A right shift operation was too large an amount. All significant bits are shifted out and the result will always be zero.
    </description>
    </rule>
    <rule key="C4334">
        <name>warning C4334: &apos;operator&apos; : result of 32-bit shift implicitly converted to 64 bits (was 64-bit shift intended?)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The result of 32-bit shift was implicitly converted to 64-bits, and the compiler suspects that a 64-bit shift was intended. To resolve this warning, either use 64-bit shift, or explicitly cast the shift result to 64-bit.
    </description>
    </rule>
    <rule key="C4335">
        <name>warning C4335: Mac file format detected: please convert the source file to either DOS or UNIX format</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The line termination character of the first line of a source file is Macintosh style (&#8216;\r&#8217;) as opposed to UNIX (&#8216;\n&#8217;) or DOS (&#8216;\r\n&#8217;).
      This warning is always issued as an errror. See warning pragma for information about how to disable this warning. Also, this warning is only issued once per compiland. Therefore, if there are multiple #include directives that specify files in Macintosh format, C4335 will only be issued once.
      One way to generate files in Macintosh format is by using the Advanced Save Options (on the File menu) in Visual Studio.
    </description>
    </rule>
    <rule key="C4336">
        <name>warning C4336: import cross-referenced type library &apos;type_lib1&apos; before importing &apos;type_lib2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type library was referenced with the #import directive. However, the type library contained a reference to another type library that was not referenced with #import. This other .tlb file was found by the compiler.
    </description>
    </rule>
    <rule key="C4337">
        <name>warning C4337: cross-referenced type library &apos;typelib1&apos; in &apos;typelib2&apos; is being automatically imported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The auto_search attribute of the #import directive caused a type library to be implicitly imported.
    </description>
    </rule>
    <rule key="C4339">
        <name>warning C4339: &apos;type&apos; : use of undefined type detected in CLR meta-data - use of this type may lead to a runtime exception</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type was not defined in code that was compiled for the common language runtime. Define the type to avoid a possible runtime exception.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4340">
        <name>warning C4340: &apos;value&apos; : value wrapped from positive to negative value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The enum value is greater than the largest enum positive value wrapped around to a negative value.
    </description>
    </rule>
    <rule key="C4341">
        <name>warning C4341: &apos;value&apos; : signed value is out of range for enum constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An enumerated constant exceeds the limit for an int. The value of the invalid constant is undefined. Constants must resolve to integers between &#8211;4,294,967,295 and +4,294,967,295 (signed).
      Note that this is a level 3 warning under /Ze and a level 1 warning under /Za.
    </description>
    </rule>
    <rule key="C4342">
        <name>warning C4342: behavior change: &apos;function&apos; called, but a member operator was called in previous versions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      In previous versions of Visual C++, a member was called, but this behavior has been changed and the compiler will find the best match in namespace scope.
      If a member operator was found, the compiler would previously not consider any namespace scope operators. If there is a better match at namespace scope, the current compiler will correctly call it, whereas previous compilers wouldn&apos;t consider it.
      This warning should be disabled after you successfully port your code to the current version. The compiler may give false positives, generating this warning for code where there is no behavior change.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4343">
        <name>warning C4343: #pragma optimize(&quot;g&quot;,off) overrides /Og option</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning, only valid in the Itanium Processor Family (IPF) compiler, reports that a pragma optimize overrode a /Og compiler option.
    </description>
    </rule>
    <rule key="C4344">
        <name>warning C4344: behavior change: use of explicit template arguments results in call to &apos;function&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A call to a function using explicit template arguments calls a different function than it would if explicit arguments had not been specified
    </description>
    </rule>
    <rule key="C4345">
        <name>warning C4345: behavior change: an object of POD type constructed with an initializer of the form () will be default-initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning reports a behavior change from the Visual C++ compiler that shipped in Visual Studio .NET when initializing a POD (plain old data) object with (); the compiler will default-initialize the object.
    </description>
    </rule>
    <rule key="C4346">
        <name>warning C4346: &apos;name&apos; : dependent name is not a type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The typename keyword is required if a dependent name is to be treated as a type. This is a breaking change in the Visual C++ .NET 2003 compiler, made in order to conform to the ISO C++ standard.
      For code that works the same in all versions of Visual C++, add typename to the declaration.
    </description>
    </rule>
    <rule key="C4347">
        <name>warning C4347: behavior change: &apos;function template&apos; is called instead of &apos;function&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      In Visual Studio .NET, if you had a template function and a nontemplate function with the same name as the template function, the compiler incorrectly treated the nontemplate function as a specialization of the template function.
      For code that works the same in all versions of Visual C++, add template&lt;&gt; above the nontemplate function, making it a real explicit specialization.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4348">
        <name>warning C4348: &apos;type&apos; : redefinition of default parameter : parameter number</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A template parameter was redefined.
    </description>
    </rule>
    <rule key="C4350">
        <name>warning C4350: behavior change: &apos;member1&apos; called instead of &apos;member2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An rvalue cannot be bound to a non-const reference. In previous versions of Visual C++, it was possible to bind an rvalue to a non-const reference in a direct initialization. This code now gives a warning.
      For backward compatibility, it is still possible to bind rvalues to non-const references, but standard conversions are preferred wherever possible.
      This warning represents a change of behavior from the Visual C++ .NET 2002 compiler. If enabled, this warning could possibly be given for correct code. For example, it could be given when using the std::auto_ptr class template.
      If you get this warning, examine your code to see if it depends on binding rvalues to non-const references. Adding a const to the reference or providing a additional const-reference overload may solve the problem.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default. 
    </description>
    </rule>
    <rule key="C4351">
        <name>warning C4351: new behavior: elements of array &apos;array&apos; will be default initialized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When an array is in a constructor&apos;s member initialization list, the elements of the array will be default initialized. In previous versions of Visual C++, when an array was in a constructor&apos;s member initialization list, the elements of the array may not have been default initialized in some cases.
      If the array&apos;s element type does not have a constructor, the elements of the array will be initialized with the corresponding zero representation for that type.
      C4351 means that you should inspect your code. If you want the compiler&apos;s previous behavior, remove the array from the constructor&apos;s member initialization list.
      If you want the new behavior, which is likely, because the array was explicitly added to the constructor&apos;s member initialization list, use the warning pragma to disable the warning. The new behavior should be fine for most users.
      One situation where the new behavior can result in unexpected behavior is when placement new is used to construct the object that has the array as a member, and the program depends on the contents that the memory (for the elements of the default initialized array) had before the call to placement new. In this case, the older compiler would have left the contents of memory unchanged, but the new behavior will cause default initialization of the array elements, overwriting the original contents in memory.
    </description>
    </rule>
    <rule key="C4353">
        <name>warning C4353: nonstandard extension used: constant 0 as function expression. Use &apos;__noop&apos; function intrinsic instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You cannot use the constant zero (0) as a function expression. For more information, see __noop.
    </description>
    </rule>
    <rule key="C4355">
        <name>warning C4355: &apos;this&apos; : used in base member initializer list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The this pointer is valid only within nonstatic member functions. It cannot be used in the initializer list for a base class.
      The base-class constructors and class member constructors are called before this constructor. In effect, you&apos;ve passed a pointer to an unconstructed object to another constructor. If those other constructors access any members or call member functions on this, the result will be undefined. You should not use the this pointer until all construction has completed.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4356">
        <name>warning C4356: &apos;member&apos; : static data member cannot be initialized via derived class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The initialization of a static data member was ill formed. The compiler accepted the initialization.
      This is a breaking change in the Visual C++ .NET 2003 compiler.
      For code that works the same in all versions of Visual C++, initialize the member through the base class.
      Use the warning pragma to suppress this warning.
    </description>
    </rule>
    <rule key="C4357">
        <name>warning C4357: param array argument in formal argument list for delegate &apos;del&apos; ignored when generating &apos;function&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The ParamArray attribute was ignored, and functioncannot be called with variable arguments.
    </description>
    </rule>
    <rule key="C4358">
        <name>warning C4358: &apos;operator&apos;: return type of combined delegates is not &apos;void&apos;; returned value is undefined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Two delegates were combined and the return value is not void. If two delegates with non-void return values are combined, the compiler will not be able to do a proper assignment if the return value of the delegate is used.
    </description>
    </rule>
    <rule key="C4359">
        <name>warning C4359: &apos;type&apos;: actual alignment (8) is greater than the value specified in __declspec(align())</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The alignment specified for a type is less than the alignment of the type of one of its data members. For more information, see align (C++).
    </description>
    </rule>
    <rule key="C4364">
        <name>warning C4364: #using for assembly &apos;file&apos; previously seen at location(line_number) without as_friend attribute; as_friend not applied</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A #using directive was repeated for a given metadata file, but the as_friend qualifier was not used in the first occurrence; the compiler will ignore the second as_friend.
    </description>
    </rule>
    <rule key="C4365">
        <name>warning C4365: &apos;action&apos; : conversion from &apos;type_1&apos; to &apos;type_2&apos;, signed/unsigned mismatch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      For example, you tried to convert an unsigned value to a signed value.
      C4365 is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4366">
        <name>warning C4366: The result of the unary &apos;operator&apos; operator may be unaligned</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If a structure member could ever be unaligned because of packing, the compiler will warn when that member&apos;s address is assigned to an aligned pointer. By default, all pointers are aligned.
      To resolve C4366, either change the alignment of the structure or declare the pointer with the __unaligned keyword.
    </description>
    </rule>
    <rule key="C4368">
        <name>warning C4368: cannot define &apos;member&apos; as a member of managed &apos;type&apos;: mixed types are not supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You can, however, declare a pointer to a native type and control its lifetime in the constructor and destructor and finalizer of your managed class (see Destructors and Finalizers in Visual C++ for more information).
      This warning is always issued as an error. Use the warning pragma to disable C4368.
    </description>
    </rule>
    <rule key="C4369">
        <name>warning C4369: &apos;enumerator&apos; : enumerator value &apos;value&apos; cannot be represented as &apos;type&apos;, value is &apos;new_value&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An enumerator was calculated to be greater than the greatest value for the specified underlying type. This caused an overflow and the compiler wrapped the enumerator value to the lowest possible value for the type.
    </description>
    </rule>
    <rule key="C4374">
        <name>warning C4374: &apos;function1&apos;: interface method will not be implemented by non-virtual method &apos;function2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler expected to find the virtual keyword on a method definition.
    </description>
    </rule>
    <rule key="C4375">
        <name>warning C4375: non-public method &apos;method2&apos; does not override &apos;method1&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type that implements another type defined an override method, but the override was not public. Therefore, the method does not override the base type method.
    </description>
    </rule>
    <rule key="C4376">
        <name>warning C4376: access specifier &apos;old_specifier:&apos; is no longer supported: please use &apos;new_specifier:&apos; instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      For more information on specifying type and member accessibility in metadata, see Type and Member Visibility.
    </description>
    </rule>
    <rule key="C4377">
        <name>warning C4377: native types are private by default; -d1PrivateNativeTypes is deprecated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      In previous releases, native types in assemblies were public by default, and an internal, undocumented compiler option (/d1PrivateNativeTypes) was used to make them private.
      All types, native and CLR, are now private by default in an assembly, so /d1PrivateNativeTypes is no longer needed.
    </description>
    </rule>
    <rule key="C4378">
        <name>warning C4378: Must obtain function pointers to run initializers; consider System::ModuleHandle::ResolveMethodHandle</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Under /clr, initializer symbols contain function tokens, not functions pointers. You need to convert tokens to pointers using ResolveMethodHandle.
    </description>
    </rule>
    <rule key="C4379">
        <name>warning C4379: Version version of the common language runtime is not supported by this compiler. Using this version may cause unexpected results.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You have a previous version of the common language runtime on your machine, but not the current version. To resolve C4379, install the version of the common language runtime that shipped with your compiler.
    </description>
    </rule>
    <rule key="C4381">
        <name>warning C4381: &apos;function1&apos;: interface method will not be implemented by non-public method &apos;function2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A class must implement all function in an interface. A class can satisfy this condition if one of its base classes implements the function. However, the function must be implemented as a public function.
    </description>
    </rule>
    <rule key="C4382">
        <name>warning C4382: throwing &apos;type&apos; : a type with __clrcall destructor or copy constructor can only be caught in /clr:pure module</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When compiled with /clr (not /clr:pure), exception handling expects the member functions in a native type to be __cdecl and not __clrcall. Native types with member functions using __clrcall calling convention cannot be caught in a module compiled with /clr.
      If the exception will be caught in a module compiled with /clr:pure, you can ignore this warning.
      for more information, see /clr (Common Language Runtime Compilation).
    </description>
    </rule>
    <rule key="C4383">
        <name>warning C4383: &apos;instance_dereference_operator&apos; : meaning of dereferencing a handle can change, when a user-defined &apos;operator&apos; exists; write  operator as a static function to be explicit about operand</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C4383: &apos;instance_dereference_operator&apos; : the meaning of dereferencing a handle can change, when a user-defined &apos;operator&apos; exists; write the operator as a static function to be explicit about the operand
      When you add a user-defined instance override of the dereference operator in a managed type, you potentially override the ability of the type&apos;s dereference operator to return the handle&apos;s object. Consider writing a static, user-defined dereference operator.
      For more information, see Handle to Object Operator (^) and Tracking Reference Operator.
      Also, an instance operator is not available to other language compilers via referenced metadata. For more information, see User-Defined Operators.
    </description>
    </rule>
    <rule key="C4384">
        <name>warning C4384: #pragma &apos;make_public&apos; should only be used at global scope</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The make_public pragma was applied incorrectly.
    </description>
    </rule>
    <rule key="C4389">
        <name>warning C4389: &apos;operator&apos; : signed/unsigned mismatch</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An operation involved signed and unsigned variables. This could result in a loss of data.
    </description>
    </rule>
    <rule key="C4390">
        <name>warning C4390: &apos;;&apos; : empty controlled statement found; is this the intent?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A semicolon was found after a control statement that contains no instructions.
      If you get C4390 because of a macro, you should use the warning pragma to disable C4390 in the module containing the macro.
    </description>
    </rule>
    <rule key="C4391">
        <name>warning C4391: &apos;signature&apos; : incorrect return type for intrinsic function, expected &apos;type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function declaration for a compiler intrinsic had the wrong return type. The resulting image may not run correctly.
      To fix this warning, either correct the declaration or delete the declaration and simply #include the appropriate header file.
    </description>
    </rule>
    <rule key="C4392">
        <name>warning C4392: &apos;signature&apos; : incorrect number of arguments for intrinsic function, expected &apos;number&apos; arguments</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function declaration for a compiler intrinsic had the wrong number of arguments. The resulting image may not run correctly.
      To fix this warning, either correct the declaration or delete the declaration and simply #include the appropriate header file.
    </description>
    </rule>
    <rule key="C4393">
        <name>warning C4393: &apos;var&apos; : const has no effect on literal data member; ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A literal data member was also specified as const. Since a literal data member implies const, you do not need to add const to the declaration.
    </description>
    </rule>
    <rule key="C4394">
        <name>warning C4394: &apos;function&apos; : per-appdomain symbol should not be marked with __declspec(dllexport)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function marked with the appdomain __declspec modifier is compiled to MSIL (not to native), and export tables (export __declspec modifier) are not supported for managed functions.
      You can declare a managed function to have public accessibility, see Type and Member Visibility for more information.
      C4394 is always issued as an error. You can turn off this warning with the #pragma warning or /wd; see warning or /w, /Wn, /WX, /Wall, /wln, /wdn, /wen, /won (Warning Level) for more information.
    </description>
    </rule>
    <rule key="C4395">
        <name>warning C4395: &apos;function&apos; : member function will be invoked on a copy of the initonly data member &apos;member&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A member function was called on an initonly data member. C4395 warns that the initonly data member cannot be modified by the function.
    </description>
    </rule>
    <rule key="C4397">
        <name>warning C4397: DefaultCharSetAttribute is ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      DefaultCharSetAttribute is ignored by the Visual C++ compiler. To specify a character set for the DLL, use the CharSet option of DllImport. For more information, see Using C++ Interop (Implicit PInvoke).
    </description>
    </rule>
    <rule key="C4398">
        <name>warning C4398: &apos;variable&apos; : per-process global object might not work correctly with multiple appdomains; consider using __declspec(appdomain)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A virtual function with __clrcall calling convention in a native type causes the creation of a per application domain vtable. Such a variable may not correct correctly when used in multiple application domains.
      You can resolve this warning by compiling with /clr:pure, which makes global variables per appdomain by default, or by explicitly marking the variable __declspec(appdomain).
      For more information, see appdomain and Application Domains and Visual C++.
    </description>
    </rule>
    <rule key="C4399">
        <name>warning C4399: &apos;symbol&apos; : per-process symbol should not be marked with __declspec(dllimport) when compiled with /clr:pure</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Data from a native image or an image with native and CLR constructs can not be imported into a pure image. To resolve this warning, compile with /clr (not /clr:pure) or delete __declspec(dllimport).
    </description>
    </rule>
    <rule key="C4400">
        <name>warning C4400: &apos;type&apos; : const/volatile qualifiers on this type are not supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The const (C++)and volatile (C++)qualifiers will not work with variables of common language runtime types.
    </description>
    </rule>
    <rule key="C4401">
        <name>warning C4401: &apos;bitfield&apos; : member is bit field</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Inline assembly code tries to access a bit-field member. Inline assembly cannot access bit-field members, so the last packing boundary before the bit-field member is used.
      To avoid this warning, cast the bit field to an appropriate type before making the reference in inline assembly code.
    </description>
    </rule>
    <rule key="C4402">
        <name>warning C4402: must use PTR operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type is used on an operand without a PTR operator when referring to or casting to a type in inline assembly code.
      The compiler assumes the PTR operator.
    </description>
    </rule>
    <rule key="C4403">
        <name>warning C4403: illegal PTR operator</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A PTR operator is used inappropriately in inline assembler code.
      The compiler ignored the PTR operator.
    </description>
    </rule>
    <rule key="C4404">
        <name>warning C4404: period on directive ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The optional period preceding the directive is ignored.
    </description>
    </rule>
    <rule key="C4405">
        <name>warning C4405: &apos;identifier&apos; : identifier is reserved word</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A word reserved for inline assembly is used as a variable name. This may cause unpredictable results. To fix this warning, avoid naming variables with words reserved for inline assembly.
    </description>
    </rule>
    <rule key="C4406">
        <name>warning C4406: operand on directive ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The directive does not take any operands, but an operand was specified.
      The compiler ignored the given operand or operands.
    </description>
    </rule>
    <rule key="C4407">
        <name>warning C4407: cast between different pointer to member representations, compiler may generate incorrect code</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An incorrect cast was detected.
      C4407 can be generated because of compiler conformance work that was done in Visual C++ 2005. Pointer-to-member now requires a qualified name and the address-of operator (&amp;).
      C4407 can occur if you cast between a multiple inheritance pointer-to-member to a single inheritance pointer-to-member. Sometimes this can work, but sometimes it can&#8217;t because the single inheritance pointer-to-member representation doesn&#8217;t hold sufficient information. Compiling with the /vmm might help (for more information, see /vmm, /vms, /vmv (General Purpose Representation)). You can also try rearranging your base classes; the compiler is detecting a loss of information in the conversion because a base class is at a non-zero offset from the derived.
    </description>
    </rule>
    <rule key="C4408">
        <name>warning C4408: anonymous union did not declare any data members</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An anonymous union must have at least one data member.
    </description>
    </rule>
    <rule key="C4409">
        <name>warning C4409: illegal instruction size</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The instruction did not have a form with the specified size. The smallest legal size was used.
    </description>
    </rule>
    <rule key="C4410">
        <name>warning C4410: illegal size for operand</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      One of the operands on the instruction had an incorrect size. The smallest legal size for the operand was used.
    </description>
    </rule>
    <rule key="C4411">
        <name>warning C4411: &apos;identifier&apos; : symbol resolves to displacement register</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The identifier is a local symbol that resolves to a displacement register and therefore may be used on an operand with another symbol.
    </description>
    </rule>
    <rule key="C4412">
        <name>warning C4412: &apos;function&apos; : function signature contains type &apos;type&apos;; C++ objects are unsafe to pass between pure code and mixed or native.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected a potentially unsafe situation that could result in a runtime error: a call is being made from a /clr:pure compiland to a function that was imported via dllimport and the function signature contains an unsafe type. A type is unsafe if it contains a member function or has a data member that is an unsafe type or an indirection to an unsafe type.
      This is unsafe because of the difference in the default calling conventions between pure and native code (or mixed native and managed). When importing (via dllimport) a function into a /clr:pure compiland, ensure that the declarations of each type in the signature are identical to those in the compiland that exports the function (being especially careful about differences in implicit calling conventions).
      A virtual member function is especially prone to give unexpected results. However, even a non-virtual function should be tested to ensure that you get the correct results. If you are sure that you are getting the correct results, you can ignore this warning.
      For more information on /clr:pure, see How to: Migrate to /clr:pure (C++/CLI).
      C4412 is off by default. See Compiler Warnings That Are Off by Default and dllexport, dllimport for more information.
      To resolve this warning, remove all functions from the type.
    </description>
    </rule>
    <rule key="C4414">
        <name>warning C4414: &apos;function&apos; : short jump to function converted to near</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Short jumps generate compact instruction which branches to an address within a limited range from the instruction. The instruction includes a short offset that represents the distance between the jump and the target address, the function definition. During linking a function may be moved or subject to link-time optimizations that cause the function to be moved out of the range reachable from a short offset. The compiler must generate a special record for the jump, which requires the jmp instruction to be either NEAR or FAR. The compiler made the conversion.
    </description>
    </rule>
    <rule key="C4420">
        <name>warning C4420: &apos;operator&apos; : operator not available, using &apos;operator&apos; instead; run-time checking may be compromised</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is generated when you use the /RTCv (vector new/delete checking) and when no vector form is found. In this case, the non-vector form is used.
      In order for /RTCv to work correctly, the compiler should always call the vector form of new/delete if the vector syntax was used.
    </description>
    </rule>
    <rule key="C4428">
        <name>warning C4428: universal-character-name encountered in source</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler issues C4428 when it detects at least one universal character name in a source code file. To fix this warning, use the Unicode equivalent of the universal character name.
      This warning is only issued once per compiland.
    </description>
    </rule>
    <rule key="C4429">
        <name>warning C4429: possible incomplete or improperly formed universal-character-name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected a character sequence that may be a badly formed universal character name. A universal character name is \u followed by four hex digits, or \U followed by eight hex digits.
    </description>
    </rule>
    <rule key="C4430">
        <name>warning C4430: missing type specifier - int assumed. Note: C++ does not support default-int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This error can be generated as a result of compiler conformance work that was done for Visual C++ 2005: all declarations must explicitly specify the type; int is no longer assumed.
      C4430 is always issued as an error. You can turn off this warning with the #pragma warning or /wd; see warning or /w, /Wn, /WX, /Wall, /wln, /wdn, /wen, /won (Warning Level) for more information.
    </description>
    </rule>
    <rule key="C4431">
        <name>warning C4431: missing type specifier - int assumed. Note: C no longer supports default-int</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This error can be generated as a result of compiler conformance work that was done for Visual C++ 2005: Visual C++ no longer creates untyped identifiers as int by default. The type of an identifier must be specified explicitly.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4432">
        <name>warning C4432: a destructor in a ref-class must have public accessibility; changing to public access</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler made a destructor public. To resolve this warning, explicitly put the destructor in a public section of the class.
      For more information, see Destructors and Finalizers in Visual C++.
    </description>
    </rule>
    <rule key="C4433">
        <name>warning C4433: a finalizer must have protected accessibility; changing to protected access</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4433 indicates that the compiler changed the accessibility of a finalizer. Finalizers must have protected accessibility. For more information, see Destructors and Finalizers in Visual C++.
    </description>
    </rule>
    <rule key="C4434">
        <name>warning C4434: a class constructor must have private accessibility; changing to private access</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4434 indicates that the compiler changed the accessibility of a static constructor. Static constructors must have private accessibility, as they are only meant to be called by the common language runtime. For more information, see How to: Define Static Constructors in a Class or Struct.
    </description>
    </rule>
    <rule key="C4435">
        <name>warning C4435: &apos;class1&apos; : Object layout under /vd2 will change due to virtual base &apos;class2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
      Under the default compile option of /vd1, the derived class does not have a vtordisp field for the indicated virtual base. If /vd2 or #pragma vtordisp(2) is in effect, a vtordisp field will be present, changing the object layout. This can lead to binary compatibility problems if interacting modules are compiled with different vtordisp settings.
    </description>
    </rule>
    <rule key="C4436">
        <name>warning C4436: dynamic_cast from virtual base &apos;class1&apos; to &apos;class2&apos; in constructor/destructor could fail with partially-constructed object Compile with /vd2 or define &apos;class2&apos; with #pragma vtordisp(2)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C4436: dynamic_cast from virtual base &apos;class1&apos; to &apos;class2&apos; in constructor or destructor could fail with partially-constructed object Compile with /vd2 or define &apos;class2&apos; with #pragma vtordisp(2) in effect
      The compiler has encountered a dynamic_cast operation with the following characteristics.
      - The cast is from a base class pointer to a derived class pointer.
      - The derived class virtually inherits the base class.
      - The derived class does not have a vtordisp field for the virtual base.
      - The cast is found in a constructor or destructor of the derived class, or some class which further inherits from the derived class.
      The warning indicates the dynamic_cast might not perform correctly, if it is operating on a partially-constructed object. That happens if the derived constructor/destructor is operating on a sub-object of some further derived object. If the derived class named in the warning is never further derived, the warning can be ignored.
    </description>
    </rule>
    <rule key="C4437">
        <name>warning C4437: dynamic_cast from virtual base &apos;class1&apos; to &apos;class2&apos; could fail in some contexts Compile with /vd2 or define &apos;class2&apos; with #pragma vtordisp(2) in effect</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
      The compiler has encountered a dynamic_cast operation with the following characteristics.
      - The cast is from a base class pointer to a derived class pointer.
      - The derived class virtually inherits the base class.
      - The derived class does not have a vtordisp field for the virtual base.
      - The cast is not found in a constructor or destructor of the derived class, or some class which further inherits from the derived class (otherwise, compiler warning C4436 will be issued).
      The warning indicates that the dynamic_cast might not perform correctly if it is operating on a partially-constructed object. This situation occurs when the enclosing function is called from a constructor or destructor of a class that inherits the derived class that is named in the warning. If the derived class that is named in the warning is never further derived, or the enclosing function is not called during object construction or destruction, the warning can be ignored.
    </description>
    </rule>
    <rule key="C4439">
        <name>warning C4439: &apos;function&apos; : function definition with a managed type in the signature must have a __clrcall calling convention</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler implicitly replaced a calling convention with __clrcall. To resolve this warning, remove the __cdecl or __stdcall calling convention.
      C4439 is always issued as an error. You can turn off this warning with the #pragma warning or /wd; see warning or /w, /Wn, /WX, /Wall, /wln, /wdn, /wen, /won (Warning Level) for more information.
    </description>
    </rule>
    <rule key="C4440">
        <name>warning C4440: calling convention redefinition from &apos;calling_convention1&apos; to &apos;calling_convention2&apos; ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An attempt to change the calling convention was ignored.
    </description>
    </rule>
    <rule key="C4441">
        <name>warning C4441: calling convention of &apos;cc1&apos; ignored; &apos;cc2&apos; used instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Member functions in managed user-defined types and global function generics must use the __clrcall calling convention. The compiler used __clrcall.
    </description>
    </rule>
    <rule key="C4445">
        <name>warning C4445: &apos;function&apos; : in a managed type a virtual method cannot be private</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If a virtual function is private, it cannot be accessed by a derived type.
    </description>
    </rule>
    <rule key="C4460">
        <name>warning C4460: CLR operator &apos;operator&apos;, has parameter passed by reference. CLR operator &apos;operator&apos; has different semantics from C++ operator &apos;operator&apos;, did you intend to pass by value?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You passed a value by reference to a user-defined CLR operator. If the value is changed inside the function, note that the value returned after the function call will be assigned the return value of the function. In standard C++, the changed value is reflected after the function call.
    </description>
    </rule>
    <rule key="C4461">
        <name>warning C4461: &apos;type&apos; : this class has a finalizer &apos;finalizer&apos; but no destructor &apos;dtor&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The presence of a finalizer in a type implies resources to delete. Unless a finalizer is explicitly called from the type&apos;s destructor, the common language runtime determines when to run the finalizer, after your object goes out of scope.
      If you define a destructor in the type and explicitly call the finalizer from the destructor, you can deterministically run your finalizer.
      For more information, see Destructors and Finalizers in Visual C++.
    </description>
    </rule>
    <rule key="C4470">
        <name>warning C4470: floating-point control pragmas ignored under /clr</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The float-control pragmas:
      - fenv_access
      - float_control
      - fp_contract
      have no effect under /clr.
    </description>
    </rule>
    <rule key="C4480">
        <name>warning C4480: nonstandard extension used: specifying underlying type for enum &apos;enum&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An extension to the language under /clr was used without /clr. You can disable C4480 with the warning pragma.
      For more information, see /clr (Common Language Runtime Compilation), /Za, /Ze (Disable Language Extensions), enum class, and C++ Enumeration Declarations.
    </description>
    </rule>
    <rule key="C4481">
        <name>warning C4481: nonstandard extension used: override specifier &apos;keyword&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A keyword was used that is not in the C++ standard, for example, one of the override specifiers that also works under /clr. For more information, see,
      - /clr (Common Language Runtime Compilation)
      - Override Specifiers
    </description>
    </rule>
    <rule key="C4482">
        <name>warning C4482: nonstandard extension used: enum &apos;enum&apos; used in qualified name</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When you refer to an enum inside a type, you do not need to specify the name of the enum.
      For more information on CLR enums, see enum class. For more information about native enums, see C++ Enumeration Declarations.
    </description>
    </rule>
    <rule key="C4484">
        <name>warning C4484: &apos;override_function&apos; : matches base ref class method &apos;base_class_function&apos;, but is not marked &apos;virtual&apos;, &apos;new&apos; or &apos;override&apos;; &apos;new&apos; (and not &apos;virtual&apos;) is assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When compiling with /clr, the compiler will not implicitly override a base class function, which means the function will get a new slot in the vtable. To resolve, explicitly specify whether a function is an override.
      For more information, see:
      - /clr (Common Language Runtime Compilation)
      - override
      - new (new slot in vtable)
      C4484 is always issued as an error. Use the warning pragma to suppress C4484.
    </description>
    </rule>
    <rule key="C4485">
        <name>warning C4485: &apos;override_function&apos; : matches base ref class method &apos;base_class_function &apos;, but is not marked &apos;new&apos; or &apos;override&apos;; &apos;new&apos; (and &apos;virtual&apos;) is assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An accessor overrides, with or without the virtual keyword, a base class accessor function, but the override or new specifier was not part of the overriding function signature. Add the new or override specifier to resolve this warning.
      See override and new (new slot in vtable) for more information.
      C4485 is always issued as an error. Use the warning pragma to suppress C4485.
    </description>
    </rule>
    <rule key="C4486">
        <name>warning C4486: &apos;function&apos; : a private virtual method of a ref class or value class should be marked &apos;sealed&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Since a private virtual member function of a managed class or struct cannot be accessed or overridden, it should be marked sealed.
    </description>
    </rule>
    <rule key="C4487">
        <name>warning C4487: &apos;derived_class_function&apos; : matches inherited non-virtual method &apos;base_class_function&apos; but is not explicitly marked &apos;new&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function in a derived class has the same signature as a non-virtual base class function. C4487 reminds you that the derived class function does not override the base class function. Explicitly mark the derived class function as new to resolve this warning.
    </description>
    </rule>
    <rule key="C4488">
        <name>warning C4488: &apos;function&apos; : requires &apos;keyword&apos; keyword to implement the interface method &apos;interface_method&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A class must implement all members of an interface from which it directly inherits. An implemented member must have public accessibility, and must be marked virtual.
    </description>
    </rule>
    <rule key="C4489">
        <name>warning C4489: &apos;specifier&apos; : not allowed on interface method &apos;method&apos;; override specifiers are only allowed on ref class and value class methods</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A specifier keyword was incorrectly used on an interface method.
      For more information, see Override Specifiers.
    </description>
    </rule>
    <rule key="C4490">
        <name>warning C4490: &apos;override&apos; : incorrect use of override specifier; &apos;function&apos; does not match a base ref class method</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An override specifier was used incorrectly. For example, you do not override an interface function, you implement it.
      For more information, see Override Specifiers.
    </description>
    </rule>
    <rule key="C4502">
        <name>warning C4502: &apos;linkage specification&apos; requires use of keyword &apos;extern&apos; and must precede all other specifiers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A linkage was specified without the extern keyword. Linkage is not relevant to non-extern types.
      The compiler assumed the extern keyword.
    </description>
    </rule>
    <rule key="C4503">
        <name>warning C4503: &apos;identifier&apos; : decorated name length exceeded, name was truncated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The decorated name was longer than the compiler limit (4096), and was truncated. To avoid this warning and the truncation, reduce the number of arguments or name length of identifiers used.
      One situation where this warning will be issued is when your code contains templates specialized on templates repeatedly. For example, a map of maps (from the Standard C++ Library). In this situation, you can make your typedefs a type (struct, for example) that contains the map.
      You might, however, decide to not restructure your code. It is possible to ship an application that generates C4503, but if you get link time errors on a truncated symbol, it will be more difficult to determine the type of the symbol in the error. Debugging will also be more difficult; the debugger will also have difficultly mapping symbol name to type name. The correctness of the program, however, is unaffected by the truncated name.
    </description>
    </rule>
    <rule key="C4505">
        <name>warning C4505: &apos;function&apos; : unreferenced local function has been removed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The given function is local and not referenced in the body of the module; therefore, the function is dead code.
      The compiler did not generate code for this dead function.
    </description>
    </rule>
    <rule key="C4506">
        <name>warning C4506: no definition for inline function &apos;function&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The given function was declared and marked for inlining but was not defined.
      The compiler did not inline the function.
      Make sure that external functions to be inlined are declared with the extern keyword.
    </description>
    </rule>
    <rule key="C4508">
        <name>warning C4508: &apos;function&apos; : function should return a value; &apos;void&apos; return type assumed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The function has no return type specified. In this case, C4430 should also fire and the compiler implements the fix reported by C4430 (default value is int).
      To resolve this warning, explicitly declare the return type of functions. 
    </description>
    </rule>
    <rule key="C4509">
        <name>warning C4509: nonstandard extension used: &apos;function&apos; uses SEH and &apos;object&apos; has destructor</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You should not use structured exception handling in functions that use objects with destructors. If an exception occurs, the destructor cannot be called. Use C++ exception handling instead.
    </description>
    </rule>
    <rule key="C4510">
        <name>warning C4510: &apos;class&apos; : default constructor could not be generated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler cannot generate a default constructor for the specified class and no user-defined constructor was created. You will not be able to create objects of this type.
      There are several situations that prevent the compiler from generating a default constructor, including:
      - A const data member.
      - A data member that is a reference.
      You need to create a user-defined default constructor for the class that initializes these members.
    </description>
    </rule>
    <rule key="C4511">
        <name>warning C4511: &apos;class&apos; : copy constructor could not be generated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler could not generate a default copy-constructor for a class; a base class may have a private copy-constructor.
    </description>
    </rule>
    <rule key="C4512">
        <name>warning C4512: &apos;class&apos; : assignment operator could not be generated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler cannot generate an assignment operator for the given class. No assignment operator was created.
      An assignment operator for the base class that is not accessible by the derived class can cause this warning.
      To avoid this warning, specify a user-defined assignment operator for the class.
      The compiler will also generate an assignment operator function for a class that does not define one. This assignment operator is a memberwise copy of the data members of an object. Because const data items cannot be modified after initialization, if the class contains a const item, the default assignment operator would not work. Another cause of the C4512 warning is a declaration of a nonstatic data member of reference type.
      You can resolve the C4512 warning for your code in one of three ways:
      - Explicitly define an assignment operator for the class.
      - Remove const or the reference operator from the data item in the class.
      - Use the #pragma warning statement to suppress the warning.
    </description>
    </rule>
    <rule key="C4513">
        <name>warning C4513: &apos;class&apos; : destructor could not be generated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler cannot generate a default destructor for the given class; no destructor was created. The destructor is in a base class that is not accessible to the derived class. If the base class has a private destructor, make it public or protected.
    </description>
    </rule>
    <rule key="C4514">
        <name>warning C4514: &apos;function&apos; : unreferenced inline function has been removedy</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The optimizer removed an inline function that is not called.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4515">
        <name>warning C4515: &apos;namespace&apos; : namespace uses itself</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A namespace is used recursively.
    </description>
    </rule>
    <rule key="C4516">
        <name>warning C4516: &apos;class::symbol&apos; : access-declarations are deprecated; member using-declarations provide a better alternative</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The ANSI C++ committee has declared access declarations (changing the access of a member in a derived class without the using keyword) to be outdated. Access declarations may not be supported by future versions of C++.
    </description>
    </rule>
    <rule key="C4517">
        <name>warning C4517: access-declarations are deprecated; member using-declarations provide a better alternative</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The ANSI C++ committee has declared access declarations (changing the access of a member in a derived class without the using keyword) to be outdated. Access declarations may not be supported by future versions of C++.
    </description>
    </rule>
    <rule key="C4518">
        <name>warning C4518: &apos;specifier&apos; : storage-class or type specifier(s) unexpected here; ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      &apos;specifier&apos; : storage-class or type specifier(s) unexpected here; ignored
    </description>
    </rule>
    <rule key="C4519">
        <name>warning C4519: default template arguments are only allowed on a class template</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Default template arguments are allowed only on a class template declaration or definition. Default template arguments may not be used in a function template, or in the definition of a member of a class template.
    </description>
    </rule>
    <rule key="C4520">
        <name>warning C4520: &apos;class&apos; : multiple default constructors specified</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The class has multiple default constructors. The first constructor is used.
    </description>
    </rule>
    <rule key="C4521">
        <name>warning C4521: &apos;class&apos; : multiple copy constructors specified</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The class has multiple copy constructors of a single type. This warning is informational; the constructors are callable in your program.
      Use the warning pragma to suppress this warning.
    </description>
    </rule>
    <rule key="C4522">
        <name>warning C4522: &apos;class&apos; : multiple assignment operators specified</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The class has multiple assignment operators of a single type. This warning is informational; the constructors are callable in your program.
      Use the warning pragma to suppress this warning.
    </description>
    </rule>
    <rule key="C4523">
        <name>warning C4523: &apos;class&apos; : multiple destructors specified</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The class has multiple destructors. 
    </description>
    </rule>
    <rule key="C4526">
        <name>warning C4526: &apos;function&apos; : static member function cannot override virtual function &apos;virtual function&apos;override ignored, virtual function will be hidden</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The static member function meets the criteria to override the virtual function, which makes the member function both virtual and static.
      The following are possible fixes:
      - If the function was intended to override the base class virtual function, remove the static specifier.
      - If the function was intended to be a static member function, rename it so it doesn&apos;t conflict with the base class virtual function.
    </description>
    </rule>
    <rule key="C4530">
        <name>warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When the /EHsc option has not been enabled, an object with automatic storage in the frame, between the function doing the throw and the function catching the throw, will not be destroyed. However, an object with automatic storage created in a try or catch block will be destroyed.
    </description>
    </rule>
    <rule key="C4532">
        <name>warning C4532: &apos;continue&apos; : jump out of __finally/finally block has undefined behavior during termination handling</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler encountered one of the following keywords:
      - continue
      - break
      - goto
      causing a jump out of a __finally or finally block during abnormal termination.
      If an exception occurs, and while the stack is being unwound during execution of the termination handlers (the __finally or finally blocks), and your code jumps out of a __finally block before the __finally block ends, the behavior is undefined. Control may not return to the unwinding code, so the exception may not be handled properly.
      If you must jump out of a __finally block, check for abnormal termination first.
      The following sample generates C4532; simply comment out the jump statements to resolve the warnings.
    </description>
    </rule>
    <rule key="C4533">
        <name>warning C4533: initialization of &apos;variable&apos; is skipped by &apos;instruction&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An instruction in your program changed the flow of control, such that, an instruction that initialized a variable was not executed.
    </description>
    </rule>
    <rule key="C4534">
        <name>warning C4534: &apos;constructor&apos; will not be a default constructor for class &apos;class&apos; due to the default argument</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An unmanaged class can have a constructor with parameters that have default values and the compiler will use this as the default constructor. A class marked with the value keyword will not use a constructor with default values for its parameters as a default constructor.
      For more information, see Classes and Structs (Platform).
    </description>
    </rule>
    <rule key="C4535">
        <name>warning C4535: calling _set_se_translator() requires /EHa</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The use of _set_se_translator requires the /EHa compiler option and not /EHs.
    </description>
    </rule>
    <rule key="C4536">
        <name>warning C4536: &apos;type name&apos; : type-name exceeds meta-data limit of &apos;limit&apos; characters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type name would be truncated in metadata if it was a managed type. See C3180 for more information.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4537">
        <name>warning C4537: &apos;object&apos; : &apos;operator&apos; applied to non-UDT type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A reference was passed where an object (user-defined type) was expected. A reference is not an object, but inline assembler code is not able to make the distinction. The compiler generates code as though object were an instance.
    </description>
    </rule>
    <rule key="C4538">
        <name>warning C4538: &apos;type&apos; : const/volatile qualifiers on this type are not supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A qualifier keyword was applied to an array incorrectly. For more information, see array.
    </description>
    </rule>
    <rule key="C4539">
        <name>warning C4539: &apos;char&apos;: a universal-character-name specifies an invalid character</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A character was specified out of Unicode range.
      The character must be in the Unicode range, or be a valid surropate pair.
    </description>
    </rule>
    <rule key="C4540">
        <name>warning C4540: dynamic_cast used to convert to inaccessible or ambiguous base; run-time test will fail (&apos;type1&apos; to &apos;type2&apos;)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You used dynamic_cast to convert from one type to another. The compiler determined that the cast would always fail (return NULL) because a base class is inaccessible (private, for instance) or ambiguous (appears more than once in the class hierarchy, for instance).
      The following shows an example of this warning. Class B is derived from class A. The program uses dynamic_cast to cast from class B (the derived class) to class A, which will always fail because class B is private and thus inaccessible. Changing the access of A to public will resolve the warning.
    </description>
    </rule>
    <rule key="C4541">
        <name>warning C4541: &apos;identifier&apos; used on polymorphic type &apos;type&apos; with /GR-; unpredictable behavior may result</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You tried to use a feature that requires run-time type information without enabling run-time type information. Recompile with /GR.
    </description>
    </rule>
    <rule key="C4543">
        <name>warning C4543: Injected text suppressed by attribute &apos;no_injected_text&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The no_injected_text attribute appeared in source code, which means the compiler will prevent attributes from injecting code.
      This warning is to remind you that attributes will not be able to inject code.
    </description>
    </rule>
    <rule key="C4544">
        <name>warning C4544: Default arguments on template declaration ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A default template argument was specified in an incorrect location and was ignored. A default template argument for a class template can only be specified in the declaration or definition of the class template and not on a member of the class template.
    </description>
    </rule>
    <rule key="C4545">
        <name>warning C4545: expression before comma evaluates to a function which is missing an argument list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an ill-formed comma expression.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4546">
        <name>warning C4546: function call before comma missing argument list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an ill-formed comma expression.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4547">
        <name>warning C4547: &apos;operator&apos; : operator before comma has no effect; expected operator with side-effect</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an ill-formed comma expression.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4548">
        <name>warning C4548: expression before comma has no effect; expected expression with side-effect</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an ill-formed comma expression.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4549">
        <name>warning C4549: &apos;operator&apos; : operator before comma has no effect; did you intend &apos;operator&apos;?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an ill-formed comma expression.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4550">
        <name>warning C4550: expression evaluates to a function which is missing an argument list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A dereferenced pointer to a function is missing an argument list.
    </description>
    </rule>
    <rule key="C4551">
        <name>warning C4551: function call missing argument list</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function call must include the open and close parentheses after the function name even if the function takes no parameters.
    </description>
    </rule>
    <rule key="C4552">
        <name>warning C4552: &apos;operator&apos; : operator has no effect; expected operator with side-effect</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If an expression statement has an operator with no side effect as the top of the expression, it&apos;s probably a mistake.
      To override this warning, put the expression in parentheses.
    </description>
    </rule>
    <rule key="C4553">
        <name>warning C4553: &apos;operator&apos; : operator has no effect; did you intend &apos;operator&apos;?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If an expression statement has an operator with no side effect as the top of the expression, it&apos;s probably a mistake.
    </description>
    </rule>
    <rule key="C4554">
        <name>warning C4554: &apos;operator&apos; : check operator precedence for possible error; use parentheses to clarify precedence</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      &apos;operator&apos; : check operator precedence for possible error; use parentheses to clarify precedence
    </description>
    </rule>
    <rule key="C4555">
        <name>warning C4555: expression has no effect; expected expression with side-effect</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning informs you when an expression has no effect.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4556">
        <name>warning C4556: value of intrinsic immediate argument &apos;value&apos; is out of range &apos;lowerbound - upperbound&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An intrinsic matches a hardware instruction. The hardware instruction has a fixed number of bits to encode the constant. If value is out of range, it will not encode properly. The compiler truncates the extra bits.
    </description>
    </rule>
    <rule key="C4557">
        <name>warning C4557: &apos;__assume&apos; contains effect &apos;effect&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The value passed to an __assume statement2 was modified.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4558">
        <name>warning C4558: value of operand &apos;value&apos; is out of range &apos;lowerbound - upperbound&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The value passed to an assembly language instruction is out of the range specified for the parameter. The value will be truncated.
    </description>
    </rule>
    <rule key="C4559">
        <name>warning C4559: &apos;function&apos; : redefinition; the function gains __declspec(modifier)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function was redefined or redeclared and the second definition or declaration added a __declspec modifier (modifier). This warning is informational. To fix this warning, delete one of the definitions.
    </description>
    </rule>
    <rule key="C4561">
        <name>warning C4561: &apos;__fastcall&apos; incompatible with the &apos;/clr&apos; option: converting to &apos;__stdcall&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The __fastcall function-calling convention cannot be used with the /clr compiler option. The compiler ignores the calls to __fastcall. To fix this warning, either remove the calls to __fastcall or compile without /clr. 
    </description>
    </rule>
    <rule key="C4564">
        <name>warning C4564: method &apos;method&apos; of class &apos;class&apos; defines unsupported default parameter &apos;parameter&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected a method with one or more parameters with default values. The default value(s) for the parameters will be ignored when the method is invoked; explicitly specify values for those parameters. If you do not explicitly specify values for those parameters, the C++ compiler will generate an error.
    </description>
    </rule>
    <rule key="C4565">
        <name>warning C4565: &apos;function&apos; : redefinition; the symbol was previously declared with __declspec(modifier)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A symbol was redefined or redeclared and the second definition or declaration, unlike the first definition or declaration, did not have a __declspec modifier (modifier). This warning is informational. To fix this warning, delete one of the definitions.
    </description>
    </rule>
    <rule key="C4566">
        <name>warning C4566: character represented by universal-character-name &apos;char&apos; cannot be represented in the current code page (page)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Not every Unicode character can be represented in your current ANSI code page.
      Narrow strings (one-byte characters) are converted to multi-byte characters whereas wide strings (two-byte characters) are not.
    </description>
    </rule>
    <rule key="C4570">
        <name>warning C4570: &apos;type&apos; : is not explicitly declared as abstract but has abstract functions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type that contains abstract (Visual C++) functions should itself be marked as abstract.
    </description>
    </rule>
    <rule key="C4571">
        <name>warning C4571: Informational: catch(...) semantics changed since Visual C++ 7.1; structured exceptions (SEH) are no longer caught</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4571 is generated for every catch(...) block when compiling with /EHs.
      When compiling with /EHs, a catch(...) block will not catch a structured exception (divide by zero, null pointer, for example); a catch(...) block will only catch explicitly-thrown, C++ exceptions. For more information, see Exception Handling in Visual C++.
      This warning is off by default. Turn this warning on to ensure that when you compile with /EHs your catch (...) blocks do not intend to catch structured exceptions. See Compiler Warnings That Are Off by Default for more information.
      You can resolve C4571 in one of the following ways,
      - Compile with /EHa if you still want your catch(...) blocks to catch structured exceptions.
      - Do not enable C4571 if you do not want your catch(...) blocks to catch structured exceptions, but you still want to use catch(...) blocks. You can still catch structured exceptions using the structured exception handling keywords (__try, __except, and __finally). But remember, when compiled /EHs destructors will only be called when a C++ exception is thrown, not when an SEH exception occurs.
      - Replace catch(...) block with catch blocks for specific C++ exceptions, and optionally, add structured exception handling around the C++ exception handling (__try, __except, and __finally). See Structured Exception Handling (C++) for more information.
      See /EH (Exception Handling Model) for more information.
    </description>
    </rule>
    <rule key="C4572">
        <name>warning C4572: [ParamArray] attribute is deprecated under /clr, use &apos;...&apos; instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An obsolete style for specifying a variable argument list was used. When compiling for the CLR, use ellipsis syntax instead of ParamArrayAttribute. For more information, see Variable Argument Lists (...).
    </description>
    </rule>
    <rule key="C4580">
        <name>warning C4580: [attribute] is deprecated; instead specify System::Attribute as a base class</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      attribute is no longer the preferred syntax for creating user-defined attributes. For more information, see User-Defined Attributes.
    </description>
    </rule>
    <rule key="C4581">
        <name>warning C4581: deprecated behavior: &apos;&quot;string1&quot;&apos; replaced with &apos;string2&apos; to process attribute</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This error can be generated as a result of compiler conformance work that was done for Visual C++ 2005: parameter checking for Visual C++ attributes.
      In previous versions, attribute values were accepted whether or not they were enclosed in quotation marks. If the value is an enumeration, it must not be enclosed in quotation marks.
    </description>
    </rule>
    <rule key="C4584">
        <name>warning C4584: &apos;class1&apos; : base-class &apos;class2&apos; is already a base-class of &apos;class3&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The class you defined inherits from two classes, one of which inherits from the other.
    </description>
    </rule>
    <rule key="C4600">
        <name>warning C4600: #pragma &apos;macro name&apos; : expected a valid non-empty string</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You cannot specify an empty string when you push or pop a macro name with either the pop_macro or push_macro.
    </description>
    </rule>
    <rule key="C4606">
        <name>warning C4606: #pragma warning : &apos;warning_number&apos; ignored; Code Analysis warnings are not associated with warning levels</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      For Code Analysis warnings, only error, once, and default are supported with the warning pragma.
    </description>
    </rule>
    <rule key="C4610">
        <name>warning C4610: object &apos;class&apos; can never be instantiated - user-defined constructor required</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The class has no user-defined or default constructors. No instantiation is performed
    </description>
    </rule>
    <rule key="C4611">
        <name>warning C4611: interaction between &apos;function&apos; and C++ object destruction is non-portable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      On some platforms, functions that include catch may not support C++ object semantics of destruction when out of scope.
      To avoid unexpected behavior, avoid using catch in functions that have constructors and destructors.
      This warning is only issued once; see pragma warning.
    </description>
    </rule>
    <rule key="C4615">
        <name>warning C4615: #pragma warning : unknown user warning type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An invalid warning specifier was used with pragma warning. To resolve the error, use a valid warning specifier. 
    </description>
    </rule>
    <rule key="C4616">
        <name>warning C4616: #pragma warning : warning number &apos;number&apos; not a valid compiler warning</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The warning number specified in the warning pragma cannot be reassigned. The pragma was ignored.
    </description>
    </rule>
    <rule key="C4618">
        <name>warning C4618: pragma parameters included an empty string; pragma ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A null string was given as an argument to a #pragma.
      The pragma was processed without the argument.
    </description>
    </rule>
    <rule key="C4619">
        <name>warning C4619: #pragma warning : there is no warning number &apos;number&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An attempt was made to disable a warning that does not exist.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4621">
        <name>warning C4621: no postfix form of &apos;operator -&apos; found for type &apos;type&apos;, using prefix form</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      There was no postfix decrement operator defined for the given type. The compiler used the overloaded prefix operator.
      This warning can be avoided by defining a postfix - operator.
    </description>
    </rule>
    <rule key="C4623">
        <name>warning C4623: &apos;derived class&apos; : default constructor could not be generated because a base class default constructor is inaccessible</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A constructor was not accessible in a base class and was therefore not generated for a derived class. Any attempt to create an object of this type on the stack will cause a compiler error.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4624">
        <name>warning C4624: &apos;derived class&apos; : destructor could not be generated because a base class destructor is inaccessible</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A destructor was not accessible in a base class and was therefore not generated for a derived class. Any attempt to create an object of this type on the stack will cause a compiler error.
    </description>
    </rule>
    <rule key="C4625">
        <name>warning C4625: &apos;derived class&apos; : copy constructor could not be generated because a base class copy constructor is inaccessible</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A copy constructor was not accessible in a base class and was therefore not generated for a derived class. Any attempt to copy an object of this type will cause a compiler error.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4626">
        <name>warning C4626: &apos;derived class&apos; : assignment operator could not be generated because a base class assignment operator is inaccessible</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An assignment operator was not accessible in a base class and was therefore not generated for a derived class. Any attempt to assign objects of this type will cause a compiler error.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4627">
        <name>warning C4627: &apos;&lt;identifier&gt;&apos;: skipped when looking for precompiled header use</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      While searching for the location where a precompiled header is used, the compiler encountered an #include directive for the &lt;identifier&gt; include file. The compiler ignores the #include directive, but issues warning C4627 if the precompiled header does not already contain the &lt;identifier&gt; include file.
    </description>
    </rule>
    <rule key="C4628">
        <name>warning C4628: digraphs not supported with -Ze. Character sequence &apos;digraph&apos; not interpreted as alternate token for &apos;char&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Digraphs are not supported under /Ze. This warning will be followed by an error.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4630">
        <name>warning C4630: &apos;symbol&apos; : &apos;extern&apos; storage class specifier illegal on member definition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A data member or member function is defined as extern. Members cannot be external, although entire objects can. The compiler ignores the extern keyword.
    </description>
    </rule>
    <rule key="C4632">
        <name>warning C4632: XML document comment: file - access denied: reason</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The path to .xdc file (file) was not valid, and no .xdc file created.
    </description>
    </rule>
    <rule key="C4633">
        <name>warning C4633: XML document comment target - error</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A name passed to the &lt;param&gt; tag was not found by the compiler.
    </description>
    </rule>
    <rule key="C4639">
        <name>warning C4639: MSXML error, XML document comments will not be processed.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning can occur for any number of reasons.
      To resolve this warning:
      - Recompile.
      - Reinstall MSXML by reinstalling the common language runtime.
      - Edit or remove the documentation comment that is causing the warning and recompile.
      When C4639 is issued, all further XML comment processing is disabled, and the .xdc file is not generated.
    </description>
    </rule>
    <rule key="C4640">
        <name>warning C4640: &apos;instance&apos; : construction of local static object is not thread-safe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A static instance of an object is not thread safe.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4641">
        <name>warning C4641: XML document comment has an ambiguous cross reference</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler was unable to unambiguously resolve a reference. To resolve this warning, specify the parameter information necessary to make the reference unambiguous.
    </description>
    </rule>
    <rule key="C4650">
        <name>warning C4650: debugging information not in precompiled header; only global symbols from the header will be available</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The precompiled header file was not compiled with Microsoft symbolic debugging information.
      When linked, the resulting executable or dynamic-link library file will not include debugging information for local symbols contained in the precompiled header.
      This warning can be avoided by recompiling the precompiled header file with the /Zi command-line option.
    </description>
    </rule>
    <rule key="C4651">
        <name>warning C4651: &apos;definition&apos; specified for precompiled header but not for current compile</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The definition was specified when the precompiled header was generated, but not in this compilation.
      The definition will be in effect inside the precompiled header, but not in the rest of the code.
      If a precompiled header was built with /DSYMBOL, the compiler will generate this warning if the /Yu compile doesn&apos;t have /DSYMBOL. Adding /DSYMBOL to the /Yu command line resolves this warning.
    </description>
    </rule>
    <rule key="C4652">
        <name>warning C4652: compiler option &apos;option&apos; inconsistent with precompiled header; current command-line option will override that defined in the precompiled header</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The given command-line option differed from that given when the precompiled header (.pch) was created. The option specified in the current command line was used.
      This warning can be avoided by regenerating the precompiled header with the given command-line option.
    </description>
    </rule>
    <rule key="C4653">
        <name>warning C4653: compiler option &apos;option&apos; inconsistent with precompiled header; current command-line option ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An option specified with the Use Precompiled Headers (/Yu) option was inconsistent with the options specified when the precompiled header was created. This compilation used the option specified when the precompiled header was created.
      This warning can occur when a different value for the Pack Structures option (/Zp) was specified during compilation of the precompiled header.
    </description>
    </rule>
    <rule key="C4656">
        <name>warning C4656: &apos;symbol&apos; : data type is new or has changed since the last build, or is defined differently elsewhere</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You added or changed a data type, making it new to your source code since the last successful build. Edit and Continue does not support changes to existing data types.
      This warning will always be followed by Fatal Error C1092. For further information, see the Supported Code Changes.

      To remove this warning without ending the current debug session
      - Change the data type back to its state prior to the error.
      - From the Debug menu, choose Apply Code Changes.

      To remove this error without changing your source code
      - From the Debug menu, choose Stop Debugging.
      - From the Build menu, choose Build.
    </description>
    </rule>
    <rule key="C4659">
        <name>warning C4659: #pragma &apos;pragma&apos; : use of reserved segment &apos;segment&apos; has undefined behavior, use #pragma comment(linker, ...)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The .drectve option was used to pass an option to the linker. Instead use pragma comment for passing a linker option.
    </description>
    </rule>
    <rule key="C4661">
        <name>warning C4661: &apos;identifier&apos; : no suitable definition provided for explicit template instantiation request</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A member of the template class is not defined.
    </description>
    </rule>
    <rule key="C4667">
        <name>warning C4667: &apos;function&apos; : no function template defined that matches forced instantiation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You cannot instantiate a function template that has not been declared. 
    </description>
    </rule>
    <rule key="C4668">
        <name>warning C4668: &apos;symbol&apos; is not defined as a preprocessor macro, replacing with &apos;0&apos; for &apos;directives&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A symbol that was not defined was used with a preprocessor directive. The symbol will evaluate to false. To define a symbol, you can use either the #define directive or /D compiler option.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4673">
        <name>warning C4673: throwing &apos;identifier&apos; the following types will not be considered at the catch site</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A throw object cannot be handled in the catch block. Each type that cannot be handled is listed in the error output immediately following the line containing this warning. Each unhandled type has its own warning. Read the warning for each specific type for more information.
    </description>
    </rule>
    <rule key="C4677">
        <name>warning C4677: &apos;function&apos;: signature of non-private member contains assembly private type &apos;private_type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type that has public accessibility outside the assembly uses a type that has private access outside the assembly. A component that references the public assembly type will not be able to use the type member or members that reference the assembly private type.
    </description>
    </rule>
    <rule key="C4679">
        <name>warning C4679: The compiler encountered a construct that it cannot support, that cannot be imported from metadata.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      &apos;member&apos;: could not import member
      Do not try to use the construct.
    </description>
    </rule>
    <rule key="C4680">
        <name>warning C4680: &apos;class&apos;: coclass does not specify a default interface</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A default interface was not specified for a class that was marked with the coclass attribute. In order for an object to be useful, it must implement an interface.
    </description>
    </rule>
    <rule key="C4683">
        <name>warning C4683: &apos;function&apos;: event source has an &apos;out&apos;-parameter; exercise caution when hooking multiple event handlers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      If more than one event sink is listening to a COM event source, the value of an out parameter may be ignored.
      Be aware that a memory leak will occur in the following situation:
      - If a method has an out parameter that is internally allocated, for example a BSTR *.
      - If the event has more than one handler (is a multicast event)
      The reason for the leak is that the out parameter will be set by more than one handler, but returned to the call site only by the last handler.
    </description>
    </rule>
    <rule key="C4684">
        <name>warning C4684: &apos;attribute&apos; : WARNING!! attribute may cause invalid code generation: use with caution</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You used an attribute that should not commonly be used.
    </description>
    </rule>
    <rule key="C4686">
        <name>warning C4686: &apos;user-defined type&apos; : possible change in behavior, change in UDT return calling convention</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A class template specialization was not is defined before it was used in a return type. Anything that instantiates the class will resolve C4686; declaring an instance or accessing a member (C&lt;int&gt;::anything) are also options.
      This warning is the result of work to make the Visual C++ .NET 2003 compiler conform to the ISO C++ standard.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4687">
        <name>warning C4687: &apos;class&apos;: a sealed abstract class cannot implement an interface &apos;interface&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A sealed, abstract type is typically only useful to hold static member functions.
      For more information, see abstract (Visual C++)and sealed.
      C4687 is issued as an error by default. You can suppress C4687 with the warning pragma. If you are certain that you want to implement an interface in a sealed, abstract type, you can suppress C4687.
    </description>
    </rule>
    <rule key="C4691">
        <name>warning C4691: &apos;type&apos; : type referenced was expected in unreferenced assembly &apos;file&apos;, type defined in current translation unit used instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The metadata file containing the original type definition is not referenced, and the compiler is using a local type definition.
      In the case where you are rebuilding file, C4691 can be ignored or turned off with pragma warning. That is, if the file you are building is the same as the file where the compiler expects to find the type definition, you can ignore C4691.
      However, unexpected behavior can occur if the compiler uses a definition that is not from the same assembly that is referenced in metadata; CLR types are typed not only by the name of the type, but also by the assembly. That is, a type Z from assembly z.dll is different from a type Z from assembly y.dll
    </description>
    </rule>
    <rule key="C4692">
        <name>warning C4692: &apos;function&apos;: signature of non-private member contains assembly private native type &apos;native_type&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type that is visible outside the assembly contains a member function whose signature contains a native type that is not visible outside the assembly. Therefore, the member function should not be called if its containing type is instantiated outside the assembly.
      For more information, see Type Visibility.
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4700">
        <name>warning C4700: uninitialized local variable &apos;name&apos; used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You used the local variable name without first assigning it a value, which could lead to unpredictable results.
    </description>
    </rule>
    <rule key="C4701">
        <name>warning C4701: Potentially uninitialized local variable &apos;name&apos; used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The local variable name might have been used without being assigned a value. This could lead to unpredictable results.
    </description>
    </rule>
    <rule key="C4702">
        <name>warning C4702: unreachable code</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is the result of compiler conformance work that was done for Visual Studio .NET 2003: unreachable code. When the compiler (back end) detects unreachable code, it will generate C4702, a level 4 warning.
      For code that is valid in both the Visual Studio .NET 2003 and Visual Studio .NET versions of Visual C++, remove the unreachable code or assure that all source code is reachable by some flow of execution.
    </description>
    </rule>
    <rule key="C4703">
        <name>warning C4703: Potentially uninitialized local pointer variable &apos;name&apos; used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The local pointer variable name might have been used without being assigned a value. This could lead to unpredictable results.
    </description>
    </rule>
    <rule key="C4706">
        <name>warning C4706: assignment within conditional expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The test value in a conditional expression was the result of an assignment.
      An assignment has a value (the value on the left side of the assignment) that can be used legally in another expression, including a test expression.
    </description>
    </rule>
    <rule key="C4709">
        <name>warning C4709: comma operator within array index expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When a comma occurs in an array index expression, the compiler uses the value after the last comma.
    </description>
    </rule>
    <rule key="C4710">
        <name>warning C4710: &apos;function&apos; : function not inlined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The given function was selected for inline expansion, but the compiler did not perform the inlining.
      Inlining is performed at the compiler&apos;s discretion. The inline keyword, like the register keyword, is used as a hint for the compiler. The compiler uses heuristics to determine if it should inline a particular function to speed up the code when compiling for speed, or if it should inline a particular function to make the code smaller when compiling for space. The compiler will only inline very small functions when compiling for space.
      In some cases, the compiler will not inline a particular function for mechanical reasons. See C4714 for a list of reasons the compiler may not inline a function.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4711">
        <name>warning C4711: function &apos;function&apos; selected for inline expansion</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler performed inlining on the given function, although it was not marked for inlining.
      C4711 is enabled if /Ob2 is specified.
      Inlining is performed at the compiler&apos;s discretion. This warning is informational.
      This warning is off by default. To enable a warning, use #pragma warning. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4714">
        <name>warning C4714: function &apos;function&apos; marked as __forceinline not inlined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The given function was selected for inline expansion, but the compiler did not perform the inlining.
      Although __forceinline is a stronger indication to the compiler than __inline, inlining is still performed at the compiler&apos;s discretion, but no heuristics are used to determine the benefits from inlining this function.
      In some cases, the compiler will not inline a particular function for mechanical reasons. For example, the compiler will not inline:
      - A function if it would result in mixing both SEH and C++ EH.
      - Some functions with copy constructed objects passed by value when -GX/EHs/EHa is on.
      - Functions returning an unwindable object by value when -GX/EHs/EHa is on.
      - Functions with inline assembly when compiling without -Og/Ox/O1/O2.
      - Functions with a variable argument list.
      - A function with a try (C++ exception handling) statement.
    </description>
    </rule>
    <rule key="C4715">
        <name>warning C4715: &apos;function&apos; : not all control paths return a value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified function can potentially not return a value.
    </description>
    </rule>
    <rule key="C4716">
        <name>warning C4716: &apos;function&apos; must return a value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The given function did not return a value.
      Only functions with a return type of void can use the return command without an accompanying return value.
      An undefined value will be returned when this function is called.
      This warning is automatically promoted to an error. If you wish to modify this behavior, use #pragma warning.
    </description>
    </rule>
    <rule key="C4717">
        <name>warning C4717: &apos;function&apos; : recursive on all control paths, function will cause runtime stack overflow</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Every path through a function contains a call to the function. Since there is no way to exit the function without first calling itself recursively, the function will never exit.
    </description>
    </rule>
    <rule key="C4723">
        <name>warning C4723: potential divide by 0</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The second operand in a divide operation evaluated to zero at compile time, giving undefined results.
      This warning is issued only when using /Og or an optimization option that implies /Og.
      The compiler may have generated the zero operand.
    </description>
    </rule>
    <rule key="C4727">
        <name>warning C4727: &quot;PCH named pch_file with same timestamp found in obj_file_1 and obj_file_2. Using first PCH.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4727 occurs when compiling multiple compilands with /Yc, and where the compiler was able to mark all .obj files with the same .pch timestamp.
      To resolve, compile one source file with /Yc /c (creates pch), and the others compile separately with /Yu /c (uses pch), then link them together.
      So, if you did the following and generates C4727:
      - cl /clr /GL a.cpp b.cpp c.cpp /Ycstdafx.h
      You would do the following instead:
      - cl /clr /GL a.cpp /Ycstdafx.h /c
      - cl /clr /GL b.cpp c.cpp /Yustdafx.h /link a.obj
      For more information, see
      - /Yc (Create Precompiled Header File)
      - /Yu (Use Precompiled Header File)
    </description>
    </rule>
    <rule key="C4730">
        <name>warning C4730: &apos;main&apos; : mixing _m64 and floating point expressions may result in incorrect code</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function uses __m64 and float/double types. Because the MMX and floating-point registers share the same physical register space (cannot be used simultaneously), using __m64 and float/double types in the same function can result in data corruption, possibly causing an exception.
      To safely use __m64 types and floating-point types in the same function, each instruction that uses one of the types should be separated by the _m_empty() (for MMX) or _m_femms() (for 3DNow!) intrinsic.
    </description>
    </rule>
    <rule key="C4731">
        <name>warning C4731: &apos;pointer&apos; : frame pointer register &apos;register&apos; modified by inline assembly code</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A frame pointer register was modified. You must save and restore the register in your inline assembly block or frame variable (local or parameter, depending on the register modified), or your code may not work properly.
    </description>
    </rule>
    <rule key="C4733">
        <name>warning C4733: Inline asm assigning to &apos;FS:0&apos; : handler not registered as safe handler</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function modifying the value at FS:0 to add a new exception handler may not work with Safe Exceptions, because the handler may not be registered as a valid exception handler (see /SAFESEH).
      To resolve this warning, either remove the FS:0 definition or turn off this warning and use .SAFESEH to specify the safe exception handlers.
    </description>
    </rule>
    <rule key="C4738">
        <name>warning C4738: storing 32-bit float result in memory, possible loss of performance</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4738 warns that the result of an assignment, cast, passed argument, or other operation may need to be rounded or that the operation ran out of registers and needed to use memory (spilling). This can result in performance loss.
      To resolve this warning and avoid rounding, compile with /fp:fast or use doubles instead of floats.
      To resolve this warning and avoid running out of registers, change the order of computation and modify your use of inlining
      This warning is off by default. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4740">
        <name>warning C4740: flow in or out of inline asm code suppresses global optimization</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When there is a jump in to or out of an asm block, global optimizations are disabled for that function.
    </description>
    </rule>
    <rule key="C4742">
        <name>warning C4742: &apos;var&apos; has different alignment in &apos;file1&apos; and &apos;file2&apos;: number and number</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An external variable that was referenced or defined in two files has different alignment in those files. This warning is emitted when compiler finds that __alignof for the variable in file1 differs from __alignof for the variable in file2. This can be caused by using incompatible types when declaring variable in different files, or by using non-matching #pragma pack in different files.
      To resolve this warning, either use the same type definition or use different names for the variables.
      For more information, see pack and __alignof Operator.
    </description>
    </rule>
    <rule key="C4743">
        <name>warning C4743: &apos;type&apos; has different size in &apos;file1&apos; and &apos;file2&apos;: number and number bytes</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An external variable referenced or defined in two files has different types in those files, and the compiler determined that the size of the variable in file1 differs from the size of the variable in file2.
      There is important case when this warning can be emitted for C++. If you declare the same types with the same name in two different files, if those declarations contain virtual functions, and if the declarations are not the same, then the compiler can emit warning C4744 for the virtual function tables. The warning occurs because there are two different sized virtual function tables for the same type, and linker must choose one of them to incorporate into the executable. It is possible that this can result in your program calling the wrong virtual function.
      To resolve this warning, either use the same type definition or use different names for the types or variables.
    </description>
    </rule>
    <rule key="C4744">
        <name>warning C4744: &apos;var&apos; has different type in &apos;file1&apos; and &apos;file2&apos;: &apos;type1&apos; and &apos;type2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An external variable referenced or defined in two files has different types in those files. To resolve, either make the type definitions the same, or change variable name in one of the files.
    </description>
    </rule>
    <rule key="C4746">
        <name>warning C4746: volatile access of &apos;&lt;expression&gt;&apos; is subject to /volatile:[iso|ms] setting; consider using __iso_volatile_load/store intrinsic functions.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4746 is emitted whenever a volatile variable is accessed directly. It is intended to help developers identify code locations that are affected by the specific volatile model currently specified (which can be controlled with the /volatile compiler option). In particular, it can be useful in locating compiler-generated hardware memory barriers when /volatile:ms is used.
      The __iso_volatile_load/store intrinsics can be used to explicitly access volatile memory without being affected by the volatile model. Using these intrinsics will not trigger C4746.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4747">
        <name>warning C4747: Calling managed &apos;entrypoint&apos;: Managed code may not be run under loader lock, including the DLL entrypoint and calls reached from the DLL entrypoint</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler found a (probable) DLL entry point compiled to MSIL. Because of potential problems with loading a DLL whose entry point has been compiled to MSIL, you are strongly discouraged from compiling a DLL entry point function to MSIL.
      For more information, see Initialization of Mixed Assemblies and Linker Tools Error LNK1306.
      To correct this error
      - Do not compile the module with /clr.
      - Mark the entry point function with #pragma unmanaged.
    </description>
    </rule>
    <rule key="C4748">
        <name>warning C4748: /GS can not protect parameters and local variables from local buffer overrun because optimizations are disabled in function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      /GS (Buffer Security Check) , which is enabled by default, cannot protect parameters and local variables from local buffer overrun in a function unless the function has optimizations enabled.
      The compiler will disable optimizations if a function has inline assembly code containing flow of control (jmp or jcc, for example) statements.
      Enable optimizations to resolve this warning, and to allow /GS to protect parameters and local variables from local buffer overrun
    </description>
    </rule>
    <rule key="C4756">
        <name>warning C4756: overflow in constant arithmetic</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler generated an exception while doing constant arithmetic during compilation.
    </description>
    </rule>
    <rule key="C4772">
        <name>warning C4772: #import referenced a type from a missing type library; &apos;missing_type&apos; used as a placeholder</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A type library was referenced with the #import directive. However, the type library contained a reference to another type library that was not referenced with #import. This other .tlb file was not found by the compiler.
      Note that the compiler will not find type libraries in different directories if you use the /I (Additional Include Directories) compiler option to specify those directories. If you want the compiler to find type libraries in different directories, add those directories to the PATH environment variable.
      This warning is, by default, issued as an error. C4772 can not be suppressed with /W0.
    </description>
    </rule>
    <rule key="C4788">
        <name>warning C4788: &apos;identifier&apos; : identifier was truncated to &apos;number&apos; characters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler limits the maximum length allowed for a function name. When the compiler generates funclets for EH/SEH code, it forms the funclet name by prepending the function name with some text, for example &quot;__catch&quot;, &quot;__unwind&quot;, or another string.
      The resulting funclet name can be too long, and the compiler will truncate it and generate C4788.
      To resolve this warning, shorten the original function name. If the function is a C++ template function or method, use a typedef for part of the name
    </description>
    </rule>
    <rule key="C4789">
        <name>warning C4789: destination of memory copy is too small</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Warns about buffer overrun when specific C run-time (CRT) functions are used, parameters are passed, and assignments are performed, such that the data sizes are known at compile time. This warning is for situations that might elude typical data-size mismatch detection.
      The warning appears when data, whose length is known at compile time, is copied and put into a data block whose size is known at compile time to be too small for the data. The copy must be done by using the intrinsic form of one of the following CRT functions:
      - strcpy
      - memset
      - memcpy, wmemcpy
      The warning also appears when a parameter datatype is mismatched by using a cast, and then a copy assignment from an lvalue reference is attempted.
      Visual C++ might generate this warning for a code path that does not ever execute. You can temporarily disable the warning by using #pragma, as shown in this example:
      #pragma(push)
      #pragma warning ( disable : 4789 )
      // unused code that generates compiler warning C4789
      #pragma(pop)
      This keeps Visual C++ from generating the warning for that specific block of code. The #pragma(push) preserves the existing state before #pragma warning(disable: 4789) changes it. The #pragma(pop) restores the pushed state, and removes the effects of the #pragma warning(disable:4789). For more information about the C++ preprocessor directive #pragma, see warning and Pragma Directives and the __Pragma Keyword.
    </description>
    </rule>
    <rule key="C4793">
        <name>warning C4793: &apos;function&apos; : function is compiled as native code: &apos;reason&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler cannot compile function into managed code, even though the /clr compiler option is specified. Instead, the compiler emits warning C4793 and an explanatory continuation message, and then compiles function into native code. The continuation message contains the reason text that explains why function cannot be compiled to MSIL.
      This is a level 1 warning when you specify the /clr:pure compiler option.
    </description>
    </rule>
    <rule key="C4799">
        <name>warning C4799: No EMMS at end of function &apos;function&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The function has at least one MMX instruction, but does not have an EMMS instruction. When a multimedia instruction is used, an EMMS instruction should also be used to clear the multimedia tag word at the end of the MMX code. For more information on EMMS instructions, see Guidelines for When to Use EMMS.
      You may get C4799 when using ivec.h, indicating that the code does not use properly execute the EMMS instruction before returning. This is a false warning for these headers. You may turn these off by defining _SILENCE_IVEC_C4799 in ivec.h. However, be aware that this will also keep the compiler from giving correct warnings of this type.
      For related information, see the Intel&apos;s MMX Instruction Set.
    </description>
    </rule>
    <rule key="C4800">
        <name>warning C4800: &apos;type&apos; : forcing value to bool &apos;true&apos; or &apos;false&apos; (performance warning)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is generated when a value that is not bool is assigned or coerced into type bool. Typically, this message is caused by assigning int variables to bool variables where the int variable contains only values true and false, and could be redeclared as type bool. If you cannot rewrite the expression to use type bool, then you can add &quot;!=0&quot; to the expression, which gives the expression type bool. Casting the expression to type bool will not disable the warning, which is by design.
    </description>
    </rule>
    <rule key="C4801">
        <name>warning C4801: Return by reference is not verifiable: reason</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      You cannot store a tracking reference into a local variable and then return it verifiably.
      A reference can only be verifiably returned when it can be tracked by the verifier from creation to return point and when it is a reference to an element of an array, or a member of a class.
      For more information, see Peverify.exe (PEVerify Tool).
      A reference must remain on the stack from creation to return in order to be verifiable.
      C4801 is always issued as an error. You can turn off this warning with the #pragma warning or /wd; see warning or /w, /Wn, /WX, /Wall, /wln, /wdn, /wen, /won (Warning Level) for more information.
    </description>
    </rule>
    <rule key="C4803">
        <name>warning C4803: &apos;method&apos; : the raise method has a different storage class from that of the event, &apos;event&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Event methods must have the same storage class as the event declaration. The compiler adjusts the event&apos;s methods so that the storage classes are the same.
      This warning can occur if you have a class that implements an event from an interface. The compiler does not implicitly generate a raise method for an event in an interface. When you implement that interface in a class, the compiler does implicitly generate a raise method and that method will not be virtual, hence the warning.
      See warning pragma for information on how to turn a warning off.
    </description>
    </rule>
    <rule key="C4804">
        <name>warning C4804: &apos;operation&apos; : unsafe use of type &apos;bool&apos; in operation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is generated for comparison operations between bool and int. 
    </description>
    </rule>
    <rule key="C4805">
        <name>warning C4805: &apos;operation&apos; : unsafe mix of type &apos;type&apos; and type &apos;type&apos; in operation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is for when you used a bool variable or value in an unexpected way. For example, C4804 is generated if you use operators such as the negative unary operator (-) or the complement operator (~). The compiler evaluates the expression.
    </description>
    </rule>
    <rule key="C4815">
        <name>warning C4815: &apos;var&apos; : zero-sized array in stack object will have no elements (unless the object is an aggregate that has been aggregate initialized)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An array with an undefined number of elements (zero-sized array) is the last member of a type and an object of the type was created on the stack. No memory will be allocated for the array. If you need a useful constructor, you can allocate memory for the struct on the heap.
    </description>
    </rule>
    <rule key="C4819">
        <name>warning C4819: The file contains a character that cannot be represented in the current code page (number). Save the file in Unicode format to prevent data loss.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      C4819 occurs when an ANSI source file is compiled on a system with a codepage that cannot represent all characters in the file.
      To resolve C4819, save the file in Unicode format.
    </description>
    </rule>
    <rule key="C4820">
        <name>warning C4820: &apos;bytes&apos; bytes padding added after construct &apos;member_name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The type and order of elements caused the compiler to add padding to the end of a struct. See align for more information on padding in a struct.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4821">
        <name>warning C4821: Unable to determine Unicode encoding type, please save the file with signature (BOM)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler could not determine the encoding type for a file. To resolve this warning, save the file with a byte order marker. See Managing Files with Encoding for more information.
    </description>
    </rule>
    <rule key="C4823">
        <name>warning C4823: &apos;function&apos; : uses pinning pointers but unwind semantics are not enabled. Consider using /EHa</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      To unpin an object on the managed heap pointed to by a pinning pointer declared in a block scope, the compiler simulates the behavior of destructors of local classes, &quot;pretending&quot; the pinning pointer has a destructor that nullifies the pointer. To enable a call to a destructor after throwing an exception, you must enable object unwinding, which you can do by using /EHsc.
      You can also manually unpin the object and ignore the warning.
    </description>
    </rule>
    <rule key="C4826">
        <name>warning C4826: Conversion from &apos;type1 &apos; to &apos;type_2&apos; is sign-extended. This may cause unexpected runtime behavior.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the compiler performed sign extension when a 32-bit pointer was cast to a 64-bit variable.
      If the extension was performed on a windows HANDLE type, it is safe to ignore this warning. If the extension was performed on a pointer type, you should modify the cast to prevent the sign extension (see example below).
      C4826 is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4829">
        <name>warning C4829: Possibly incorrect parameters to function main. Consider &apos;int main(array&lt;System::String^&gt;^ argv)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Certain functions, such as main, cannot take reference type parameters. While compilation will succeed, the resulting image will probably not run
    </description>
    </rule>
    <rule key="C4832">
        <name>warning C4832: token &apos;token&apos; is illegal after UDT &apos;type name&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A member of a UDT (user-defined type, such a class or struct) was qualified incorrectly. The compiler issues this warning and proceeds as if the qualification was specified correctly.
    </description>
    </rule>
    <rule key="C4835">
        <name>warning C4835: &apos;variable&apos; : the initializer for exported data will not be run until managed code is first executed in the host assembly</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When accessing data between managed components, it is recommended that you not use native C++ import and export mechanisms. Instead, declare your data members inside a managed type and reference the metadata with #using in the client. For more information, see #using Directive (C++).
    </description>
    </rule>
    <rule key="C4836">
        <name>warning C4836: nonstandard extension used : &apos;type&apos; : local types or unnamed types cannot be used as template arguments</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The C++ standard does not allow the use of local types as template arguments, but the Visual C++ compiler does allow this under /Ze. C4836 is an informational warning, to let you know that you are writing non-conformant code. For more information, see /Za, /Ze (Disable Language Extensions).
      C4836 is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4837">
        <name>warning C4837: trigraph detected: &apos;??%c&apos; replaced by &apos;%c&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The detected trigraph is replaced by the indicated character.
      The compiler translates trigraphs before any other processing is completed. Use the character escape sequence, \?, to prevent the misinterpretation of a character sequence that resembles a trigraph. For more information about trigraphs, see Trigraphs. For more information about escape sequences, see Escape Sequences.
      C4837 is off by default. See Compiler Warnings That Are Off by Default for more information.
      To correct this error
      - use the character escape sequence, \?, instead of one of the &apos;?&apos; characters in the source code.
    </description>
    </rule>
    <rule key="C4867">
        <name>warning C4867: &apos;function&apos;: function call missing argument list; use &apos;call&apos; to create a pointer to member</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A pointer to member function was initialized incorrectly.
      This warning can be generated as a result of compiler conformance work that was done for Visual C++ 2005: enhanced pointer-to-member conformance. Code that compiled prior to Visual C++ 2005 will now generate C4867.
      This warning is always issued as an error. Use the warning pragma to disable this warning. For more information about C4867 and MFC/ATL, see _ATL_ENABLE_PTM_WARNING.
    </description>
    </rule>
    <rule key="C4905">
        <name>warning C4905: wide string literal cast to &apos;LPSTR&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an unsafe cast. The cast did succeed, but you should use a conversion routine.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4906">
        <name>warning C4906: string literal cast to &apos;LPWSTR&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an unsafe cast. The cast did succeed, but you should use a conversion routine.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4917">
        <name>warning C4917: &apos;declarator&apos; : a GUID can only be associated with a class, interface or namespace</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A user-defined structure other than class, interface, or namespace cannot have a GUID.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4927">
        <name>warning C4927: illegal conversion; more than one user-defined conversion has been implicitly applied</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      More than one user-defined conversion is implicitly applied to a single value - the compiler did not find an explicit conversion but did find a conversion, which it used.
    </description>
    </rule>
    <rule key="C4928">
        <name>warning C4928: illegal copy-initialization; more than one user-defined conversion has been implicitly applied</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      More than one user-defined conversion routine was found. The compiler executed the code in all such routines.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4929">
        <name>warning C4929: &apos;file&apos;: typelibrary contains a union; ignoring the &apos;embedded_idl&apos; qualifier</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The embedded_idl attribute of #import could not be applied to the type library because a union is present in the type library. To resolve this warning, don&apos;t use embedded_idl.
    </description>
    </rule>
    <rule key="C4930">
        <name>warning C4930: &apos;prototype&apos;: prototyped function not called (was a variable definition intended?)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler detected an unused function prototype. If the prototype was intended as a variable declaration, remove the open/close parentheses.
    </description>
    </rule>
    <rule key="C4931">
        <name>warning C4931: we are assuming the type library was built for number-bit pointers</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Explicit information was not supplied with the ptrsize attribute of the #import directive; the compiler concluded that pointer size of the type library is number.
      This warning is off by default. See Compiler Warnings That Are Off by Default for more information.
    </description>
    </rule>
    <rule key="C4945">
        <name>warning C4945: &apos;symbol&apos; : cannot import symbol from &apos;assembly2&apos;: as &apos;symbol&apos; has already been imported from another assembly &apos;assembly1&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A symbol was imported from a referenced assembly but that symbol was already imported from another referenced assembly. Either do not reference one of the assemblies or get the symbol name changed in one of the assemblies.
    </description>
    </rule>
    <rule key="C4946">
        <name>warning C4946: reinterpret_cast used between related classes: &apos;class1&apos; and &apos;class2&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Do not use reinterpret_cast to cast between related types. Use static_cast instead, or for polymorphic types, use dynamic_cast.
      By default, this warning is off. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4948">
        <name>warning C4948: return type of &apos;accessor&apos; does not match the last parameter type of the corresponding setter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler found a mismatch between what data type is being get and set for an indexed property.
      C4948 is only reachable using /clr:oldSyntax.
    </description>
    </rule>
    <rule key="C4949">
        <name>warning C4949: pragmas &apos;managed&apos; and &apos;unmanaged&apos; are meaningful only when compiled with &apos;/clr[:option]&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler ignores the managed and unmanaged pragmas if the source code is not compiled with /clr. This warning is informational.
    </description>
    </rule>
    <rule key="C4964">
        <name>warning C4964: No optimization options were specified; profile info will not be collected</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      /GL and /LTCG were specified, but no optimizations were requested, so no .pgc files will be generated and, therefore, no profile-guided optimizations will be possible.
      If you want .pgc files to be generated when you run your application, specify one of the /O compiler options.
    </description>
    </rule>
    <rule key="C4965">
        <name>warning C4965: implicit box of integer 0; use nullptr or explicit cast</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Visual C++ features implicit boxing of value types. An instruction that resulted in a null assignment using Managed Extensions for C++ now becomes an assignment to a boxed int.
      For more information, see Boxing (Visual C++).
    </description>
    </rule>
    <rule key="C4980">
        <name>warning C4980: &apos;keyword&apos; : use of this keyword requires /clr:oldSyntax command line option</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A keyword from a previous version was used. Update your code to use newer syntax, or use /clr:oldSyntax. For more information about the newer syntax, see Component Extensions for Runtime Platforms.
      C4980 is a warning that is always issued as an error. Use /wd to turn the warning off. See /w, /Wn, /WX, /Wall, /wln, /wdn, /wen, /won (Warning Level) for more information.
    </description>
    </rule>
    <rule key="C4986">
        <name>warning C4986: &apos;function&apos;: exception specification does not match previous declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning can be generated when there is an exception specification in one declaration and not the other.
      By default, C4986 is off. For more information, see Compiler Warnings That Are Off by Default.
    </description>
    </rule>
    <rule key="C4995">
        <name>warning C4995: &apos;function&apos;: name was marked as #pragma deprecated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler encountered a function that was marked with pragma deprecated. The function may no longer be supported in a future release. You can turn this warning off with the warning pragma (example below).
    </description>
    </rule>
    <rule key="C4996">
        <name>warning C4996: &apos;function&apos;: was declared deprecated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The compiler encountered a function that was marked with deprecated. The function may no longer be supported in a future release. You can turn this warning off with the warning pragma (example below).
      C4996 is generated for the line on which the function is declared and for the line on which the function is used.
      You will see C4996 if you are using members of the &lt;hash_map&gt;; and &lt;hash_set&gt;; header files in the std namespace. See The stdext Namespace for more information.
      Some CRT and Standard C++ Library functions have been deprecated in favor of new, more secure functions. For more information about deprecated functions, see Security Features in the CRT and Safe Libraries: Standard C++ Library.
      C4996 can also occur if you use MFC or ATL functions that were deprecated for security reasons. To suppress these warnings, see _AFX_SECURE_NO_WARNINGS and _ATL_SECURE_NO_WARNINGS.
      C4996 can also occur when you use the marshaling library. In this case C4996 is an error, not a warning. This error will occur when you use marshal_as to convert between two data types that require a marshal_context Class. You will also receive this error when the marshaling library does not support a conversion. For more information about the marshaling library, see Overview of Marshaling in C++.
    </description>
    </rule>
    <rule key="C6001">
        <name>warning C6001: using uninitialized memory &lt;variable&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when an uninitialized local variable is used before it is assigned a value. This could lead to unpredictable results. You should always initialize variables before use.
    </description>
    </rule>
    <rule key="C6011">
        <name>warning C6011: dereferencing NULL pointer &lt;name&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a null pointer is being dereferenced. If the pointer value is invalid, the result is undefined.
    </description>
    </rule>
    <rule key="C6014">
        <name>warning C6014: Leaking memory.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the specified pointer points to allocated memory or some other allocated resource that has not been freed. The analyzer checks for this condition only when the _Analysis_mode_(_Analysis_local_leak_checks_) SAL annotation is specified. By default, this annotation is specified for Windows kernel mode (driver) code. For more information about SAL annotations, see Using SAL Annotations to Reduce C/C++ Code Defects.
    </description>
    </rule>
    <rule key="C6029">
        <name>warning C6029: possible buffer overrun in call to &lt;function&gt;: use of unchecked value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a function that takes a buffer and a size is being passed a unchecked size. The data read-in from some external source has not been verified to see whether it is smaller than the buffer size. An attacker might intentionally specify a much larger than expected value for the size, which will lead to a buffer overrun.
      Generally, whenever you read data from an untrusted external source, make sure to verify it for validity. It is usually appropriate to verify the size to make sure it is in the expected range.
    </description>
    </rule>
    <rule key="C6031">
        <name>warning C6031: return value ignored: &lt;function&gt; could return unexpected value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the calling function is not checking the return value of a function call that signals failure via its return value. Depending on which function is being called, this defect can lead to seemingly random program misbehavior, including crashes and data corruptions in error conditions or low-resource situations.
      In general, it is not safe to assume that a call to function requiring disk, network, memory, or other resources will always succeed. The caller should always check the return value and handle error cases appropriately. Also consider using the _Must_inspect_result_ annotation, which checks that the value is examined in a useful way.
    </description>
    </rule>
    <rule key="C6053">
        <name>warning C6053: call to &lt;function&gt; may not zero-terminate string &lt;variable&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the specified function has been called in such a way that the resulting string might not be zero-terminated. This defect might cause an exploitable buffer overrun or crash. This warning is also generated if an annotated function expects a null terminated string is passed a string that is not null terminated.
      Most C standard library and Win32 string handling functions require and produce zero-terminated strings. A few &apos;counted string&apos; functions (including strncpy, wcsncpy, _mbsncpy, _snprintf, and snwprintf) do not produce zero-terminated strings if they exactly fill their buffer. In this case, a subsequent call to a string function that expects a zero-terminated string will go beyond the end of the buffer looking for the zero. The program should make sure that the string ends with a zero. In general, you should pass a length to the &apos;counted string&apos; function one smaller than the size of the buffer and then explicitly assign zero to the last character in the buffer.
    </description>
    </rule>
    <rule key="C6054">
        <name>warning C6054: string &lt;variable&gt; may not be zero-terminated</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a function that requires zero-terminated string was passed a non-zero terminated string. A function that expects a zero-terminated string will go beyond the end of the buffer to look for the zero. This defect might cause an exploitable buffer overrun error or crash. The program should make sure that the string ends with a zero.
    </description>
    </rule>
    <rule key="C6057">
        <name>warning C6057: buffer overrun due to number of characters/number of bytes mismatch in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a function that expects the number of characters is being passed the number of bytes instead. With wide (Unicode) characters, the values are different. This defect might cause an exploitable buffer overrun or crash.
      A common cause of this defect is using sizeof on a character array. The sizeof operator always computes the number of bytes; for ANSI characters this is the same as the number of characters, but for Unicode characters it is twice the number of characters.
      It is usually safe to compute the number of elements in an array by dividing the size of the array by the size of each element.
    </description>
    </rule>
    <rule key="C6059">
        <name>warning C6059: Incorrect length parameter in call to &lt;function&gt;. Pass the number of remaining characters, not the buffer size of &lt;variable&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a call to a string concatenation function is probably passing an incorrect value for the number of characters to concatenate. This defect might cause an exploitable buffer overrun or crash. A common cause of this defect is passing the buffer size, instead of the remaining number of characters in the buffer, to the string manipulation function.
    </description>
    </rule>
    <rule key="C6063">
        <name>warning C6063: missing string argument to &lt;function&gt; corresponding to conversion specifier &lt;number&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that not enough arguments are being provided to match a format string; at least one of the missing arguments is a string. This defect can cause crashes and buffer overflows (if the called function is of the sprintf family), as well as potentially incorrect output.
    </description>
    </rule>
    <rule key="C6064">
        <name>warning C6064: missing integer argument to &lt;function&gt; corresponding to conversion specifier &lt;number&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that not enough arguments are being provided to match a format string and one of the missing arguments is an integer. This defect can cause incorrect output.
    </description>
    </rule>
    <rule key="C6066">
        <name>warning C6066: non-pointer passed as parameter &lt;number&gt; when pointer is required in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies that a pointer is required, for example, a %n or %p specification for printf or a %d for scanf, but a non-pointer is being passed. This defect is likely to cause a crash or corruption of some form.
    </description>
    </rule>
    <rule key="C6067">
        <name>warning C6067: parameter &lt;number&gt; in call to &lt;function&gt; must be the address of the string</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a mismatch between the format specifier and the function parameter. Even though the warning suggests using the address of the string, you must check the type of parameter a function expects before correcting the problem. For example, a %s specification for printf requires a string argument, but a %s specification in scanf requires an address of the string.
      This defect is likely to cause a crash or corruption of some form
    </description>
    </rule>
    <rule key="C6101">
        <name>warning C6101: Returning uninitialized memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A successful path through the function does not set the named _Out_ parameter. This message is generated based on SAL annotations that indicate that the function in question always succeeds. A function that doesn&#8217;t return a success/failure indication should set all of its _Out_ parameters because the analyzer assumes that the _Out_ parameter is uninitialized data before the function is called, and that the function will set the parameter so that it&#8217;s no longer uninitialized. If the function does indicate success/failure, then the _Out_ parameter doesn&apos;t have to be set in the case of failure, and you can detect and avoid the uninitialized location. In either case, the objective is to avoid the reading of an uninitialized location. If the function sometimes doesn&#8217;t touch an _Out_ parameter that&#8217;s subsequently used, then the parameter should be initialized before the function call and be marked with the _Inout_ annotation, or the more explicit _Pre_null_ or _Pre_satisfies_() when appropriate. &quot;Partial success&quot; can be handled with the _When_ annotation. For more information, see Using SAL Annotations to Reduce C/C++ Code Defects.
    </description>
    </rule>
    <rule key="C6200">
        <name>warning C6200: index &lt;name&gt; is out of valid index range &lt;min&gt; to &lt;max&gt; for non-stack buffer &lt;variable&gt; </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an integer offset into the specified array exceeds the maximum bounds of that array. This defect might cause random behavior or crashes.
      One common cause of this defect is using the size of an array as an index into the array. Because C/C++ array indexing is zero-based, the maximum legal index into an array is one less than the number of array elements.
    </description>
    </rule>
    <rule key="C6201">
        <name>warning C6201: buffer overrun for &lt;variable&gt;, which is possibly stack allocated: index &lt;name&gt; is out of valid index range &lt;min&gt; to &lt;max&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an integer offset into the specified stack array exceeds the maximum bounds of that array. This defect might cause random behavior or crashes.
      One common cause of this defect is using an array&#8217;s size as an index into the array. Because C/C++ array indexing is zero-based, the maximum legal index into an array is one less than the number of array elements.
    </description>
    </rule>
    <rule key="C6202">
        <name>warning C6202: buffer overrun for &lt;variable&gt;, which is possibly stack allocated, in call to &lt;function&gt;: length &lt;size&gt; exceeds buffer size &lt;max&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter pointing to a stack buffer of known size is being passed into a function that copies more bytes into it than that size. This situation will cause a buffer overrun. This defect is likely to cause an exploitable security hole or a program crash.
    </description>
    </rule>
    <rule key="C6203">
        <name>warning C6203: buffer overrun for buffer &lt;variable&gt; in call to &lt;function&gt;: length &lt;size&gt; exceeds buffer size </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter that points to a non-stack buffer of known size is being passed into a function that copies more bytes into it than that size. This situation will cause a buffer overrun.
      This defect might cause an exploitable security hole or a program crash.
    </description>
    </rule>
    <rule key="C6204">
        <name>warning C6204: possible buffer overrun in call to &lt;function&gt;: use of unchecked parameter &lt;variable&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a function call is being made that could potentially lead to an overrun of a stack buffer, depending on the possible values of parameters to the function being analyzed. This defect might cause an exploitable buffer overrun or crash.
      It is a good idea to review the code, as well as the callers to this function, to see whether the function can ever be called with unexpected data. If it is not clear that all calls are safe, it might be appropriate to validate the input to the function by checking the length of any input strings or by annotating the function parameter using appropriate properties.
    </description>
    </rule>
    <rule key="C6209">
        <name>warning C6209: using &apos;sizeof&lt;variable1&gt;&apos; as parameter &lt;number&gt; in call to &lt;function&gt; where &lt;variable2&gt; may be an array of wide characters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6209: using &apos;sizeof&lt;variable1&gt;&apos; as parameter &lt;number&gt; in call to &lt;function&gt; where &lt;variable2&gt; may be an array of wide characters, did you intend to use character count rather than byte count?
      This warning indicates that a parameter to a function call might incorrectly be a byte count instead of a character count. If this is the case, this defect is likely to cause a memory corruption or program crash, although some cases might cause an exploitable security hole.
      A common cause of this defect is using sizeof on a character array. The sizeof operator always computes the number of bytes. For ANSI characters this is the same as the number of characters; however, for Unicode characters it is twice the number of characters.
      It is usually safe to compute the number of elements in an array by dividing the size of the array by the size of each element.
      This warning is generated when:
      - A variable is passed as one parameter and sizeof that variable is passed as another parameter.
      - Both the variable type and the formal parameter type are some variety of pointer-to-wide char.
    </description>
    </rule>
    <rule key="C6211">
        <name>warning C6211: Leaking memory &lt;pointer&gt; due to an exception. Consider using a local catch block to clean up memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that allocated memory is not being freed when an exception is thrown. The statement at the end of the path could throw an exception. The analyzer checks for this condition only when the _Analysis_mode_(_Analysis_local_leak_checks_) SAL annotation is specified. By default, this annotation is specified for Windows kernel mode (driver) code. For more information about SAL annotations, see Using SAL Annotations to Reduce C/C++ Code Defects.
    </description>
    </rule>
    <rule key="C6214">
        <name>warning C6214: cast between semantically different integer types: HRESULT to a Boolean type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being cast to a Boolean type. The success value (S_OK) of an HRESULT equals 0. However, 0 indicates failure for a Boolean type. Casting an HRESULT to a Boolean type and then using it in a test expression will yield an incorrect result. Sometimes, this warning occurs if an HRESULT is being stored in a Boolean variable. Any comparison that uses the Boolean variable to test for HRESULT success or failure could lead to incorrect results.
    </description>
    </rule>
    <rule key="C6215">
        <name>warning C6215: cast between semantically different integer types: a Boolean type to HRESULT </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a Boolean is being cast to an HRESULT. Boolean types indicate success by a non-zero value, whereas success (S_OK) in HRESULT is indicated by a value of 0. Casting a Boolean type to an HRESULT and then using it in a test expression will yield an incorrect result.
      This warning frequently occurs when a Boolean is used as an argument to SUCCEEDED or FAILED macro, which explicitly casts their arguments to an HRESULT.
    </description>
    </rule>
    <rule key="C6216">
        <name>warning C6216: compiler-inserted cast between semantically different integral types: a Boolean type to HRESULT</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a Boolean is being used as an HRESULT without being explicitly cast. Boolean types indicate success by a non-zero value; success (S_OK) in HRESULT is indicated by a value of 0. The typical failure value for functions that return a Boolean false is a success status when it is tested as an HRESULT. This is likely to lead to incorrect results.
    </description>
    </rule>
    <rule key="C6217">
        <name>warning C6217: Implicit cast between semantically different integer types: testing HRESULT with &apos;not&apos;. Consider using SUCCEEDED or FAILED macro instead.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being tested with the not (!) operator. A success (S_OK) in HRESULT is indicated by a value of 0. However, 0 indicates failure for a Boolean type. Testing HRESULT with the not operator (!) to determine which code block to run can cause following the wrong code path. This will lead to unwanted results.
    </description>
    </rule>
    <rule key="C6219">
        <name>warning C6219: Implicit cast between semantically different integer types: comparing HRESULT to 1 or TRUE. Consider using SUCCEEDED or FAILED macro instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being compared with an explicit, non-HRESULT value of one (1). This is likely to lead to incorrect results because the typical success value of HRESULT (S_OK) is 0; comparing it to a Boolean type will implicitly convert it to false. 
    </description>
    </rule>
    <rule key="C6220">
        <name>warning C6220 - Implicit cast between semantically different integer types: comparing HRESULT to -1. Consider using SUCCEEDED or FAILED macro instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being compared with an explicit, non-HRESULT value of -1, which is not a well-formed HRESULT. A failure in HRESULT (E_FAIL) is not represented by a -1. Therefore, an implicit cast of an HRESULT to an integer will generate an incorrect value and is likely to lead to the wrong result.
    </description>
    </rule>
    <rule key="C6221">
        <name>warning C6221: Implicit cast between semantically different integer types: comparing HRESULT to an integer. Consider using SUCCEEDED or FAILED macros instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being compared to an integer other than zero. A success in HRESULT (S_OK) is represented by a 0. Therefore, an implicit cast of an HRESULT to an integer will generate an incorrect value and is likely to lead to the wrong result. It is often caused by mistakenly expecting a function to return an integer when it actually returns an HRESULT.
    </description>
    </rule>
    <rule key="C6225">
        <name>warning C6225: Implicit cast between semantically different integer types: assigning 1 or TRUE to HRESULT. Consider using S_FALSE instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being assigned or initialized with a value of an explicit 1. Boolean types indicate success by a non-zero value; success (S_OK) in HRESULT is indicated by a value of 0. This warning is frequently caused by accidental confusion of Boolean and HRESULT types. To indicate success, the symbolic constant S_OK should be used.
    </description>
    </rule>
    <rule key="C6226">
        <name>warning C6226: Implicit cast between semantically different integer types: assigning -1 to HRESULT. Consider using E_FAIL instead.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an HRESULT is being assigned or initialized with a value of an explicit -1. This warning is frequently caused by accidental confusion of integer and HRESULT types. To indicate success, the symbolic constant S_OK should be used. To indicate failure, the symbolic constants starting with E_constant should be used.
    </description>
    </rule>
    <rule key="C6230">
        <name>warning C6230: implicit cast between semantically different integer types: using HRESULT in a Boolean context </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a bare HRESULT is being used in a context, such as if statement, where a Boolean result is expected. This is likely to yield incorrect results. For example, the typical success value for HRESULT (S_OK) is false when it is tested as a Boolean.
    </description>
    </rule>
    <rule key="C6235">
        <name>warning C6235: (&lt;non-zero constant&gt; || &lt;expression&gt;) is always a non-zero constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a non-zero constant value, other than one, was detected on the left side of a logical-or operation that occurs in a test context. The right side of the logical-or operation is not evaluated because the resulting expression always evaluates to true. This is referred to as &quot;short-circuit evaluation.&quot;
      A non-zero constant value, other than one, suggests that the bitwise-AND operator (&amp;) may have been intended. This warning is not generated for the common idiom when the non-zero constant is 1, because of its use for selectively enabling code paths, but it is generated if the non-zero constant evaluates to 1, for example 1+0.
    </description>
    </rule>
    <rule key="C6236">
        <name>warning C6236: (&lt;expression&gt; || &lt;non-zero constant&gt;) is always a non-zero constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a non-zero constant value, other than one, was detected on the right side of a logical-or operation that occurs in a test context. The left side of the logical-or operation is not evaluated because the resulting expression always evaluates to true. This is referred to as &quot;short-circuit evaluation.&quot;
      A constant value other than one suggests that the bitwise-AND operator (&amp;) may have been intended. This warning is not generated for the common idiom when the non-zero constant is 1, because of its use for selectively enabling code paths, but it is generated if the non-zero constant evaluates to 1, for example 1+0.
    </description>
    </rule>
    <rule key="C6237">
        <name>warning C6237: (&lt;zero&gt; &amp;&amp; &lt;expression&gt;) is always zero. &lt;expression&gt; is never evaluated and may have side effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a constant value of zero was detected on the left side of a logical-and operation that occurs in a test context. The resulting expression always evaluates to false. Therefore, the right side of the logical-AND operation is not evaluated. This is referred to as &quot;short-circuit evaluation.&quot;
      You should examine the right side of the expression carefully to ensure that any side effects such as assignment, function call, increment, and decrement operations needed for proper functionality are not affected by the short-circuit evaluation.
      The expression (0 &amp;&amp; n) produces no side effects and is commonly used to selectively choose code paths.
    </description>
    </rule>
    <rule key="C6239">
        <name>warning C6239: (&lt;non-zero constant&gt; &amp;&amp; &lt;expression&gt;) always evaluates to the result of &lt;expression&gt;. Did you intend to use the bitwise-and operator?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a non-zero constant value, other than one, was detected on the left side of a logical-AND operation that occurs in a test context. For example, the expression ( 2 &amp;&amp; n ) is reduced to (!!n), which is the Boolean value of n.
      This warning typically indicates an attempt to check a bit mask in which the bitwise-AND (&amp;) operator should be used, and is not generated if the non-zero constant evaluates to 1 because of its use for selectively choosing code paths.
    </description>
    </rule>
    <rule key="C6240">
        <name>warning C6240: (&lt;expression&gt; &amp;&amp; &lt;non-zero constant&gt;) always evaluates to the result of &lt;expression&gt;. Did you intend to use the bitwise-and operator?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a non-zero constant value, other than one, was detected on the right side of a logical-and operation that occurs in a test context. For example, the expression (n &amp;&amp; 3) reduces to (!!n), which is the Boolean value of n.
      This warning typically indicates an attempt to check a bit mask in which the bitwise-AND (&amp;) operator should be used. It is not generated if the non-zero constant evaluates to 1 because of its use for selectively choosing code paths.
    </description>
    </rule>
    <rule key="C6242">
        <name>warning C6242: A jump out of this try-block forces local unwind. Incurs severe performance penalty</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a jump statement causes control-flow to leave the protected block of a try-finally other than by fall-through.
      Leaving the protected block of a try-finally other than by falling through from the last statement requires local unwind to occur. Local unwind typically requires approximately 1000 machine instructions; therefore, it is detrimental to performance.
      Use _leave to exit the protected block of a try-finally
    </description>
    </rule>
    <rule key="C6244">
        <name>warning C6244: local declaration of &lt;variable&gt; hides previous declaration at &lt;line&gt; of &lt;file&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a declaration has the same name as a declaration at an outer scope and hides the previous declaration. You will not be able to refer to the previous declaration from inside the local scope. Any intended use of the previous declaration will end up using the local declaration This warning only identifies a scope overlap and not lifetime overlap.
    </description>
    </rule>
    <rule key="C6246">
        <name>warning C6246: Local declaration of &lt;variable&gt; hides declaration of same name in outer scope. Additional Information: See previous declaration at &lt;location&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that two declarations have the same name at local scope. The name at outer scope is hidden by the declaration at the inner scope. Any intended use of the outer scope declaration will result in the use of local declaration.
    </description>
    </rule>
    <rule key="C6248">
        <name>warning C6248: setting a SECURITY_DESCRIPTOR&#8217;s DACL to NULL will result in an unprotected object</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning identifies a call that sets a SECURITY_DESCRIPTOR&apos;s DACL field to null. If the DACL that belongs to the security descriptor of an object is set to NULL, a null DACL is created. A null DACL grants full access to any user who requests it; normal security checking is not performed with respect to the object. A null DACL should not be confused with an empty DACL. An empty DACL is a properly allocated and initialized DACL that contains no ACEs. An empty DACL grants no access to the object it is assigned to.
      Objects that have null DACLs can have their security descriptors altered by malicious users so that no one has access to the object.
      Even if everyone needs access to an object, the object should be secured so that only administrators can alter its security. If only the creator needs access to an object, a DACL should not be set on the object; the system will choose an appropriate default.
    </description>
    </rule>
    <rule key="C6250">
        <name>warning C6250: Calling &lt;function&gt; VirtualFree without the MEM_RELEASE flag may free memory but not address descriptors (VADs); results in address space leaks</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a call to VirtualFree without the MEM_RELEASE flag only decommits the pages, and does not release them. To decommit and release pages, use MEM_RELEASE flag in call to VirtualFree. If any pages in the region are committed, the function first decommits and then releases them. After this operation, the pages are in the free state. If you specify this flag, dwSize must be zero, and lpAddress must point to the base address returned by the VirtualAlloc function when the region was reserved. The function fails if either of these conditions is not met.
      You can ignore this warning if your code later frees the address space by calling VirtualFree with the MEM_RELEASE flag.
      For more information see VirtualAlloc and VirtualFree.
      The use of VirtualAlloc and VirtualFree have many pitfalls in terms of memory leaks and exceptions. To avoid these kinds of leaks and exception problems altogether, use the mechanisms that are provided by the C++ Standard Template Library (STL). These include shared_ptr, unique_ptr, and vector. For more information, see Smart Pointers (Modern C++) and Standard C++ Library Reference.
    </description>
    </rule>
    <rule key="C6255">
        <name>warning C6255: _alloca indicates failure by raising a stack overflow exception. Consider using _malloca instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a call to _alloca has been detected outside of local exception handling. _alloca should always be called from within the protected range of an exception handler because it can raise a stack overflow exception on failure. If possible, instead of using _alloca, consider using _malloca which is a more secure version of _alloca.
    </description>
    </rule>
    <rule key="C6258">
        <name>warning C6258: using TerminateThread does not allow proper thread clean up.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a call to TerminateThread has been detected.
      TerminateThread is a dangerous function that should only be used in the most extreme cases. For more information about problems associated with TerminateThread call, see this topic in the MSDN Library: TerminateThread.
      To properly terminate threads
      - Create an event object using the CreateEvent function.
      - Create the threads.
      - Each thread monitors the event state by calling the WaitForSingleObject function.
      - Each thread ends its own execution when the event is set to the signaled state (WaitForSingleObject returns WAIT_OBJECT_0).
    </description>
    </rule>
    <rule key="C6259">
        <name>warning C6259: labeled code is unreachable: (&lt;expression&gt; &amp; &lt;constant&gt;) in switch-expr cannot evaluate to &lt;case-label&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates unreachable code caused by the result of a bitwise-AND (&amp;) comparison in a switch expression. The case statement that matches the constant in the switch expression is only reachable; all other case statements are not reachable.
    </description>
    </rule>
    <rule key="C6260">
        <name>warning C6260: sizeof * sizeof is almost always wrong, did you intend to use a character count or a byte count?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the results of two sizeof operations have been multiplied together. The C/C++ sizeof operator returns the number of bytes of storage an object uses. It is typically incorrect to multiply it by another sizeof operation; usually one is interested in the number of bytes in an object or the number of elements in an array (for example the number of wide-characters in an array).
      There is some unintuitive behavior associated with sizeof operator. For example, in C, the sizeof (&apos;\0&apos;) == 4, because a character is of an integral type. In C++, the type of a character literal is char, so sizeof (&apos;\0&apos;) == 1. 
    </description>
    </rule>
    <rule key="C6262">
        <name>warning C6262: Function uses &lt;constant&gt; bytes of stack: exceeds /analyze:stacksize&lt;constant 2&gt;. Consider moving some data to heap</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that stack usage that exceeds a preset threshold (constant 2) has been detected in a function. The default stack frame size for this warning is 16 KB for user mode, 1 KB for kernel mode. Stack&#8212;even in user mode&#8212;is limited, and failure to commit a page of stack causes a stack overflow exception. Kernel mode has a 12 KB stack size limit, which cannot be increased; therefore, kernel-mode code should aggressively limit stack use.
      To correct the problem behind this warning, you can either move some data to the heap or to other dynamic memory. In user mode, one large stack frame may not be a problem&#8212;and this warning may be suppressed&#8212;but a large stack frame increases the risk of a stack overflow. (A large stack frame might occur if the function uses the stack heavily or is recursive.) The total stack size in user mode can be increased if stack overflow actually occurs, but only up to the system limit. You can use the /analyze command-line option to change the value for &lt;constant 2&gt;, but increasing it introduces a risk that an error will not be reported.
      For kernel-mode code&#8212;for example, in driver projects&#8212;the value of &lt;constant 2&gt; is set to 1 KB. Well-written drivers should have very few functions that approach this value, and changing the limit downward may be desirable. The same general techniques that are used for user-mode code to reduce the stack size can be adapted to kernel-mode code.
    </description>
    </rule>
    <rule key="C6263">
        <name>warning C6263: using _alloca in a loop; this can quickly overflow stack</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that calling _alloca inside a loop to allocate memory can cause stack overflow. _alloca allocates memory from the stack, but that memory is only freed when the calling function exits. Stack, even in user-mode, is limited, and failure to commit a page of stack causes a stack overflow exception. The _resetstkoflw function recovers from a stack overflow condition, allowing a program to continue instead of failing with a fatal exception error. If the _resetstkoflw function is not called, there is no guard page after the previous exception. The next time that there is a stack overflow, there are no exceptions at all and the process terminates without warning.
      You should avoid calling _alloca inside a loop if either the allocation size or the iteration count is unknown because it might cause stack overflow. In these cases, consider other options such as, heap memory, or Standard C++ Library Reference classes.
    </description>
    </rule>
    <rule key="C6268">
        <name>warning C6268: Incorrect order of operations: (&lt;TYPE1&gt;)(&lt;TYPE2&gt;)x + y. Possible missing parentheses in (&lt;TYPE1&gt;)((&lt;TYPE2&gt;)x + y)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a complex cast expression might involve a precedence problem when performing pointer arithmetic. Because casts group more closely than binary operators, the result might not be what the programmer intended. In some cases, this defect causes incorrect behavior or a program crash.
      In an expression such as:
      (char *)p + offset
      the offset is interpreted as an offset in characters; however, an expression such as:
      (int *)(char *)p + offset
      is equivalent to:
      ((int *)(char *)p) + offset
      and so the offset is interpreted as an offset in integers. In other words, it is equivalent to:
      (int *)((char *)p + (offset * sizeof(int)))
      which is not likely to be what the programmer intended.
      Depending on the relative sizes of the two types, this can lead to a buffer overrun.
    </description>
    </rule>
    <rule key="C6269">
        <name>warning C6269: possible incorrect order of operations: dereference ignored</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the result of a pointer dereference is being ignored, which raises the question of why the pointer is being dereferenced in the first place.
      The compiler will correctly optimize away the gratuitous dereference. In some cases, however, this defect may reflect a precedence or logic error.
      One common cause for this defect is an expression statement of the form: *p++;
      If the intent of this statement is simply to increment the pointer p, then dereference is unnecessary; however, if the intent is to increment the location that p is pointing to, then the program will not behave as intended because *p++ construct is interpreted as * (p++). instead of (*p)++.
    </description>
    </rule>
    <rule key="C6270">
        <name>warning C6270: missing float argument to &lt;function&gt;: add a float argument corresponding to conversion specifier &lt;number&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that not enough arguments are being provided to match a format string; at least one of the missing arguments is a floating-point number. This defect can lead to crashes, in addition to potentially incorrect output
    </description>
    </rule>
    <rule key="C6271">
        <name>warning C6271: extra argument passed to &lt;function&gt;: parameter &lt;number&gt; is not used by the format string</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that additional arguments are being provided beyond those specified by the format string. By itself, this defect will not have any visible effect although it indicates that the programmer&apos;s intent is not reflected in the code.
    </description>
    </rule>
    <rule key="C6272">
        <name>warning C6272: non-float passed as argument &lt;number&gt; when float is required in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies that a float is required, for example, a %f or %g specification for printf, but a non-float such as an integer or string is being passed. This defect is likely to result in incorrect output; however, in certain circumstances it could result in a crash.
    </description>
    </rule>
    <rule key="C6273">
        <name>warning C6273 - non-integer passed as parameter &lt;number&gt; when integer is required in call to &lt;function&gt;: if a pointer value is being passed, %p should be used</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies an integer, for example, a %d, length or precedence specification for printf but a non-integer such as a float, string, or struct is being passed as a parameter. This defect is likely to result in incorrect output.
    </description>
    </rule>
    <rule key="C6274">
        <name>warning C6274: non-character passed as parameter &lt;number&gt; when character is required in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies that a character is required (for example, a %c or %C specification) but a non-integer such as a float, string, or struct is being passed. This defect is likely to cause incorrect output.
    </description>
    </rule>
    <rule key="C6276">
        <name>warning C6276: Cast between semantically different string types: char* to wchar_t*. Use of invalid string can lead to undefined behavior</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a potentially incorrect cast from an ANSI string (char_t*) to a UNICODE string (wchar_t *). Because UNICODE strings have a character size of 2 bytes, this cast might yield strings that are not correctly terminated. Using such strings with the wcs* library of functions could cause buffer overruns and access violations
    </description>
    </rule>
    <rule key="C6277">
        <name>warning C6277: NULL application name with an unquoted path in call to &lt;function&gt;: results in a security vulnerability if the path contains spaces</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the application name parameter is null and there might be spaces in the executable path name. In this case, unless the executable name is &quot;fully qualified,&quot; there is likely to be a security problem. A malicious user might insert a rogue executable with the same name earlier in the path. To correct this warning, you can specify the application name instead of passing null or if you do pass null for the application name, use quotation marks around the executable path.
    </description>
    </rule>
    <rule key="C6278">
        <name>warning C6278: &lt;variable&gt; is allocated with array new [], but deleted with scalar delete. Destructors will not be called</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning appears only in C++ code and indicates that the calling function has inconsistently allocated memory with the array new [] operator, but freed it with the scalar delete operator. This is undefined behavior according to the C++ standard and the Microsoft Visual C++ implementation. There are at least three reasons that this is likely to cause problems:
      - The constructors for the individual objects in the array are invoked, but the destructors are not invoked.
      - If global, or class-specific, operator new and operator delete are not compatible with operator new[] and operator delete[], unexpected results are likely to occur.
      - It is always very risky to rely on undefined behavior.
      The exact ramifications of this defect are difficult to predict. It might result in leaks for classes with destructors that perform memory de-allocation; inconsistent behavior for classes with destructors that perform some semantically significant operation; or memory corruptions and crashes when operators have been overridden. In other cases the mismatch might be unimportant, depending on the implementation of the compiler and its libraries. Analysis tool cannot always distinguish between these situations.
      If memory is allocated with array new [], it should be typically be freed with array delete[].
    </description>
    </rule>
    <rule key="C6279">
        <name>warning C6279: &lt;variable&gt; is allocated with scalar new, deleted with array delete [] </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning appears only in C++ code and indicates that the calling function has inconsistently allocated memory with the scalar new operator, but freed it with the array delete [] operator. If memory is allocated with scalar new, it should typically be freed with scalar delete.
      There are at least three reasons that this is likely to cause problems:
      - The constructors for the individual objects in the array are not invoked, although the destructors are.
      - If global (or class-specific) operator new and operator delete are not compatible with operator new[] and operator delete[], unexpected results are likely to occur.
      The exact ramifications of this defect are difficult to predict. It might cause random behavior or crashes due to usage of uninitialized memory because constructors are not invoked. Or, it might cause memory allocations and crashes in situations where operators have been overridden. In rare cases, the mismatch might be unimportant. Analysis tool does not currently distinguish between these situations.
    </description>
    </rule>
    <rule key="C6280">
        <name>warning C6280: &lt;variable&gt; is allocated with &lt;function&gt;, but deleted with &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the calling function has inconsistently allocated memory by using a function from one memory allocation family and freed it by using a function from another memory allocation family. The analyzer checks for this condition only when the _Analysis_mode_(_Analysis_local_leak_checks_) SAL annotation is specified. By default, this annotation is specified for Windows kernel mode (driver) code. For more information about SAL annotations, see Using SAL Annotations to Reduce C/C++ Code Defects.
      For example, this warning would be produced if memory is allocated by using malloc but freed by using GlobalFree or delete. In the specific cases of mismatches between array new[] and scalar delete, more precise warnings are reported instead of this one.
    </description>
    </rule>
    <rule key="C6281">
        <name>warning C6281 - incorrect order of operations: relational operators have higher precedence than bitwise operators</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a possible error in the operator precedence. This might produce incorrect results. You should check the precedence and use parentheses to clarify the intent. Relational operators (&lt;, &gt;, &lt;=, &gt;=, ==, != ) have higher precedence than bitwise operators (&amp; | ^). 
    </description>
    </rule>
    <rule key="C6282">
        <name>warning C6282: Incorrect operator: assignment of constant in Boolean context. Consider using &apos;==&apos; instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an assignment of a constant to a variable was detected in a test context. Assignment of a constant to a variable in a test context is almost always incorrect. Replace the = with ==, or remove the assignment from the test context to resolve this warning. 
    </description>
    </rule>
    <rule key="C6283">
        <name>warning C6283: &lt;variable&gt; is allocated with array new [], but deleted with scalar delete</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning appears only in C++ code and indicates that the calling function has inconsistently allocated memory with the array new [] operator, but freed it with the scalar delete operator. This defect might cause leaks, memory corruptions, and, in situations where operators have been overridden, crashes. If memory is allocated with array new [], it should typically be freed with array delete[].
    </description>
    </rule>
    <rule key="C6284">
        <name>warning C6284: object passed as parameter &apos;%d&apos; when string is required in call to &lt;function&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies a string, for example, a %s specification for printf or scanf, but a C++ object has been passed instead.
      This defect might produce incorrect output or crashes.
      This message is often reported due to passing a C++ object implementing some string type, for example, std::string, CComBSTR or bstr_t, into a C printf-style call. Depending on the implementation of the C++ class, that is, if the proper cast operators are defined, C++ string objects can often be used transparently whenever C strings are required; however, because parameters to printf-style functions are essentially untyped, no conversion to a string occurs.
      Depending on the object, it might be appropriate to insert a static_cast operator to the appropriate string type, for example, char * or TCHAR *, or to call a member function which returns a string, for example, c_str(), on instances of std::string.
    </description>
    </rule>
    <rule key="C6285">
        <name>warning C6285: (&lt;non-zero constant&gt; || &lt;non-zero constant&gt;) is always a non-zero constant. Did you intend to use the bitwise-and operator?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that two constant values, both greater than one, were detected as arguments to a logical-or operation that occurs in a test context. This expression is always TRUE.
      Constant values greater than one suggest that the arguments to logical-or could be bit fields. Consider whether a bitwise operator might be a more appropriate operator in this case.
    </description>
    </rule>
    <rule key="C6286">
        <name>warning C6286: (&lt;non-zero constant&gt; || &lt;expression&gt;) is always a non-zero constant. &lt;expression&gt; is never evaluated and may have side effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a non-zero constant was detected on the left side of a logical-or operation that occurs in a test context. The resulting expression always evaluates to TRUE. In addition, the right side of the expression appears to have side effects, and they will be lost.
      This warning indicates that you may want to examine the right side of the expression carefully to ensure that any side effects needed for proper functionality are not lost.
      The (!0 || &lt;expression&gt;) construction is commonly used to force execution of a controlled block.
    </description>
    </rule>
    <rule key="C6287">
        <name>warning C6287: redundant code: the left and right sub-expressions are identical</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a redundant element was detected in an expression.
      It is difficult to judge the severity of this problem without examining the code. A duplicate test on its own is harmless, but the consequences of deleting the second test can be severe. The code should be inspected to ensure that a test was not omitted.
    </description>
    </rule>
    <rule key="C6288">
        <name>warning C6288: Incorrect operator: mutual inclusion over &amp;&amp; is always zero. Did you intent to use || instead?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that in a test expression, a variable is being tested against two different constants and the result depends on both conditions being true. The code in these cases indicates that the programmer&apos;s intent is not captured correctly. It is important to examine the code and correct the problem; otherwise your code will not behave the way you expected it to.
      This problem is generally caused by using &amp;&amp;; in place of ||, but can also be caused by using == where != was intended.
    </description>
    </rule>
    <rule key="C6289">
        <name>warning C6289: Incorrect operator: mutual exclusion over || is always a non-zero constant. Did you intend to use &amp;&amp; instead?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that in a test expression a variable is being tested against two different constants and the result depends on either condition being true. This always evaluates to true.
      This problem is generally caused by using || in place of &amp;&amp;, but can also be caused by using != where == was intended. 
    </description>
    </rule>
    <rule key="C6290">
        <name>warning C6290: Bitwise operation on logical result: ! has higher precedence than &amp;. Use &amp;&amp; or (!(x &amp; y)) instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates possible confusion in the use of an operator or an operator precedence.
      The ! operator yields a Boolean result, and it has higher precedence than the &amp;.The bitwise-and (&amp;) operator takes two arithmetic arguments. Therefore, one of the following errors has been detected:
      - The expression is mis-parenthesised:
      Because the result of ! is Boolean (zero or one), an attempt to test that two variables have bits in common will only end up testing that the lowest bit is present in the right side: ((!8) &amp; 1) == 0.
      - The ! operator is incorrect, and should be a ~ instead:
      The ! operator has a Boolean result, while the ~ operator has an arithmetic result. These operators are never interchangeable, even when operating on a Boolean value (zero or one): ((!0x01) &amp; 0x10) == 0x0, while ((~0x01) &amp; 0x10) == 0x10.
      - The binary operator &amp; is incorrect, and should instead be &amp;&amp;:
      While &amp; can sometimes be interchanged with &amp;&amp;, it is not equivalent because it forces evaluation of the right side of the expression. Certain side effects in this type of expression can be terminal.
      It is difficult to judge the severity of this problem without examining the code. The code should be inspected to ensure that the intended test is occurring.
    </description>
    </rule>
    <rule key="C6291">
        <name>warning C6291: Bitwise operation on logical result: ! has higher precedence than |. Use || or (!(x | y)) instead</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The ! operator yields a Boolean result, and the | (bitwise-or) operator takes two arithmetic arguments. The ! operator also has higher precedence than |.
      Therefore, one of the following errors has been detected:
      - The expression is mis-parenthesised:
      Because the result of ! is Boolean (zero or one), an attempt to test that two variables have bits set will only end up testing that the lowest bit is present in the right side: ((!x) | y) != (!(x | y)) when x == 0 and y == 1.
      - The ! operator is incorrect, and should be a ~ instead:
      The ! operator has a Boolean result, but the ~ operator has an arithmetic result. These operators are never interchangeable, even when operating on a Boolean value (zero or one): ((!x) | y) != ((~x) | y) when x == 1 and y == 0.
      - The binary operator | is incorrect, and should instead be ||:
      Even though | can sometimes be interchanged with ||, it is not equivalent because it forces evaluation of the right side of the expression. Certain side-effects in this type of expression can be terminal: (!p | (*p == &apos;\0&apos;)), when p == NULL, we must dereference it to evaluate the other half of the expression.
      This warning is not reported if the ! operator is on the right side of the | operator because this case is typically just the relatively harmless case of an incorrect operator.
      It is difficult to judge the severity of this problem without examining the code. The code should be inspected to ensure that the intended test is occurring.
      This warning always indicates possible confusion in the use of an operator or operator precedence.
    </description>
    </rule>
    <rule key="C6292">
        <name>warning C6292: ill-defined for-loop: counts up from maximum</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a for-loop might not function as intended.
      It occurs when a loop counts up from a maximum, but has a lower termination condition. This loop will terminate only after integer overflow occurs.
    </description>
    </rule>
    <rule key="C6293">
        <name>warning C6293: Ill-defined for-loop: counts down from minimum</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a for-loop might not function as intended. It occurs when a loop counts down from a minimum, but has a higher termination condition.
      A signed &#8212;or unsigned&#8212;index variable together with a negative increment will cause the loop to count negative until an overflow occurs. This will terminate the loop.
    </description>
    </rule>
    <rule key="C6294">
        <name>warning C6294: Ill-defined for-loop: initial condition does not satisfy test. Loop body not executed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a for-loop cannot be executed because the terminating condition is true. This warning suggests that the programmer&apos;s intent is not correctly captured.
    </description>
    </rule>
    <rule key="C6295">
        <name>warning C6295: Ill-defined for-loop: &lt;variable&gt; values are of the range &quot;min&quot; to &quot;max&quot;. Loop executed indefinitely</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a for-loop might not function as intended. The for-loop tests an unsigned value against zero (0) with &gt;=. The result is always true, therefore the loop is infinite. 
    </description>
    </rule>
    <rule key="C6296">
        <name>warning C6296: Ill-defined for-loop: Loop body only executed once</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a for-loop might not function as intended. When the index is unsigned and a loop counts down from zero, its body is run only once. 
    </description>
    </rule>
    <rule key="C6297">
        <name>warning C6297: Arithmetic overflow: 32-bit value is shifted, then cast to 64-bit value. Result may not be an expected value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates incorrect behavior that results from integral promotion rules and types larger than those in which arithmetic is typically performed.
      In this case, a 32-bit value was shifted left, and the result of that shift was cast to a 64-bit value. If the shift overflowed the 32-bit value, bits are lost.
      If you do not want to lose bits, cast the value to be shifted to a 64-bit quantity before it is shifted. If you want to lose bits, performing the appropriate cast to unsigned long or a short type, or masking the result of the shift will eliminate this warning and make the intent of the code more clear.
    </description>
    </rule>
    <rule key="C6298">
        <name>warning C6298: using a read-only string &lt;pointer&gt; as a writable string argument: this will attempt to write into static read-only memory and cause random crashes</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates the use of a constant string as an argument to a function that might modify the contents of that string. Because the compiler allocates constant strings in a static read-only memory, any attempts to modify it cause access violations and random crashes.
      This can be avoided by storing the constant string into a local array and then using the array as the argument to the function.
    </description>
    </rule>
    <rule key="C6299">
        <name>warning C6299: explicitly comparing a bit field to a Boolean type will yield unexpected results</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an incorrect assumption that Booleans and bit fields are equivalent. Assigning 1 to bit fields will place 1 in its single bit; however, any comparison of this bit field to 1 includes an implicit cast of the bit field to a signed int. This cast will convert the stored 1 to a -1 and the comparison can yield unexpected results.
    </description>
    </rule>
    <rule key="C6302">
        <name>warning C6302: format string mismatch: character string passed as parameter &lt;number&gt; when wide character string is required in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies that a wide character string is required. However, a character string is being passed. This defect is likely to cause a crash or a corruption of some form.
    </description>
    </rule>
    <rule key="C6303">
        <name>warning C6303: format string mismatch: wide character string passed as parameter &lt;number&gt; when character string is required in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the format string specifies that a character string is required. However, a wide character string is being passed. This defect is likely to cause a crash or corruption of some form.
    </description>
    </rule>
    <rule key="C6305">
        <name>warning C6305: potential mismatch between sizeof and countof quantities</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a variable holding a sizeof result is being added to or subtracted from a pointer or countof expression. This will cause unexpected scaling in pointer arithmetic.
    </description>
    </rule>
    <rule key="C6306">
        <name>warning C6306: incorrect call to &lt;function&gt;: consider using &lt;function&gt; which accepts a va_list as an argument</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an incorrect function call. The printf family includes several functions that take a variable list of arguments; however, these functions cannot be called with a va_list argument. There is a corresponding vprintf family of functions that can be used for such calls. Calling the wrong print function will cause incorrect output.
    </description>
    </rule>
    <rule key="C6308">
        <name>warning C6308: &apos;realloc&apos; may return null pointer: assigning a null pointer to &lt;variable&gt;, which is passed as an argument to &apos;realloc&apos;, will cause the original memory block to be leaked</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a memory leak that is the result of the incorrect use of a reallocation function. Heap reallocation functions do not free the passed buffer if reallocation is unsuccessful. To correct the defect, assign the result of the reallocation function to a temporary, and then replace the original pointer after successful reallocation.
    </description>
    </rule>
    <rule key="C6309">
        <name>warning C6309: argument &lt;number&gt; is null: it does not adhere to function specification of &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This message indicates that the code is passing an unexpected NULL parameter as an argument to the specified API. Passing a null parameter to a function that expects a non-null parameter can cause unhandled exception.
    </description>
    </rule>
    <rule key="C6310">
        <name>warning C6310: illegal constant in exception filter can cause unexpected behavior</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This message indicates that an illegal constant was detected in the filter expression of a structured exception handler. The constants defined for use in the filter expression of a structured exception handler are:
      - EXCEPTION_CONTINUE_EXECUTION
      - EXCEPTION_CONTINUE_SEARCH
      - EXCEPTION_EXECUTE_HANDLER
      These values are defined in the runtime header file excpt.h.
      Using a constant that is not in the preceding list can cause unexpected behavior.
    </description>
    </rule>
    <rule key="C6312">
        <name>warning C6312: Possible infinite loop: use of the constant EXCEPTION_CONTINUE_EXECUTION in the exception-filter expression of a try-except</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates the use of the constant EXCEPTION_CONTINUE_EXECUTION (or another constant that evaluates to -1) in the filter expression of a structured exception handler. Use of the constant value EXCEPTION_CONTINUE_EXECUTION could lead to an infinite loop. For example, if an exception was raised by hardware, the instruction that caused the exception will be restarted. If the address that caused the exception is still bad, another exception will occur and be handled in the same way. This causes an infinite loop.
      An explicit call to RaiseException will not directly cause an infinite loop, but it will continue execution of the code in the protected block. This can be unexpected, and could lead to an infinite loop if RaiseException was used to avoid dereferencing an invalid pointer.
      Typically, EXCEPTION_CONTINUE_EXECUTION should be returned only by a function called in the filter expression, which has a chance to fix either the pointer that caused the exception or the underlying memory.
    </description>
    </rule>
    <rule key="C6313">
        <name>warning C6313: Incorrect operator: Zero-valued flag cannot be tested with bitwise-and. Use an equality test to check for zero-valued flags</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a constant value of zero was provided as an argument to the bitwise-and (&amp;) operator in a test context. The resulting expression is constant and evaluates to false; the result is different than intended.
      This is typically caused by using bitwise-and to test for a flag that has the value zero. To test zero-valued flags, a test for equality must be performed, for example, using == or !=.
    </description>
    </rule>
    <rule key="C6314">
        <name>warning C6314: Incorrect order of operations: bitwise-or has higher precedence than the conditional-expression operator. Add parentheses to clarify intent</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This message indicates that an expression that contains a bitwise-or operator (|) was detected in the tested expression of a conditional operation (?:).
      The conditional operator has lower precedence than bitwise operators. If the tested expression should contain the bitwise-or operator, then parentheses should be added around the conditional-expression.
    </description>
    </rule>
    <rule key="C6315">
        <name>warning C6315: Incorrect order of operations: bitwise-and has higher precedence than bitwise-or. Add parentheses to clarify intent</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an expression in a test context contains both bitwise-and (&amp;) and bitwise-or (|) operations, but causes a constant because the bitwise-or operation happens last. Parentheses should be added to clarify intent.
    </description>
    </rule>
    <rule key="C6316">
        <name>warning C6316: Incorrect operator: tested expression is constant and non-zero. Use bitwise-and to determine whether bits are set</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates the use of bitwise-or (|) when bitwise-and (&amp;) should have been used. Bitwise-or adds bits to the resulting expression, whereas bitwise-and selects only those bits in common between its two operators. Tests for flags must be performed with bitwise-and or a test of equality.
    </description>
    </rule>
    <rule key="C6317">
        <name>warning C6317: incorrect operator: logical-not (!) is not interchangeable with ones-complement (~)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a logical-not (!) is being applied to a constant that is likely to be a bit-flag. The result of logical-not is Boolean; it is incorrect to apply the bitwise-and (&amp;) operator to a Boolean value. Use the ones-complement (~) operator to flip flags.
    </description>
    </rule>
    <rule key="C6318">
        <name>warning C6318: Ill-defined __try/__except: use of the constant EXCEPTION_CONTINUE_SEARCH. The code in the exception handler block is not executed</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6318: Ill-defined __try/__except: use of the constant EXCEPTION_CONTINUE_SEARCH or another constant that evaluates to zero in the exception-filter expression. The code in the exception handler block is not executed
      This warning indicates that if an exception occurs in the protected block of this structured exception handler, the exception will not be handled because the constant EXCECPTION_CONTINUE_SEARCH is used in the exception filter expression.
      This code is equivalent to the protected block without the exception handler block because the handler block is not executed.
    </description>
    </rule>
    <rule key="C6319">
        <name>warning C6319: use of the comma-operator in a tested expression causes the left argument to be ignored when it has no side-effects</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an ignored sub-expression in test context because of the comma-operator (,). The comma operator has left-to-right associativity. The result of the comma-operator is the last expression evaluated. If the left expression to comma-operator has no side effects, the compiler might omit code generation for the expression.
    </description>
    </rule>
    <rule key="C6320">
        <name>warning C6320: exception-filter expression is the constant EXCEPTION_EXECUTE_HANDLER. This may mask exceptions that were not intended to be handled</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates the side effect of using EXCEPTION_EXECUTE_HANDLER constant in __except block. In this case, the statement in the __except block will always execute to handle the exception, including exceptions you did not want to handle in a particular function. It is recommended that you check the exception before handling it.
    </description>
    </rule>
    <rule key="C6322">
        <name>warning C6322: empty _except block</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This message indicates that there is no code in the _except block. As a result, exceptions might go unhandled.
    </description>
    </rule>
    <rule key="C6323">
        <name>warning C6323 - use of arithmetic operator on Boolean type(s)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning occurs if arithmetic operators are used on Boolean data types. Use of incorrect operator might yield incorrect results. It also indicates that the programmer&apos;s intent is not reflected in the code.
    </description>
    </rule>
    <rule key="C6324">
        <name>warning C6324: potential incorrect use of &lt;function1&gt;: Did you intend to use &lt;function2&gt;?</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a string copy function was used where a string comparison function should have been used. Incorrect use of function can cause an unexpected logic error.
    </description>
    </rule>
    <rule key="C6326">
        <name>warning C6326: potential comparison of a constant with another constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a potential comparison of a constant with another constant, which is redundant code. You must check to make sure that your intent is properly captured in the code. In some cases, you can simplify the test condition to achieve the same result.
    </description>
    </rule>
    <rule key="C6327">
        <name>warning C6327: Potential buffer overrun: SysAllocStringLen copies &lt;number&gt; characters from the string &lt;variable&gt; without validating the number of characters to copy. The code may crash</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a potential buffer overrun. SysAllocStringLen allocates a string and then copies the specified number of characters from the specified string. Because SysAllocStringLen does not validate the number of characters to copy, if the number of characters specified is larger than the number of characters in the string, the code might crash. You must pass correct number of characters to the SysAllocString function to avoid buffer overrun.
    </description>
    </rule>
    <rule key="C6328">
        <name>warning C6328: Size mismatch: &lt;type&gt; passed as parameter &lt;number&gt; when &lt;type&gt; is required in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      For C runtime character-based routines in the family name isxxx(), passing an argument of type char can have unpredictable results. For example, an SBCS or MBCS single-byte character of type char with a value greater than 0x7F is a negative value. If a char is passed, the compiler might convert the value to a signed int or a signed long. This value could be sign-extended by the compiler, with unexpected results. For example, isspace accepts an argument of type int; however, the valid range of values for its input argument is:
      0 &lt;= c &lt;= 255, plus the special value EOF.
    </description>
    </rule>
    <rule key="C6329">
        <name>warning C6329: Return value for a call to &lt;function&gt; should not be checked against &lt;number&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The program is comparing a number against the return value from a call to CreateFile. If CreateFile succeeds, it returns an open handle to the object. If it fails, it returns INVALID_HANDLE_VALUE.
    </description>
    </rule>
    <rule key="C6330">
        <name>warning C6330: Incorrect type passed as parameter in call to function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6330: Incorrect type passed as parameter in call to function
    </description>
    </rule>
    <rule key="C6331">
        <name>warning C6331: Invalid parameter: passing MEM_RELEASE and MEM_DECOMMIT in conjunction to &lt;function&gt; is not allowed. This results in the failure of this call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This message indicates that an invalid parameter being passed to VirtualFree or VirtualFreeEx. VirtualFree and VirtualFreeEx both reject the flags (MEM_RELEASE | MEM_DECOMMIT) in combination. Therefore, the values MEM_DECOMMIT and MEM_RELEASE may not be used together in the same call.
      It is not required for decommit and release to occur as independent steps. Releasing committed memory will decommit the pages as well. Also, ensure the return value of this function is not ignored. 
    </description>
    </rule>
    <rule key="C6332">
        <name>warning C6332: Invalid parameter: passing zero as the dwFreeType parameter to &lt;function&gt; is not allowed. This results in the failure of this call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an invalid parameter is being passed to VirtualFree or VirtualFreeEx. VirtualFree and VirtualFreeEx both reject a dwFreeType parameter of zero. The dwFreeType parameter can be either MEM_DECOMMIT or MEM_RELEASE. However, the values MEM_DECOMMIT and MEM_RELEASE may not be used together in the same call. Also, make sure that the return value of the VirtualFree function is not ignored. 
    </description>
    </rule>
    <rule key="C6333">
        <name>warning C6333: Invalid parameter: passing MEM_RELEASE and a non-zero dwSize parameter to &lt;function&gt; is not allowed. This results in the failure of this call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an invalid parameter is being passed to VirtualFree or VirtualFreeEx. Both of these functions reject a dwFreeType of MEM_RELEASE with a non-zero value of dwSize. When passing MEM_RELEASE, the dwSize parameter must be zero. Also, make sure that the return value of this function is not ignored. 
    </description>
    </rule>
    <rule key="C6334">
        <name>warning C6334: sizeof operator applied to an expression with an operator may yield unexpected results</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a misuse of the sizeof operator. The sizeof operator, when applied to an expression, yields the size of the type of the resulting expression.
    </description>
    </rule>
    <rule key="C6335">
        <name>warning C6335: leaking process information handle &lt;handlename&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the process information handles returned by the CreateProcess family of functions need to be closed using CloseHandle. Failure to do so will cause handle leaks.
    </description>
    </rule>
    <rule key="C6336">
        <name>warning C6336: arithmetic operator has precedence over question operator, use parentheses to clarify intent</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates a possible operator precedence problem. The &apos;+&apos;,&apos;-&apos;,&apos;*&apos; and &apos;/&apos; operators have precedence over the &apos;?&apos; operator. If the precedence in the expression is not correct, use parentheses to change the operator precedence.
    </description>
    </rule>
    <rule key="C6340">
        <name>warning C6340: Mismatch on sign: Incorrect type passed as parameter in call to function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6340: Mismatch on sign: Incorrect type passed as parameter in call to function
    </description>
    </rule>
    <rule key="C6381">
        <name>warning C6381: Shutdown API &lt;function&gt; requires a valid dwReason or lpMessage</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is issued if InitiateSystemShutdownEx is called:
      - Without passing a valid shutdown reason (dwReason). If dwReason parameter is zero, the default is an undefined shutdown. By default, it is also an unplanned shutdown. You should use one of the System Shutdown Reason Codes for this parameter.
      - Without passing a shutdown message (lpMessage).
      We recommend that you use appropriate parameters when calling this API to help system administrators determine the cause of the shutdown.
    </description>
    </rule>
    <rule key="C6383">
        <name>warning C6383: buffer overrun due to conversion of an element count into a byte count: an element count is expected for parameter &lt;number&gt; in call to &lt;function&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a non-constant byte count is being passed when an element count is required. Typically, this occurs when a variable is multiplied by the sizeof a type, but code analysis suggests that an element count is required.
    </description>
    </rule>
    <rule key="C6384">
        <name>warning C6384: dividing sizeof a pointer by another value</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a size calculation might be incorrect. To calculate the number of elements in an array, one sometimes divides the size of the array by the size of the first element; however, when the array is actually a pointer, the result is typically different than intended.
      If the pointer is a function parameter and the size of the buffer was not passed, it is not possible to calculate the maximum buffer available. When the pointer is allocated locally, the size used in the allocation should be used.
    </description>
    </rule>
    <rule key="C6385">
        <name>warning C6385: invalid data: accessing &lt;buffer name&gt;, the readable size is &lt;size1&gt; bytes, but &lt;size2&gt; bytes may be read: Lines: x, y</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the readable extent of the specified buffer might be smaller than the index used to read from it. Attempts to read data outside the valid range leads to buffer overrun.
    </description>
    </rule>
    <rule key="C6386">
        <name>warning C6386: buffer overrun: accessing &lt;buffer name&gt;, the writable size is &lt;size1&gt; bytes, but &lt;size2&gt; bytes may be written: Lines: x, y</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the writable extent of the specified buffer might be smaller than the index used to write to it. This can cause buffer overrun.
    </description>
    </rule>
    <rule key="C6387">
        <name>warning C6387: &lt;argument&gt; may be &lt;value&gt;: this does not adhere to the specification for the function &lt;function name&gt;: Lines: x, y</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is raised if an annotated function parameter is being passed an unexpected value. For example, passing a potentially null value to a parameter that is marked with _In_ annotation generates this warning.
    </description>
    </rule>
    <rule key="C6388">
        <name>warning C6388: &lt;argument&gt; may not be &lt;value&gt;: this does not adhere to the specification for the function &lt;function name&gt;: Lines: x, y</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an unexpected value is being used in the specified context. This is typically reported for values passed as arguments to a function that does not expect it.
    </description>
    </rule>
    <rule key="C6400">
        <name>warning C6400: Using &lt;function name&gt; to perform a case-insensitive compare to constant string &lt;string name&gt;. Yields unexpected results in non-English locales</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a case-insensitive comparison to a constant string is being performed in a locale-dependent way, when, apparently, a locale-independent comparison was intended.
      The typical consequence of this defect is incorrect behavior in non-English speaking locales. For example, in Turkish, &quot;.gif&quot; will not match &quot;.GIF&quot;; in Vietnamese, &quot;LogIn&quot; will not match &quot;LOGIN&quot;.
      String comparisons should typically be performed with the CompareString function. To perform a locale-independent comparison on Windows XP, the first parameter should be the constant LOCALE_INVARIANT.
    </description>
    </rule>
    <rule key="C6401">
        <name>warning C6401: Using &lt;function name&gt; in a default locale to perform a case-insensitive compare to constant string &lt; string name&gt;. Yields unexpected results in non-English locales</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a case-insensitive comparison to a constant string is being performed when specifying the default locale; usually, a locale-independent comparison was intended.
      The typical consequence of this defect is incorrect behavior in non-English speaking locales. For example, in Turkish, &quot;.gif&quot; will not match &quot;.GIF&quot;; in Vietnamese, &quot;LogIn&quot; will not match &quot;LOGIN&quot;.
      The CompareString function takes a locale as an argument; however, passing in a default locale, for example, the constant LOCALE_USER_DEFAULT, will cause different behaviors in different locales, depending on the user&apos;s default. Usually, case-insensitive comparisons against a constant string should be performed in a locale-independent comparison.
    </description>
    </rule>
    <rule key="C6411">
        <name>Warning C6411: Potentially reading invalid data from the buffer.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the value of the index that is used to read from the buffer can exceed the readable size of the buffer. Because the code analysis tool reports this warning when it cannot reduce a complex expression that represents the buffer size, or the index used to access the buffer, this warning might be reported in error.
    </description>
    </rule>
    <rule key="C6412">
        <name>warning C6412: Potential buffer overrun while writing to buffer. The writable size is write_size bytes, but write_index bytes may be written.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the value of the index that is used to write to the buffer can exceed the writeable size of the buffer.
      Because the code analysis tool reports this warning when it cannot reduce a complex expression that represents the buffer size, or the index used to access the buffer, this warning might be reported in error.
    </description>
    </rule>
    <rule key="C6500">
        <name>warning C6500: invalid annotation: value for &lt;name&gt; property is invalid</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a property value used in the annotation is not valid. For example, it can occur if an incorrect level of dereference is used in the Deref property, or if you use a constant value that is larger than size_t for properties like ElementSize.
    </description>
    </rule>
    <rule key="C6501">
        <name>warning C6501: annotation conflict: &lt;name&gt; property conflicts with previously specified property</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates the presence of conflicting properties in the annotation. This typically occurs when multiple properties that serve similar purpose are used to annotate a parameter or return value. To correct the warning, you must choose the property that best addresses your need.
    </description>
    </rule>
    <rule key="C6503">
        <name>warning C6503: Invalid annotation: references and arrays may not be marked Null=Yes or Null=Maybe</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that Null property is incorrectly used on a reference or array type. A reference or array type holds the address of an object and must point to a valid object. Because reference and array types cannot be null, you must correct the error by either removing the Null property or by setting the Null property value to No.
    </description>
    </rule>
    <rule key="C6504">
        <name>warning C6504: invalid annotation: property may only be used on values of pointer, pointer-to-member, or array type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates the use of a property on an incompatible data type. For more information about data types supported by properties, see [NIB]Annotation Properties.
    </description>
    </rule>
    <rule key="C6505">
        <name>warning C6505: invalid annotation: MustCheck property may not be used on values of void type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicated that MustCheck property was used on a void data type. You cannot use MustCheck property on void type. Either remove the MustCheck property or use another data type.
    </description>
    </rule>
    <rule key="C6506">
        <name>warning C6506: invalid annotation: &lt;name&gt; property may only be used on values of pointer or array types</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a property is used on a type other than pointer or array types. The Access, Tainted, and Valid properties can be used on all data types. Other properties, such as ValidBytesConst, ValidElementsConst, ElementSize, and NullTerminted support pointer, pointer to members, or array types. For a complete list of properties and the supported data types, see [NIB]Annotation Properties.
    </description>
    </rule>
    <rule key="C6507">
        <name>warning C6507: annotation conflict: Null property at Deref=0 on a post condition must be a subset of the Null property on the precondition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that conflicting values for the Null property were used in Pre- and Post- conditions at default dereference level 0. In this case the Pre condition specifies Null=No, and the Post condition specifies Null=Yes. Because the parameter is not passed by reference it cannot be changed; therefore, the Post condition cannot use Null=Yes.
    </description>
    </rule>
    <rule key="C6508">
        <name>warning C6508: invalid annotation: write access is not allowed on const values</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the Access property specified on a const parameter implies that it can be written to. For constant values, Access=Read is the only valid setting.
    </description>
    </rule>
    <rule key="C6509">
        <name>warning C6509: invalid annotation: &apos;return&apos; cannot be referenced from a precondition</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the return keyword cannot be used in a precondition. The return keyword is used to terminate the execution of a function and return control to the calling function. 
    </description>
    </rule>
    <rule key="C6510">
        <name>warning C6510: Invalid annotation: &apos;NullTerminated&apos; property may only be used on buffers whose elements are of integral or pointer type: Function &apos;&lt;function&gt;&apos; &lt;parameter&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an incorrect use of the NullTerminated property (those ending in &apos;_z&apos;). You can only use this type of property on pointer or array types.
    </description>
    </rule>
    <rule key="C6511">
        <name>warning C6511: invalid annotation: MustCheck property must be Yes or No</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an invalid value for MustCheck property was specified. The only valid values for this property are: Yes and No.
    </description>
    </rule>
    <rule key="C6512">
        <name>warning C6512: invalid annotation: Null property must be Maybe if the Valid property is No</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that Null is considered a valid value; therefore, Null cannot be used with the Valid property value of No.
    </description>
    </rule>
    <rule key="C6513">
        <name>warning C6513: invalid annotation: ElementSizeConst requires additional size properties</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that ElementSizeConst requires other properties that are missing from the annotation. Specifying ElementSizeConst alone does not provide any benefit to the analysis process. In addition to specifying ElementSize, other properties such as ValidElementsConst or WritableElementsConst must also be specified.
    </description>
    </rule>
    <rule key="C6514">
        <name>warning C6514: invalid annotation: value of the &lt;name&gt; property exceeds the size of the array</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a property value exceeds the size of the array specified in the parameter being annotated. This warning occurs when the value specified for the annotation property is greater than the actual length of the array being passed.
    </description>
    </rule>
    <rule key="C6515">
        <name>warning C6515 - invalid annotation: &lt;name&gt; property may only be used on values of pointer type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a property for use on pointers was applied to a non-pointer type. For a list of annotation properties, see [NIB]Annotation Properties.
    </description>
    </rule>
    <rule key="C6516">
        <name>warning C6516: invalid annotation: no properties specified for &lt;name&gt; attribute</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that either no property was specified in the attribute or the property that was specified is invalid; therefore, the attribute cannot be considered complete.
    </description>
    </rule>
    <rule key="C6517">
        <name>warning C6517: Invalid annotation: &apos;SAL_readableTo&apos; property may not be specified on buffers that are not readable: &apos;_Param_(1)&apos;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that SAL_readableTo property does not have the required read access. You cannot use this property to annotate a parameter without providing read access.
    </description>
    </rule>
    <rule key="C6518">
        <name>warning C6518: Invalid annotation: &apos;SAL_writableTo&apos; property may not be specified as a precondition on buffers that are not writable: &apos;_Param_(1)&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a conflict exists between a SAL_writableTo property value and a writable property. This ordinarily indicates that a writable property does not have write access to the parameter being annotated. 
    </description>
    </rule>
    <rule key="C6521">
        <name>warning C6521: invalid size specification: * operator can only be applied to pointer types</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an incorrect use of the * operator in an annotation property that accepts the size of a parameter in terms of another parameter. This warning is generated if the size parameter is a non-pointer type and a * operator is used to dereference it. However, you can use the * operator if the size parameter is passed as pointer type.
    </description>
    </rule>
    <rule key="C6522">
        <name>warning C6522: invalid size specification: expression must be of integral type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an integral type was expected, but an incorrect data type was used. You can use annotation properties that accept the size of a parameter in terms of another parameter, but you must use correct data type. For a list of annotation properties, see [NIB]Annotation Properties.
    </description>
    </rule>
    <rule key="C6523">
        <name>warning C6523: invalid size specification: parameter &lt;name&gt; not found</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter used to set a property value is not in the function parameter list. You can use annotation properties that accept the name of a parameter as their value, but you must make sure that the parameter exists and is of the correct data type.
    </description>
    </rule>
    <rule key="C6525">
        <name>warning C6525: invalid size specification: property value may not be valid</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the property value used to specify the size is not valid. This occurs if the size parameter is annotated using Valid=No.
    </description>
    </rule>
    <rule key="C6526">
        <name>warning C6526 - invalid size specification: expression must be of array or pointer type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an incorrect data type is used to specify a property value. A property might support all data types or a subset of them. In this case, the value specified for the property must be an array or a pointer type. For a list of annotation properties, see Annotation Properties. 
    </description>
    </rule>
    <rule key="C6527">
        <name>warning C6527: Invalid annotation: NeedsRelease property may not be used on values of void type</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6527: Invalid annotation: NeedsRelease property may not be used on values of void type
    </description>
    </rule>
    <rule key="C6530">
        <name>warning C6530: unrecognized format string style &lt;name&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the FormatString property is using a value other than scanf or printf. To correct this warning, review your code and use a valid value for the Style property.
    </description>
    </rule>
    <rule key="C6535">
        <name>warning C6535: buffer cannot be of size &lt;n&gt;, bigger than max(size_t)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the size of the buffer cannot be more than size_t. The type size_t is defined as an unsigned integer and its actual size is system dependent.
    </description>
    </rule>
    <rule key="C6540">
        <name>warning C6540: The use of attribute annotations on this function will invalidate all of its existing __declspec annotations</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6540: The use of attribute annotations on this function will invalidate all of its existing __declspec annotations
    </description>
    </rule>
    <rule key="C6551">
        <name>warning C6551: Invalid size specification: expression not parsable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6551: Invalid size specification: expression not parsable
    </description>
    </rule>
    <rule key="C6552">
        <name>warning C6552: Invalid Deref= or Notref=: expression not parsable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6552: Invalid Deref= or Notref=: expression not parsable
    </description>
    </rule>
    <rule key="C6701">
        <name>warning C6701: The value is not a valid Yes/No/Maybe value: &lt;string&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C6702">
        <name>warning C6702: The value is not a string value: &lt;string&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C6703">
        <name>warning C6703: The value is not a number: &lt;string&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C6704">
        <name>warning C6704: Unexpected Annotation Expression Error: &lt;annotation&gt; [&lt;why&gt;]</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C6705">
        <name>warning C6705: Annotation error expected &lt;expected_number&gt; arguments for annotation &lt;parameter&gt; found &lt;actual_number&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C6706">
        <name>warning C6706: Unexpected Annotation Error for annotation &lt;annotation&gt;: &lt;why&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C6707">
        <name>warning C6707: Unexpected Model Error: &lt;why&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C6707: Unexpected Model Error: &lt;why&gt;
    </description>
    </rule>
    <rule key="C6995">
        <name>warning C6995: Failed to save XML Log file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the Code Analysis tool cannot create the defect log, which is the output of the code analysis.
      This error might indicate a disk error or indicate that you do not have permission to create a file in the specified directory.
    </description>
    </rule>
    <rule key="C26100">
        <name>warning C26100: Race condition. Variable &lt;var&gt; should be protected by lock &lt;lock&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The _Guarded_by_ annotation in the code specifies the lock to use to guard a shared variable. Warning C26100 is generated when the guard contract is violated.
    </description>
    </rule>
    <rule key="C26101">
        <name>warning C26101: Failing to use interlocked operation properly for variable &lt;var&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Windows APIs offer a variety of interlocked operations. Annotation _Interlocked_ specifies that a variable should only be accessed through an interlocked operation. Warning C26101 is issued when an access is not consistent with the _Interlocked_ annotation.
    </description>
    </rule>
    <rule key="C26105">
        <name>warning C26105: Lock order violation. Acquiring lock &lt;lock&gt; with level &lt;level&gt; causes order inversion.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Concurrency SAL supports lock levels. To declare a lock level, which is denoted by a string literal without double quotes, use _Create_lock_level_. You can impose an order of acquisition between two lock levels by using the annotation _Set_lock_level_order_(A,B), which states that locks that have level A must be acquired before locks that have level B. To establish a lock order hierarchy (a partial order among lock levels), use multiple _Set_lock_level_order_ annotations. To associate a lock with a lock level, use the _Set_lock_level_ annotation when you declare the lock. Warning C26105 is issued when a lock ordering violation is detected.
    </description>
    </rule>
    <rule key="C26110">
        <name>warning C26110: Caller failing to hold lock &lt;lock&gt; before calling function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      When a lock is required, make sure to clarify whether the function itself or its caller should acquire the lock. Warning C26110 is issued when there is a violation of the _Requires_lock_held_ annotation.
    </description>
    </rule>
    <rule key="C26111">
        <name>warning C26111: Caller failing to release lock &lt;lock&gt; before calling function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The annotation _Requires_lock_not_held_ imposes a precondition that the lock count for the specified lock cannot be greater than zero when the function is called. Warning C26111 is issued when a function fails to release the lock before it calls another function.
    </description>
    </rule>
    <rule key="C26112">
        <name>warning C26112: Caller cannot hold any lock before calling &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The annotation _Requires_no_locks_held_ imposes a precondition that the caller must not hold any lock while it calls the function. Warning C26112 is issued when a function fails to release all locks before it calls another function. 
    </description>
    </rule>
    <rule key="C26115">
        <name>warning C26115: Failing to release lock &lt;lock&gt; in function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Enforcement of syntactically scoped lock acquire and lock release pairs in C/C++ programs is not performed by the language. A function may introduce a locking side effect by making an observable modification to the concurrency state. For example, a lock wrapper function increments the number of lock acquisitions, or lock count, for a given lock.
      You can annotate a function that has a side effect from a lock acquire or lock release by using _Acquires_lock_ or _Releases_lock_, respectively. Without such annotations, a function is expected not to change any lock count after it returns. If acquires and releases are not balanced, they are considered to be orphaned. Warning C26115 is issued when a function introduces an orphaned lock.
    </description>
    </rule>
    <rule key="C26116">
        <name>warning C26116: Failing to acquire or to hold lock &lt;lock&gt; in &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Enforcement of syntactically scoped lock acquire and lock release pairs in C/C++ programs is not performed by the language. A function may introduce a locking side effect by making an observable modification to the concurrency state. For example, a lock wrapper function increments the number of lock acquisitions, or lock count, for a given lock.You can annotate a function that has a side effect from a lock acquire or lock release by using _Acquires_lock_ or _Requires_lock_held, respectively. Without such annotations, a function is expected not to change any lock count after it returns. If acquires and releases are not balanced, they are considered to be orphaned. Warning C26116 is issued when a function has been annotated with _Acquires_lock_, but it does not acquire a lock, or when a function is annotated with _Requires_lock_held and releases the lock.
    </description>
    </rule>
    <rule key="C26117">
        <name>warning C26117: Releasing unheld lock &lt;lock&gt; in function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Enforcement of syntactically scoped lock acquire and lock release pairs in C/C++ programs is not performed by the language. A function may introduce a locking side effect by making an observable modification to the concurrency state. For example, a lock wrapper function increments the number of lock acquisitions, or lock count, for a given lock.You can annotate a function that has a side effect from a lock acquire or lock release by using _Acquires_lock_ or _Releases_lock_, respectively. Without such annotations, a function is expected not to change any lock count after it returns. If acquires and releases are not balanced, they are considered to be orphaned. Warning C26117 is issued when a function that has not been annotated with _Releases_lock_ releases a lock that it doesn&apos;t hold, because the function must own the lock before it releases it.
    </description>
    </rule>
    <rule key="C26130">
        <name>warning C26130: Missing annotation _Requires_lock_held_(&lt;lock&gt;) or _No_competing_thread_ at function &lt;func&gt;. Otherwise it could be a race condition.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C26130: Missing annotation _Requires_lock_held_(&lt;lock&gt;) or _No_competing_thread_ at function &lt;func&gt;. Otherwise it could be a race condition. Variable &lt;var&gt; should be protected by lock &lt;lock&gt;.
      Warning C26130 is issued when the analyzer detects a potential race condition but infers that the function is likely to be run in a single threaded mode, for example, when the function is in the initialization stage based on certain heuristics. 
    </description>
    </rule>
    <rule key="C26135">
        <name>warning C26135: Missing annotation &lt;annotation&gt; at function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Warning C26135 is issued when the analyzer infers that a function is a lock wrapper function that has a lock acquire or lock release side effect. If the code is not intended to be a wrapper function, then either the lock is leaking (if the lock is being acquired) or it is being released incorrectly (if the lock is being released).
    </description>
    </rule>
    <rule key="C26140">
        <name>warning C26140: Undefined lock kind &lt;lock&gt; in annotation &lt;annotation&gt; on lock &lt;lock&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C26140: Undefined lock kind &lt;lock&gt; in annotation &lt;annotation&gt; on lock &lt;lock&gt;.
    </description>
    </rule>
    <rule key="C26160">
        <name>warning C26160: Caller possibly failing to hold lock &lt;lock&gt; before calling function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Warning C26160 resembles warning C26110 except that the confidence level is lower. For example, the function may contain annotation errors.
    </description>
    </rule>
    <rule key="C26165">
        <name>warning C26165: Possibly failing to release lock &lt;lock&gt; in function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Warning C26165 resembles warning C26115 except that the confidence level is lower. For example, the function may contain annotation errors.
    </description>
    </rule>
    <rule key="C26166">
        <name>warning C26166: Possibly failing to acquire or to hold lock &lt;lock&gt; in function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Warning C26166 resembles warning C26116 except that the confidence level is lower. For example, the function may contain annotation errors.
    </description>
    </rule>
    <rule key="C26167">
        <name>warning C26167: Possibly releasing unheld lock &lt;lock&gt; in function &lt;func&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Warning C26167 resembles warning C26117 except that the confidence level is lower. For example, the function may contain annotation errors.
    </description>
    </rule>
    <rule key="C28020">
        <name>warning C28020: The expression &lt;expr&gt; is not true at this call</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when the _Satisfies_ expression listed is not true. Frequently this indicates an incorrect parameter.
      If this occurs on a function declaration, the annotations indicate an impossible condition.
      
    </description>
    </rule>
    <rule key="C28021">
        <name>warning C28021: The parameter &lt;param&gt; being annotated with &lt;anno&gt; must be a pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when the object being annotated is not a pointer type. This annotation cannot be used with void or integral types.
    </description>
    </rule>
    <rule key="C28022">
        <name>warning C28022: The function class(es) &lt;classlist1&gt; on this function do not match the function class(es) &lt;classlist2&gt; on the typedef used to define it.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations. Both the typedef and the function itself have _Function_class_ annotations, but they do not match. If both are used they must match.
    </description>
    </rule>
    <rule key="C28023">
        <name>warning C28023: The function being assigned or passed should have a _Function_class_ annotation for at least one of the class(es) in: &lt;classlist&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is usually reported when only one function class is in use and a callback of the appropriate type is not declared.
      This warning is issued when the function on the left side of the assignment (or of the implied assignment, if this is a function call) is annotated to indicate that it is a driver-specific function type that uses the _Function_class_ annotation or a typedef that contains such an annotation. The function on the right side of the assignment does not have a _Function_class_ annotation. The function on the right should be annotated to be of the same type as the function on the left. This is usually best done by adding the declaration &lt;class1&gt; &lt;funcname1&gt; before the current first declaration of &lt;funcname2&gt;.
      
    </description>
    </rule>
    <rule key="C28024">
        <name>warning C28024: The function pointer being assigned to is annotated with the function class &lt;class&gt;, which is not contained in the function class(es) &lt;classlist&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when both functions were annotated with a function class, but the classes do not match.
      This warning is issued when a function pointer has a _Function_class_ annotation that specifies that only functions of a particular functional class should be assigned to it. In an assignment or implied assignment in a function call, the source and target must be of the same function class, but the function classes do not match.
      
    </description>
    </rule>
    <rule key="C28039">
        <name>warning C28039: The type of actual parameter &lt;operand&gt; should exactly match the type &lt;typename&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is usually reported when an enum formal was not passed a member of the enum, but may also be used for other types.
      Because C permits enums to be used interchangeably, and interchangeably with constants, it is easy to pass the wrong enum value to a function without an error.
      For enum types, if the type of an enum parameter is annotated with _Enum_is_bitflag_, arithmetic is permitted on the parameter. Otherwise the parameter must be of exactly the correct type. If a constant is strictly required, warning C28137 may also apply.
      This rule can be used for other parameter types as well; see the function documentation for why the types must match exactly.
      
    </description>
    </rule>
    <rule key="C28103">
        <name>warning C28103: Leaking resource</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified object contains a resource that has not been freed. A function being called has been annotated with __drv_acquiresResource or __drv_acquiresResourceGlobal and this warning indicates that the resource named in the annotation was not freed.
    </description>
    </rule>
    <rule key="C28104">
        <name>warning C28104: Resource that should have been acquired before function exit was not acquired</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A function that is intended to acquire a resource before it exits has exited without acquiring the resource. This warning indicates that the function is annotated with __drv_acquiresResource but does not return having actually acquired the resource. If this function is a wrapper function, a path through the function did not reach the wrapped function. If the failure to reach the wrapped function is because the function returned an error and did not actually acquire the resource, you might need to use a conditional annotation (__drv_when).
      If this function actually implements the acquisition of the resource, it might not be possible for PFD to detect that the resource is acquired. In that case, use a #pragma warning to suppress the error. You can probably place the #pragma on the line preceding the { that begins the function body. The calling functions still need the annotation, but the Code Analysis tool will not be able to detect that the resource was acquired.
    </description>
    </rule>
    <rule key="C28105">
        <name>Warning C28105: Leaking resource due to an exception</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The specified resource is not freed when an exception is raised. The statement specified by the path can raise an exception. This warning is similar to warning C28103, except that in this case an exception is involved.
    </description>
    </rule>
    <rule key="C28106">
        <name>Warning C28106: Variable already holds resource possibly causing leak</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A variable that contains a resource is used in a context in which a new value can be placed in the variable. If this occurs, the resource can be lost and not properly freed, causing a resource leak.
    </description>
    </rule>
    <rule key="C28107">
        <name>warning C28107: Resource must be held when calling function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A resource that the program must acquire before calling the function was not acquired when the function was called. As a result, the function call will fail. This warning is reported only when resources are acquired and released in the same function.
    </description>
    </rule>
    <rule key="C28108">
        <name>warning C28108: Variable holds an unexpected resource</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The resource that the driver is using is in the expected C language type, but has a different semantic type.
    </description>
    </rule>
    <rule key="C28109">
        <name>warning C28109: Variable cannot be held at the time function is called</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The program is holding a resource that should not be held when it is calling this function. Typically, it indicates that the resource was unintentionally acquired twice. The Code Analysis tool reports this warning when resources are acquired and released in the same function.
    </description>
    </rule>
    <rule key="C28112">
        <name>warning C28112: A variable which is accessed via an Interlocked function must always be accessed via an Interlocked function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      See line number: It is not always safe to access a variable which is accessed via the Interlocked* family of functions in any other way.
      A variable that is accessed by using the Interlocked executive support routines, such as InterlockedCompareExchangeAcquire, is later accessed by using a different method.Although certain ordinary assignments, accesses, and comparisons to variables that are used by the Interlocked* routines can be safely accessed by using a different method, the risk is great enough to justify examining each instance.
    </description>
    </rule>
    <rule key="C28113">
        <name>warning C28113: Accessing a local variable via an Interlocked function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The driver is using an Interlocked executive support routine, such as InterlockedDecrement, to access a local variable.
      Although drivers are permitted to pass the address of a local variable to another function, and then use an interlocked function to operate on that variable, it&apos;s important to verify that the stack will not be swapped out to disk unexpectedly and that the variable has the correct life time across all threads that might use it.
    </description>
    </rule>
    <rule key="C28125">
        <name>warning C28125: The function must be called from within a try/except block</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The driver is calling a function that must be called from within a try/except block, such as ProbeForRead, ProbeForWrite, MmProbeAndLockPages.
    </description>
    </rule>
    <rule key="C28137">
        <name>warning C28137: The variable argument should instead be a (literal) constant</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a function call is missing a required (literal) constant. Consult the documentation for the function.
    </description>
    </rule>
    <rule key="C28138">
        <name>warning C28138: The constant argument should instead be variable</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported in a function call that expects a variable or a non-constant expression, but the call includes a constant. For information about the function and its parameter, consult the WDK documentation of the function.
    </description>
    </rule>
    <rule key="C28159">
        <name>warning C28159: Consider using another function instead.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported for Drivers is suggesting that you use a preferred function call that is semantically equivalent to the function that the driver is calling. This is a general warning message; the annotation __drv_preferredFunction was used (possibly with a conditional a __drv_when() annotation) to flag a bad coding practice.
    </description>
    </rule>
    <rule key="C28160">
        <name>warning C28160: Error annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a __drv_error annotation has been encountered. This annotation is used to flag coding practices that should be fixed, and can be used with a __drv_when annotation to indicate specific combinations of parameters.
    </description>
    </rule>
    <rule key="C28163">
        <name>warning C28163: The function should never be called from within a try/except block</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a function is of a type that should never be enclosed in a try/except block is found in a try/except block. The code analysis tool found at least one path in which the function called was within a try/except block.
    </description>
    </rule>
    <rule key="C28164">
        <name>warning C28164: The argument is being passed to a function that expects a pointer to an object (not a pointer to a pointer)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a pointer to a pointer is used in a call to a function that is expecting a pointer to an object.
      The function takes a PVOID in this position. Usually, this indicates that &amp;pXXX was used when pXXX is required.
      Some polymorphic functions (functions that can evaluate to, and be applied to, values of different types) are implemented in C by using a PVOID argument that takes any pointer type. However, this allows the programmer to code a pointer to a pointer without causing a compiler error, even when this type is not appropriate.
    </description>
    </rule>
    <rule key="C28182">
        <name>warning C28182: Dereferencing NULL pointer.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Additional information: &lt;pointer1&gt; contains the same NULL value as &lt;pointer2&gt; did &lt;note&gt;
      The code analysis tool reports this warning when it confirms that the pointer can be NULL. If there are unconfirmed instances where the error might occur earlier in the trace, the code analysis tool adds the line number of the first instance to the warning message so that you can change the code to address all instances.
      &lt;pointer2&gt; is confirmed to be potentially NULL. &lt;pointer1&gt; contains the same value as pointer2 and is being dereferenced. Because these pointers may be at very different places in the code, both are reported so that you can determine why the code analysis tool is reporting this warning.
      If an unconfirmed earlier instance of the condition exists, then &lt;note&gt; is replaced by this text: &quot;See line &lt;number&gt; for an earlier location where this can occur.&quot;
    </description>
    </rule>
    <rule key="C28183">
        <name>warning C28183: The argument could be one value, and is a copy of the value found in the pointer</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that this value is unexpected in the current context. This warning usually appears when a NULL value is passed as an argument to a function that does not permit it. The value was actually found in the specified variable, and the argument is a copy of that variable.
      The Code Analysis tool reports this warning at the first point where it can definitively determine that the pointer is NULL or that it contains an illegal value. However, it is often the case that the error could actually occur earlier in the trace. When this happens, the Code Analysis tool will also give the line number of the first possible instance -- usually at a location where it could not definitively determine that the warning was appropriate. In those cases, the earlier location where this can occur is appended to the warning message. Typically, a code change should occur at or before that line number, rather than at the point of report.
    </description>
    </rule>
    <rule key="C28193">
        <name>warning C28193: The variable holds a value that must be examined</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the calling function is not checking the value of the specified variable, which was supplied by a function. The returned value is annotated with the _Check_return_ annotation, but the calling function is either not using the value or is overwriting the value without examining it.
      This warning is similar to warning C6031, but it is reported only when the code does not test or examine the value of the variable, such as by using it in a comparison. Simply assigning the value is not considered to be a sufficient examination to avoid this warning. Aliasing the result out of the function is considered a sufficient examination, but the result itself should be annotated with _Check_return_.
      Certain functions (such as strlen) exist almost exclusively for their return value, so it makes sense for them to have the _Check_return_ annotation. For these functions, the Code Analysis tool might report this warning when the return value is unused. This usually indicates that the code is incorrect, for example, it might contain residual code that could be deleted. However, in some rare instances, the return value is intentionally not used. The most common of these instances is where a string length is returned but not actually used before some other test is made. That other test causes a path to be simulated where the string length ends up being unused. When this happens, the code can be correct, but it might be inefficient.
      There are two primary strategies for dealing with these cases where the return value is unused:
      Reorder the code so that the string length is only returned along the path where it is needed.
      Use a #pragma warning to suppress the warning--if by reordering the code, you would make the code too complex or otherwise less useful.
    </description>
    </rule>
    <rule key="C28194">
        <name>warning C28194: The function was declared as aliasing the value in variable and exited without doing so</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the function prototype for the function being analyzed has a __drv_isAliased annotation, which indicates that it will alias the specified argument (that is, assign the value in a way that it will survive returning from the function). However, the function does not alias the argument along the path that is indicated by the annotation. Most functions that alias a variable save its value to a global data structure.
    </description>
    </rule>
    <rule key="C28195">
        <name>warning C28195: The function was declared as acquiring memory in a variable and exited without doing so</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the function prototype for the function being analyzed has a __drv_acquiresMemory annotation. The __drv_acquiresMemory annotation indicates that the function acquires memory in the designated result location, but in at least one path, the function did not acquire the memory. Note that the Code Analysis tool will not recognize the actual implementation of a memory allocator (involving address arithmetic) and will not recognize that memory is allocated (although many wrappers will be recognized). In this case, the Code Analysis tool does not recognize that the memory was allocated and issues this warning. To suppress the false positive, use a #pragma warning on the line that precedes the opening brace { of the function body
    </description>
    </rule>
    <rule key="C28196">
        <name>warning C28196: The requirement is not satisfied. (The expression does not evaluate to true.)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the function prototype for the function being analyzed has a __notnull, __null or __drv_valueIs on an _Out_ parameter or the return value, but the value returned is inconsistent with that annotation.
    </description>
    </rule>
    <rule key="C28197">
        <name>Warning C28197: Possibly leaking memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported for both memory and resource leaks when the resource is potentially aliased to another location.
      The pointer points to allocated memory or to another allocated resource that was not explicitly freed. This warning is usually due to inadequate annotations on the called function, although inadequate annotations on the calling function can also make this more likely.
      This warning can be reported on function exit if an input argument has a __drv_freesMem or __drv_aliasesMem annotation. This warning typically indicates either a valid leak or that a function called by the current function needs additional annotation.
      In particular, the absence of the basic _In_ and _Out_ annotations make this warning fairly likely, although the __drv_aliasesMem and __drv_freesMem annotations might be needed as well. A false positive is a likely result of a missing _In_ annotation.
      Functions that take a pointer and alias it (thus avoiding a leak) should be annotated with __drv_aliasesMem. If you create a function that inserts an object into a global structure, or passes it to a system function that does that, you should add the __drv_aliasesMem annotation.
      Functions that free memory should be annotated with __drv_freesMem. The major functions that free memory already have this annotation.
    </description>
    </rule>
    <rule key="C28198">
        <name>warning C28198: Possibly leaking memory due to an exception.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that allocated memory is not being freed after an exception is raised. The statement at the end of the path can raise an exception. The memory was passed to a function that might have saved a copy to be freed later.
      This warning is very similar to warning C28197. The annotations that are recommended for use with warning C28197 can also be used here.
    </description>
    </rule>
    <rule key="C28199">
        <name>warning C28199: Using possibly uninitialized memory</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This message indicates that the variable has had its address taken but no assignment to it has been discovered.
      The specified variable is being used without being explicitly initialized, but at some point its address was taken, indicating that it might be initialized invisibly to the Code Analysis tool.
      This warning can be mistaken if the variable is initialized outside of the function.
      The Code Analysis tool reports this warning on function exit if a parameter has an _Out_ or _Inout_ annotation and the variable is not initialized.
    </description>
    </rule>
    <rule key="C28202">
        <name>warning C28202: Illegal reference to non-static member</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C28203">
        <name>warning C28203: Ambiguous reference to class member. Could be &lt;name1&gt; or &lt;name2&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C28204">
        <name>warning C28204: &lt;function&gt; : Only one of this overload and the one at &lt;filename&gt;(&lt;line&gt;) are annotated for &lt;paramname&gt;: both or neither must be annotated.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C28205">
        <name>warning C28205: function&gt; : _Success_ or _On_failure_ used in an illegal context: &lt;why&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when there is an error in the annotations.
    </description>
    </rule>
    <rule key="C28206">
        <name>warning C28206: &lt;expression&gt; : left operand points to a struct, use -&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when the struct pointer dereference notation -&gt; was expected.
    </description>
    </rule>
    <rule key="C28207">
        <name>warning C28207: &lt;expression&gt;: left operand is a struct, use .</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a struct dereference dot (.) was expected.
    </description>
    </rule>
    <rule key="C28208">
        <name>warning C28208: Function &lt;function&gt; was previously defined with a different parameter list at &lt;file&gt;(&lt;line&gt;). Some analysis tools will yield incorrect results</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a function&#8217;s known definition doesn&#8217;t match another occurrence.
    </description>
    </rule>
    <rule key="C28209">
        <name>warning C28209: The declaration for symbol has a conflicting declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an incorrectly constructed annotation declaration. This warning should never occur in normal use.
    </description>
    </rule>
    <rule key="C28210">
        <name>warning C28210: Annotations for the _On_failure_ context must not be in explicit pre context</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Annotations _On_failure_ must be explicitly or implicitly indicated in __post context, that is, to be applied after the function returns. Use _drv_out to ensure this.
    </description>
    </rule>
    <rule key="C28211">
        <name>warning C28211: Static context name expected for SAL_context</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the operand to the _Static_context_ annotation must be the name of a tool-defined context. This warning should never occur in normal use.
    </description>
    </rule>
    <rule key="C28212">
        <name>warning C28212: Pointer expression expected for annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the numbered parameter to an annotation (not the function being annotated) is expected to be a pointer or array type, but some other type was encountered. The annotation needs to be corrected.
    </description>
    </rule>
    <rule key="C28213">
        <name>warning C28213: The _Use_decl_annotations_ annotation must be used to reference, without modification, a prior declaration. &lt;why&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when a prior declaration is referenced without the required _Use_decl_annotations_ annotation.
    </description>
    </rule>
    <rule key="C28214">
        <name>warning C28214: Attribute parameter names must be p1...p9</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that when you construct an annotation declaration, the parameter names are limited to p1...p9. This warning should never occur in normal use.
    </description>
    </rule>
    <rule key="C28215">
        <name>warning C28215: The typefix cannot be applied to a parameter that already has a typefix</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Applying a __typefix annotation to a parameter that already has that annotation is an error. The __typefix annotations are used only in a few special cases and this warning is not expected to be seen in normal use.
    </description>
    </rule>
    <rule key="C28216">
        <name>warning C28216: The _Check_return_ annotation only applies to post-conditions for the specific function parameter.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The _Check_return_ annotation has been applied in a context other than __post; it may need a __post (or __drv_out) modifier, or it may be placed incorrectly.
    </description>
    </rule>
    <rule key="C28217">
        <name>warning C28217: For function, the number of parameters to annotation does not match that found at file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The annotations on the current line and on the line in the message are inconsistent. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in normal use.
    </description>
    </rule>
    <rule key="C28218">
        <name>warning C28218: For function parameter, the annotation&apos;s parameter does not match that found at file</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The annotations on the current line and on the line in the message are inconsistent. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in normal use.
    </description>
    </rule>
    <rule key="C28219">
        <name>warning C28219: Member of enumeration expected for annotation the parameter in the annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A parameter to an annotation is expected to be a member of the named enum type, and some other symbol was encountered; use a member of that enum type. This usually indicates an incorrectly coded annotation macro.
    </description>
    </rule>
    <rule key="C28220">
        <name>warning C28220: Integer expression expected for annotation the parameter in the annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter to an annotation is expected to be an integer expression, and some other type was encountered. This usually indicates an incorrectly coded annotation macro.
    </description>
    </rule>
    <rule key="C28221">
        <name>warning C28221: String expression expected for the parameter in the annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter to an annotation is expected to be a string, and some other type was encountered. This usually indicates an incorrectly coded annotation macro and is not expected to be seen in normal use.
    </description>
    </rule>
    <rule key="C28222">
        <name>warning C28222: _Yes_, _No_, or _Maybe_ expected for annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter to an annotation is expected to be one of the symbols _Yes_, _No_, or _Maybe_, and some other symbol was encountered. This usually indicates an incorrectly coded annotation macro.
    </description>
    </rule>
    <rule key="C28223">
        <name>Warning C28223: Did not find expected Token/identifier for annotation, parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter to an annotation is expected to be an identifier, and some other symbol was encountered. This usually indicates an incorrectly coded annotation macro. The use of C or C++ keywords in this position will cause this error.
    </description>
    </rule>
    <rule key="C28224">
        <name>warning C28224: Annotation requires parameters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the named annotation is used without parameters and at least one parameter is required. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in normal use.
    </description>
    </rule>
    <rule key="C28225">
        <name>warning C28225: Did not find the correct number of required parameters in annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the named annotation is used with the incorrect number of parameters. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28226">
        <name>Warning C28226: Annotation cannot also be a PrimOp (in current declaration)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the named annotation is being declared as a PrimOp, and also was previously declared as a normal annotation. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in normal use.
    </description>
    </rule>
    <rule key="C28227">
        <name>Warning C28227: Annotation cannot also be a PrimOp (see prior declaration)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the named annotation is being declared as an ordinary annotation, and also was previously declared as a PrimOp. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28228">
        <name>warning C28228: Annotation parameter: cannot use type in annotations</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a parameter is of type that is not supported. Annotations can only use a limited set of types as parameters. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28229">
        <name>warning C28229: Annotation does not support parameters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an annotation was used with a parameter when the annotation is declared without parameters. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28230">
        <name>warning C28230: The type of parameter has no member.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an argument to an annotation attempts to access a struct, class, or union and the named member does not exist.
    </description>
    </rule>
    <rule key="C28231">
        <name>warning C28231: Annotation is only valid on array</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an argument to an annotation should be an array, and some other type was encountered.
    </description>
    </rule>
    <rule key="C28232">
        <name>warning C28232: _Pre_, _Post_, or _Deref_ not applied to any annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a _Pre_, _Post_, or _Deref_ operator appears in an annotation expression without a subsequent functional annotation; the modifier was ignored, but this indicates an incorrectly coded annotation.
    </description>
    </rule>
    <rule key="C28233">
        <name>warning C28233: pre, post, or deref applied to a block</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C28233: pre, post, or deref applied to a block
    </description>
    </rule>
    <rule key="C28234">
        <name>warning C28234: _At_ expression does not apply to current function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that the value of an _At_ expression does not identify an accessible object.
    </description>
    </rule>
    <rule key="C28235">
        <name>warning C28235: The function cannot stand alone as an annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an attempt was made to use a function that was not declared to be an annotation in an annotation context. This includes using a primitive operation (PrimOp) in a standalone context. This should not be possible if the standard macros are being used for annotations. This warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28236">
        <name>warning C28236: The annotation cannot be used in an expression</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that an attempt was made to use a function declared to be an annotation in an expression context. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28237">
        <name>warning C28237: The annotation on parameter is no longer supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An internal error has occurred in the PREfast model file. This warning should not occur in typical use.
    </description>
    </rule>
    <rule key="C28238">
        <name>warning C28238: The annotation on parameter has more than one of value, stringValue, and longValue. Use paramn=xxx</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An internal error has occurred in the PREfast model file. This warning should not occur in typical use.
    </description>
    </rule>
    <rule key="C28239">
        <name>warning C28239: The annotation on parameter has both value, stringValue, or longValue; and paramn=xxx. Use only paramn=xxx</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An internal error has occurred in the PREfast model file. This warning should not occur in typical use.
    </description>
    </rule>
    <rule key="C28240">
        <name>warning C28240: The annotation on parameter has param2 but no param1</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An internal error has occurred in the PREfast model file. This warning should not occur in typical use.
    </description>
    </rule>
    <rule key="C28241">
        <name>warning C28241: The annotation for function on parameter is not recognized</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An unrecognized annotation name was used. This should not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28243">
        <name>warning C28243: The annotation for function on parameter requires more dereferences than the actual type annotated allows</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The number of __deref operators on an annotation is more than the number of levels of pointer defined by the parameter type. Correct this warning by changing either the number in the annotation or the pointer levels of the parameter referenced.
    </description>
    </rule>
    <rule key="C28244">
        <name>warning C28244: The annotation for function has an unparseable parameter/external annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This should currently not be possible if the standard macros are being used for annotations; this warning is not expected to be seen in typical use.
    </description>
    </rule>
    <rule key="C28245">
        <name>warning C28245: The annotation for function annotates &apos;this&apos; on a non-member-function</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      An internal error has occurred in the PREfast model file. This warning should not occur in typical use.
    </description>
    </rule>
    <rule key="C28246">
        <name>warning C28246: The annotation for function &apos;&lt;name&gt;&apos; - parameter &apos;&lt;parameter&gt;&apos; does not match the type of the parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      A __deref operator was applied to a non-pointer type when creating an annotation.
    </description>
    </rule>
    <rule key="C28250">
        <name>warning C28250: Inconsistent annotation for function: the prior instance has an error.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Note: There are several prototypes for this function. This warning compares the first prototype with instance number &lt;number&gt;.
      If a declaration is made using a typedef, the line where the typedef appears is more useful than the line of the declaration.
      This warning refers to an error in the annotation and reflects the requirement that the annotations on a function declaration must match those on the definition, except if a function typedef is involved. In that case, the function typedef is taken as definitive for both the declaration and the definition.
      Note that annotations are usually implemented as macros, and one macro will usually yield several low-level annotations. This warning is reported for each unmatched low-level annotation, so a single unmatched annotation macro may yield a number of unmatched low-level annotations. It is best to simply compare the declaration and definition source code to make sure that they are the same. (Trivial differences in the order of the annotations are not reported.)
      The comparison is always between the first declaration found and the current one. If there are additional declarations, each declaration is checked pairwise. It is currently not possible to do a comparison other than in pairs, although it is possible to identify that there are more than two declarations/definitions. The text field above contains a list of the annotations that differ (at a fairly low level) between the two instances.
      This warning message displays the text of the underlying code sent to the compiler, and not the macros that are used to actually insert the annotation in the source code (as is the case whenever macros are used). In general, you do not need to understand the low-level annotations, but you should recognize that the annotations are being reported as inconsistent between the line numbers reported in the error message. Mostly, an inspection of the source code will make it clear why the inconsistency exists.
    </description>
    </rule>
    <rule key="C28251">
        <name>warning C28251: Inconsistent annotation for function: this instance has an error</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning refers to an error in the annotation and reflects the requirement that the annotations on a function declaration must match those on the definition, except if a function typedef is involved. In that case, the function typedef is taken as definitive for both the declaration and the definition.
      Note that annotations are usually implemented as macros, and one macro will usually yield several low-level annotations. This warning is reported for each unmatched low-level annotation, so a single unmatched annotation macro may yield a number of unmatched low-level annotations. It is best to simply compare the declaration and definition source code to make sure that they are the same. (Trivial differences in the order of the annotations are not reported.)
      The comparison is always between the first declaration found and the current one. If there are additional declarations, then each declaration is checked in groups of two. It is currently not possible to do a comparison other than in pairs, although it is possible to identify that there are more than two declarations/definitions. The text field above contains a list of the annotations that differ (at a fairly low level) between the two instances.
      This warning message displays the text of the underlying code sent to the compiler, and not the macros that are used to actually insert the annotation in the source code (as is the case whenever macros are used). In general, you do not need to understand the low-level annotations, but you should recognize that the annotations are being reported as inconsistent between the line numbers reported in the error message. Mostly, an inspection of the source code will make it clear why the inconsistency exists.
    </description>
    </rule>
    <rule key="C28252">
        <name>warning C28252: Inconsistent annotation for function: parameter has another annotation on this instance</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning refers to an error in the annotation and reflects the requirement that the annotations on a function declaration must match those on the definition, except if a function typedef is involved. In that case, the function typedef is taken as definitive for both the declaration and the definition.
      Note that annotations are usually implemented as macros, and one macro will usually yield several low-level annotations. This warning is reported for each unmatched low-level annotation, so a single unmatched annotation macro may yield a number of unmatched low-level annotations. It is best to simply compare the declaration and definition source code to make sure that they are the same. (Trivial differences in the order of the annotations are not reported.)
      The comparison is always between the first declaration found and the current one. If there are additional declarations, then each declaration is checked in groups of two. It is currently not possible to do a comparison other than in pairs, although it is possible to identify that there are more than two declarations/definitions. The error message contains a list of the annotations that differ (at a fairly low level) between the two instances.
      This warning message displays the text of the underlying code sent to the compiler, and not the macros that are used to actually insert the annotation in the source code (as is the case whenever macros are used). In general, you do not need to understand the low-level annotations, but you should recognize that the annotations are being reported as inconsistent between the line numbers reported in the error message. Mostly, an inspection of the source code will make it clear why the inconsistency exists.
    </description>
    </rule>
    <rule key="C28253">
        <name>warning C28253: Inconsistent annotation for function: parameter has another annotations on this instance</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning refers to an error in the annotation and reflects the requirement that the annotations on a function declaration must match those on the definition, except if a function typedef is involved. In that case, the function typedef is taken as definitive for both the declaration and the definition.
      Note that annotations are usually implemented as macros, and one macro will usually yield several low-level annotations. This warning is reported for each unmatched low-level annotation, so a single unmatched annotation macro may yield a number of unmatched low-level annotations. It is best to simply compare the declaration and definition source code to make sure that they are the same. (Trivial differences in the order of the annotations are not reported.)
      The comparison is always between the first declaration found and the current one. If there are additional declarations, then each declaration is checked in groups of two. It is currently not possible to do a comparison other than in pairs, although it is possible to identify that there are more than two declarations/definitions. The error message contains a list of the annotations that differ (at a fairly low level) between the two instances.
      This warning message displays the text of the underlying code sent to the compiler, and not the macros that are used to actually insert the annotation in the source code (as is the case whenever macros are used). In general, you do not need to understand the low-level annotations, but you should recognize that the annotations are being reported as inconsistent between the line numbers reported in the error message. Mostly, an inspection of the source code will make it clear why the inconsistency exists.
    </description>
    </rule>
    <rule key="C28254">
        <name>warning C28254: dynamic_cast&lt;&gt;() is not supported in annotations</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The C++ dynamic_cast operator cannot be used in annotations.
    </description>
    </rule>
    <rule key="C28262">
        <name>warning C28262: A syntax error in the annotation was found in function &lt;function&gt; for annotation &lt;name&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C28262: A syntax error in the annotation was found in function &lt;function&gt; for annotation &lt;name&gt;
    </description>
    </rule>
    <rule key="C28263">
        <name>warning C28263: A syntax error in a conditional annotation was found for Intrinsic annotation</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when the return value for the specified function has a conditional value. This warning indicates an error in the annotations, not in the code being analyzed. If the function declaration is in a header file, the annotation should be corrected so that it matches the header file.
      The result list for the function and parameter specified has multiple unconditional values.
      Typically, this indicates that more than one unconditional _Null_ or __drv_valueIs annotations have been used to specify a result value.
    </description>
    </rule>
    <rule key="C28267">
        <name>warning C28267: A syntax error in the annotations was found annotation &lt;name&gt; in the function &lt;function&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C28267: A syntax error in the annotations was found annotation &lt;name&gt; in the function &lt;function&gt;.
    </description>
    </rule>
    <rule key="C28272">
        <name>warning C28272: The annotation for function, parameter when examining is inconsistent with the function declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an error in the annotations, not in the code that is being analyzed. The annotations appearing on a function definition are inconsistent with those appearing on a declaration. The two annotations should be resolved to match.
    </description>
    </rule>
    <rule key="C28273">
        <name>warning C28273: For function, the clues are inconsistent with the function declaration</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates an error in the annotations, not in the code that is being analyzed. The annotations appearing on a function definition are inconsistent with those appearing on a declaration. The two annotations should be resolved to match.
    </description>
    </rule>
    <rule key="C28275">
        <name>warning C28275: The parameter to _Macro_value_ is null</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that there is an internal error in the model file, not in the code being analyzed. The macroValue function was called without a parameter.
    </description>
    </rule>
    <rule key="C28278">
        <name>Warning C28278: Function name appears with no prototype in scope.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning typically indicates that a __deref is needed to apply the __return annotation to the value returned.
      The Code Analysis tool reports this warning when a function without a declaration was called, and the analysis that can be performed is limited because the declaration contains important information.
      The C language permits (but discourages) the use of a function for which no prototype has been declared. A function definition or a function declaration (prototype) should appear before the first use of the function. This warning indicates that a function without a declaration was called, and the analysis that can be performed is limited because declaration contains important information. If the function declaration were to contain annotations, the function declaration is even more useful to the Code Analysis tool.
    </description>
    </rule>
    <rule key="C28279">
        <name>warning C28279: For symbol, a &apos;begin&apos; was found without a matching &apos;end&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The annotation language supports a begin and end ({ and } in C) construct, and the pairing has gotten unbalanced. This situation can be avoided if the macros are used.
    </description>
    </rule>
    <rule key="C28280">
        <name>warning C28280: For symbol, an &apos;end&apos; was found without a matching &apos;begin&apos;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The annotation language supports a begin and an end ({ and } in C) construct, and the pairing has gotten unbalanced. This situation can be avoided if the macros are used.
    </description>
    </rule>
    <rule key="C28282">
        <name>warning C28282: Format Strings must be in preconditions</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a __drv_formatString annotation is found, which is not in a _Pre_ (__drv_in) annotation (function parameters are by default _Pre_). Check whether the annotation used in an explicit block with a _Post_ (__drv_out) annotation. If so, remove the annotation from any enclosing block that has put it in a _Post_ context.
    </description>
    </rule>
    <rule key="C28283">
        <name>warning C28283: For symbol, the specified size specification is not yet supported</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The warning indicates that the size specification &quot;sentinel&quot; annotation received a value other than zero. Essentially, the caller tried to say that the string is terminated by a character other than binary zero.
    </description>
    </rule>
    <rule key="C28284">
        <name>warning C28284: For symbol, Predicates are currently not supported for non-function symbols</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning indicates that a conditional annotation (predicate, __drv_when) was found on something other than a function.
    </description>
    </rule>
    <rule key="C28285">
        <name>warning C28285: For function, syntax error in parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when a probable error is encountered in the model file. A few source file errors can also cause such errors.
    </description>
    </rule>
    <rule key="C28286">
        <name>warning C28286: For function, syntax error near the end</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when a probable error is encountered in the model file. A few source file errors can also cause such errors.
    </description>
    </rule>
    <rule key="C28287">
        <name>warning C28287: For function, syntax Error in _At_() annotation (unrecognized parameter name)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when the SAL_at (__drv_at) annotation is used and the parameter expression cannot be interpreted in the current context. This might include using a misspelled parameter or member name, or a misspelling of &quot;return&quot; or &quot;this&quot; keywords.
    </description>
    </rule>
    <rule key="C28288">
        <name>warning C28288: For function, syntax Error in _At_() annotation (invalid parameter name)</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when the SAL_at (__drv_at) annotation is used and the parameter expression cannot be interpreted in the current context. This might include using a misspelled parameter or member name, or a misspelling of &quot;return&quot; or &quot;this&quot; keywords.
    </description>
    </rule>
    <rule key="C28289">
        <name>warning C28289: For function: ReadableTo or WritableTo did not have a limit-spec as a parameter</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when the function/parameter annotation is miscoded as noted. 
    </description>
    </rule>
    <rule key="C28290">
        <name>warning C28290: the annotation for function contains more Externals than the actual number of parameters</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when the annotation for the function contains more Externals than the actual number of parameters.
    </description>
    </rule>
    <rule key="C28291">
        <name>warning C28291: Post null/notnull at deref level 0 is meaningless for function &lt;x&gt; at param &lt;number&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The Code Analysis tool reports this warning when the post condition of a dereference level-zero parameter is specified to have a null/non-null property. This error occurs because a value at dereference level zero cannot change.
    </description>
    </rule>
    <rule key="C28300">
        <name>warning C28300: &lt;parameter_name&gt;: Expression operands of incompatible types for operator &lt;operator_name&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when operand types in a parameter are not compatible with the operator.
    </description>
    </rule>
    <rule key="C28301">
        <name>warning C28301: No annotations for first declaration of &lt;function&gt;.&lt;note1&gt; See &lt;filename&gt;(&lt;line&gt;). &lt;note2&gt;</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when annotations were not found at the first declaration of a given function.
    </description>
    </rule>
    <rule key="C28302">
        <name>warning C28302: For C++ reference-parameter &lt;parameter_name&gt;, an extra _Deref_ operator was found on &lt;annotation&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when an extra level of _Deref_ is used on a parameter.
      SAL2 does not require the use of an extra level of _Deref_ when dealing with reference parameters. This particular annotation is unambiguous and is interpreted correctly, but should be corrected.
      Frequently this can be corrected by simply removing the older __deref annotation and using SAL2 syntax. Sometimes may be necessary to use _At_ to reference the specific object to be annotated.
    </description>
    </rule>
    <rule key="C28303">
        <name>warning C28303: For C++ reference-parameter &lt;parameter_name&gt;, an ambiguous _Deref_ operator was found on &lt;annotation&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning similar to warning C28302 and is reported when an extra level of _Deref_ is used on a parameter.
      SAL2 does not require the use of an extra level of _Deref_ when dealing with reference parameters. This particular annotation is ambiguous as to which level of dereference is intended to be annotated. It may be necessary to use _At_ to reference the specific object to be annotated.
    </description>
    </rule>
    <rule key="C28304">
        <name>warning C28304: For C++ reference-parameter &lt;parameter_name&gt;, an improperly placed _Notref_ operator was found applied to &lt;token&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The _Notref_ operator should only be used in special circumstances involving C++ reference parameters and only in system-provided macros. It must be immediately followed by a _Deref_ operator or a functional annotation.
    </description>
    </rule>
    <rule key="C28305">
        <name>warning C28305: An error while parsing &lt;token&gt; was discovered.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when the expression containing the specified token is ill-formed.
    </description>
    </rule>
    <rule key="C28306">
        <name>warning C28306: The annotation on parameter is obsolescent</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Use _String_length_ with the appropriate SAL2 annotation instead.
    </description>
    </rule>
    <rule key="C28307">
        <name>warning C28307: The annotation on parameter is obsolescent</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Use _String_length_ with the appropriate SAL2 annotation instead.
    </description>
    </rule>
    <rule key="C28308">
        <name>warning C28308: The format list argument position specified by the annotation is incorrect. </name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      The format list argument position must be either a parameter name, or an integer offset that&apos;s in the parameter list, or zero.
      The second parameter to IsFormatString2 (where) can be in one of two forms:
      - A parameter name, which is taken as the first argument to the format string.
      - An offset (n) relative to the format-string parameter.
      In the second form, the first format-string parameter is the n-th argument after the format string. If n is zero, an ellipsis is specified as the parameter. Specifying an offset of zero without specifying the ellipsis as the first format-string parameter will cause an error.
    </description>
    </rule>
    <rule key="C28309">
        <name>warning C28309: &lt;parameter_name&gt;: Annotation operands must be integer/enum/pointer types. Floats are approximated as integers. Types: &lt;typelist&gt;.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      warning C28309: &lt;parameter_name&gt;: Annotation operands must be integer/enum/pointer types. Void operands and C++ overloaded operators are not supported. Floats are approximated as integers. Types: &lt;typelist&gt;.
      You&#8217;ve tried to use a void or a function in an annotation expression, and Code Analysis can&apos;t handle it.  This error typically occurs when an operator== that&apos;s implemented as a function is used, but other cases may also occur. Examine the types in &lt;typelist&gt; for clues about what&#8217;s wrong.
    </description>
    </rule>
    <rule key="C28350">
        <name>warning C28350: The annotation &lt;annotation&gt; describes a situation that is not conditionally applicable.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      Usually this warning is generated when an annotation is applied where the C/C++ type is being inspected.
    </description>
    </rule>
    <rule key="C28351">
        <name>warning C28351: The annotation &lt;annotation&gt; describes where a dynamic value (a variable) cannot be used in the condition.</name>
        <requirement>undefined</requirement>
        <remediationFactorVal>0.0</remediationFactorVal>
        <remediationFactorUnit>undefined</remediationFactorUnit>
        <remediationFunction>undefined</remediationFunction>
        <severity>undefined</severity>
        <repo>compiler</repo>
        <description>
      This warning is reported when an annotation is applied where the C/C++ type is being inspected.
      The expression in the _When_ should evaluate to a constant. The _When_ is ignored.
    </description>
    </rule>
    </rules>
</sqaleManager>
