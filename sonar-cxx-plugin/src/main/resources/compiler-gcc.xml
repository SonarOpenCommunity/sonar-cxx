<?xml version="1.0" encoding="UTF-8"?>
<rules>
  <rule>
    <key>=CustomRuleTemplate</key>
    <cardinality>MULTIPLE</cardinality>
    <name><![CDATA[Template for custom Custom rules]]></name>
    <description>
      <![CDATA[
<p>
Follow these steps to make your custom Custom rules available in SonarQube:
</p>

<ol>
  <ol>
    <li>Create a new rule in SonarQube by "copying" this rule template and specify the <code>CheckId</code> of your custom rule, a title, a description, and a default severity.</li>
    <li>Enable the newly created rule in your quality profile</li>
  </ol>
  <li>Relaunch an analysis on your projects, et voil√†, your custom rules are executed!</li>
</ol>
      ]]>
    </description>
    <severity>MAJOR</severity>
  </rule>    
  <rule>
    <key>enabled by default</key>
    <name>Default compiler warnings</name>
    <description>
    Default compiler warnings.
    </description>
    <internalKey>enabled by default</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wabi</key>
    <name>Warn about things that will change when compiling with an ABI-compliant compiler</name>
    <description>
    Warn when G++ generates code that is probably not compatible with the vendor-neutral
    C++ ABI. Although an effort has been made to warn about all such cases, there are probably some
    cases that are not warned about, even though G++ is generating incompatible code. There may also
    be cases where warnings are emitted even though the code that is generated will be compatible.

    You should rewrite your code to avoid these warnings if you are concerned about the fact that code
    generated by G++ may not be binary compatible with code generated by other compilers.
    </description>
    <internalKey>-Wabi</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Waddress</key>
    <name>Warn about suspicious uses of memory addresses</name>
    <description>
    Warn about suspicious uses of memory addresses. These include using the address of
    a function in a conditional expression, such as "void func(void); if (func)", and comparisons
    against the memory address of a string literal, such as "if (x == "abc")". Such uses typically
    indicate a programmer error: the address of a function always evaluates to true, so their use in
    a conditional usually indicate that the programmer forgot the parentheses in a function call;
    and comparisons against string literals result in unspecified behavior and are not portable in C,
    so they usually indicate that the programmer intended to use "strcmp".
    </description>
    <internalKey>-Waddress</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Waggregate-return</key>
    <name>Warn about returning structures, unions or arrays</name>
    <description>
    Warn if any functions that return structures or unions are defined or called. (In
    languages where you can return an array, this also elicits a warning.)
    </description>
    <internalKey>-Waggregate-return</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Waliasing</key>
    <name>Warn about possible aliasing of dummy arguments</name>
    <description>
    Warn about possible aliasing of dummy arguments.
    </description>
    <internalKey>-Waliasing</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Walign-commons</key>
    <name>Warn about alignment of COMMON blocks</name>
    <description>
    Warn about alignment of COMMON blocks.
    </description>
    <internalKey>-Walign-commons</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wampersand</key>
    <name>Warn about missing ampersand in continued character constants</name>
    <description>
    Warn about missing ampersand in continued character constants.
    </description>
    <internalKey>-Wampersand</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Warray-bounds</key>
    <name>Warn if an array is accessed out of bounds</name>
    <description>
    This option is only active when -ftree-vrp is active (default for -O2 and above). It
    warns about subscripts to arrays that are always out of bounds.
    </description>
    <internalKey>-Warray-bounds</internalKey>
    <severity>CRITICAL</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Warray-temporaries</key>
    <name>Warn about creation of array temporaries</name>
    <description>
    Warn about creation of array temporaries.
    </description>
    <internalKey>-Warray-temporaries</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wassign-intercept</key>
    <name>Warn whenever an Objective-C assignment is being intercepted by the garbage collector</name>
    <description>
    Warn whenever an Objective-C assignment is being intercepted by the garbage collector.
    </description>
    <internalKey>-Wassign-intercept</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wattributes</key>
    <name>Warn about inappropriate attribute usage</name>
    <description>
    Warn if an unexpected "__attribute__" is used, such as unrecognized attributes,
    function attributes applied to variables, etc. This will not stop errors for incorrect use of
    supported attributes.
    </description>
    <internalKey>-Wattributes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wbad-function-cast</key>
    <name>Warn about casting functions to incompatible types</name>
    <description>
    Warn whenever a function call is cast to a non-matching type. For example, warn if
    "int malloc()" is cast to "anything *".
    </description>
    <internalKey>-Wbad-function-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wbuiltin-macro-redefined</key>
    <name>Warn when a built-in preprocessor macro is undefined or redefined</name>
    <description>
    Warn if certain built-in macros are redefined. This generate warnings for
    redefinition of "__TIMESTAMP__", "__TIME__", "__DATE__", "__FILE__", and "__BASE_FILE__".
    </description>
    <internalKey>-Wbuiltin-macro-redefined</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++-compat</key>
    <name>Warn about C constructs that are not in the common subset of C and C++</name>
    <description>
    Warn about ISO C constructs that are outside of the common subset of ISO C and ISO
    C++, e.g. request for implicit conversion from "void *" to a pointer to non-"void" type.
    </description>
    <internalKey>-Wc++-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++0x-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 200x</name>
    <description>
    Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 200x,
    e.g., identifiers in ISO C++ 1998 that will become keywords in ISO C++ 200x.
    </description>
    <internalKey>-Wc++0x-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wc++11-compat</key>
    <name>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011</name>
    <description>
    Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011,
    e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011.
    </description>
    <internalKey>-Wc++11-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcast-align</key>
    <name>Warn about pointer casts which increase alignment</name>
    <description>
    Warn whenever a pointer is cast such that the required alignment of the target is
    increased.  For example, warn if a "char *" is cast to an "int *" on machines where integers can
    only be accessed at two- or four-byte boundaries.
    </description>
    <internalKey>-Wcast-align</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcast-qual</key>
    <name>Warn about casts which discard qualifiers</name>
    <description>
    Warn whenever a pointer is cast so as to remove a type qualifier from the target type.
    For example, warn if a "const char *" is cast to an ordinary "char *".

    Also warn when making a cast which introduces a type qualifier in an unsafe way.  For example,
    casting "char **" to "const char **" is unsafe, as in this example:

              /* p is char ** value.  */
              const char **q = (const char **) p;
              /* Assignment of readonly string to const char * is OK.  */
              *q = "string";
              /* Now char** pointer points to read-only memory.  */
              **p = 'b';
    </description>
    <internalKey>-Wcast-qual</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wchar-subscripts</key>
    <name>Warn about subscripts whose type is "char"</name>
    <description>
    Warn if an array subscript has type "char". This is a common cause of error, as
    programmers often forget that this type is signed on some machines.
    </description>
    <internalKey>-Wchar-subscripts</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcharacter-truncation</key>
    <name>Warn about truncated character expressions</name>
    <description>
    Warn about truncated character expressions.
    </description>
    <internalKey>-Wcharacter-truncation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wclobbered</key>
    <name>Warn about variables that might be changed by "longjmp" or "vfork"</name>
    <description>
     Warn for variables that might be changed by longjmp or vfork.
    </description>
    <internalKey>-Wclobbered</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcomment</key>
    <name>Warn about possibly nested block comments, and C++ comments spanning more than one physical line</name>
    <description>
    Warn whenever a comment-start sequence /* appears in a /* comment, or whenever a Backslash-Newline
    appears in a // comment.
    </description>
    <internalKey>-Wcomment</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconversion</key>
    <name>Warn for implicit type conversions that may change a value</name>
    <description>
    Warn for implicit conversions that may alter a value. This includes conversions
    between real and integer, like "abs (x)" when "x" is "double"; conversions between signed and
    unsigned, like "unsigned ui = -1"; and conversions to smaller types, like "sqrtf (M_PI)". Do not
    warn for explicit casts like "abs ((int) x)" and "ui = (unsigned) -1", or if the value is not
    changed by the conversion like in "abs (2.0)".  Warnings about conversions between signed and
    unsigned integers can be disabled by using -Wno-sign-conversion.

    For C++, also warn for confusing overload resolution for user-defined conversions; and conversions
    that will never use a type conversion operator: conversions to "void", the same type, a base class
    or a reference to them. Warnings about conversions between signed and unsigned integers are
    disabled by default in C++ unless -Wsign-conversion is explicitly enabled.
    </description>
    <internalKey>-Wconversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconversion-extra</key>
    <name>Warn about most implicit conversions</name>
    <description>
    Warn about most implicit conversions.
    </description>
    <internalKey>-Wconversion-extra</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wconversion-null</key>
    <name>Warn for converting NULL from/to a non-pointer type</name>
    <description>
    Warn for conversions between "NULL" and non-pointer types.
    </description>
    <internalKey>-Wconversion-null</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcoverage-mismatch</key>
    <name>Warn in case profiles in -fprofile-use do not match</name>
    <description>
    Warn if feedback profiles do not match when using the -fprofile-use option. If a source
    file was changed between -fprofile-gen and -fprofile-use, the files with the profile feedback can
    fail to match the source file and GCC can not use the profile feedback information.  By default,
    this warning is enabled and is treated as an error. -Wno-coverage-mismatch can be used to disable
    the warning or -Wno-error=coverage-mismatch can be used to disable the error. Disable the error
    for this warning can result in poorly optimized code, so disabling the error is useful only in the
    case of very minor changes such as bug fixes to an existing code-base. Completely disabling the
    warning is not recommended.
    </description>
    <internalKey>-Wcoverage-mismatch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wcpp</key>
    <name>Warn when a #warning directive is encountered</name>
    <description>
    Warning messages emitted by "#warning" directives.
    </description>
    <internalKey>-Wcpp</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wctor-dtor-privacy</key>
    <name>Warn when all constructors and destructors are private</name>
    <description>
    Warn when a class seems unusable because all the constructors or destructors in that
    class are private, and it has neither friends nor public static member functions.
    </description>
    <internalKey>-Wctor-dtor-privacy</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdeclaration-after-statement</key>
    <name>Warn when a declaration is found after a statement</name>
    <description>
    Warn when a declaration is found after a statement in a block. This construct, known
    from C++, was introduced with ISO C99 and is by default allowed in GCC.  It is not supported by
    ISO C90 and was not supported by GCC versions before GCC 3.0.
    </description>
    <internalKey>-Wdeclaration-after-statement</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdelete-non-virtual-dtor</key>
    <name>Warn about deleting polymorphic objects with non-virtual destructors</name>
    <description>
    Warn when delete is used to destroy an instance of a class that has virtual functions
    and non-virtual destructor. It is unsafe to delete an instance of a derived class through a pointer
    to a base class if the base class does not have a virtual destructor.
    </description>
    <internalKey>-Wdelete-non-virtual-dtor</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdeprecated</key>
    <name>Warn about usage of deprecated features</name>
    <description>
    Warn if a deprecated compiler feature, class, method, or field is used.
    </description>
    <internalKey>-Wdeprecated</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdeprecated-declarations</key>
    <name>Warn about uses of __attribute__((deprecated)) declarations</name>
    <description>
    Warn about uses of functions, variables, and types marked as deprecated by using the
    "deprecated" attribute.
    </description>
    <internalKey>-Wdeprecated-declarations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdisabled-optimization</key>
    <name>Warn when an optimization pass is disabled</name>
    <description>
    Warn if a requested optimization pass is disabled. This warning does not generally
    indicate that there is anything wrong with your code; it merely indicates that GCC's optimizers
    were unable to handle the code effectively. Often, the problem is that your code is too big or
    too complex; GCC will refuse to optimize programs when the optimization itself is likely to take
    inordinate amounts of time.
    </description>
    <internalKey>-Wdisabled-optimization</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdiv-by-zero</key>
    <name>Warn about compile-time integer division by zero</name>
    <description>
    Warn about compile-time integer division by zero. Floating point division by zero is
    not warned about, as it can be a legitimate way of obtaining infinities and NaNs.
    </description>
    <internalKey>-Wdiv-by-zero</internalKey>
    <severity>CRITICAL</severity>
    <type>BUG</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wdouble-promotion</key>
    <name>Warn about implicit conversions from "float" to "double"</name>
    <description>
    Give a warning when a value of type "float" is implicitly promoted to "double". CPUs
    with a 32-bit "single-precision" floating-point unit implement "float" in hardware, but emulate
    "double" in software. On such a machine, doing computations using "double" values is much more
    expensive because of the overhead required for software emulation.

    It is easy to accidentally do computations with "double" because floating-point literals are
    implicitly of type "double". For example, in:

            float area(float radius)
            {
               return 3.14159 * radius * radius;
            }

    the compiler will perform the entire computation with "double" because the floating-point literal
    is a "double".
    </description>
    <internalKey>-Wdouble-promotion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Weffc++</key>
    <name>Warn about violations of Effective C++ style rules</name>
    <description>
    Warn about violations of the following style guidelines from Scott Meyers' Effective
    C++, Second Edition book:
      * Item 11:  Define a copy constructor and an assignment operator for classes with dynamically allocated memory.
      * Item 12:  Prefer initialization to assignment in constructors.
      * Item 14:  Make destructors virtual in base classes.
      * Item 15:  Have "operator=" return a reference to *this.
      * Item 23:  Don't try to return a reference when you must return an object.

    Also warn about violations of the following style guidelines from Scott Meyers' More Effective C++ book:
      * Item 6:  Distinguish between prefix and postfix forms of increment and decrement operators.
      * Item 7:  Never overload "&amp;&amp;", "||", or ",".
    </description>
    <internalKey>-Weffc++</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wempty-body</key>
    <name>Warn about an empty body in an if or else statement</name>
    <description>
    Warn if an empty body occurs in an if, else or do while statement.
    </description>
    <internalKey>-Wempty-body</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wendif-labels</key>
    <name>Warn about stray tokens after #elif and #endif</name>
    <description>
    Warn whenever an #else or an #endif are followed by text.
    </description>
    <internalKey>-Wendif-labels</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wenum-compare</key>
    <name>Warn about comparison of different enum types</name>
    <description>
    Warn about a comparison between values of different enum types. In C++ this warning is enabled by default.
    </description>
    <internalKey>-Wenum-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfloat-equal</key>
    <name>Warn if testing floating point numbers for equality</name>
    <description>
    Warn if floating point values are used in equality comparisons.

    The idea behind this is that sometimes it is convenient (for the programmer) to consider
    floating-point values as approximations to infinitely precise real numbers. If you are doing this,
    then you need to compute (by analyzing the code, or in some other way) the maximum or likely
    maximum error that the computation introduces, and allow for it when performing comparisons (and
    when producing output, but that's a different problem).  In particular, instead of testing for
    equality, you would check to see whether the two values have ranges that overlap; and this is done
    with the relational operators, so equality comparisons are probably mistaken.
    </description>
    <internalKey>-Wfloat-equal</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat</key>
    <name>Warn about printf/scanf/strftime/strfmon format string anomalies</name>
    <description>
    Check calls to "printf" and "scanf", etc., to make sure that the arguments supplied
    have types appropriate to the format string specified, and that the conversions specified in the
    format string make sense. This includes standard functions, and others specified by format
    attributes, in the "printf", "scanf", "strftime" and "strfmon" (an X/Open extension, not in the C
    standard) families (or other target-specific families). Which functions are checked without format
    attributes having been specified depends on the standard version selected, and such checks of
    functions without the attribute specified are disabled by -ffreestanding or -fno-builtin.

    The formats are checked against the format features supported by GNU libc version 2.2. These
    include all ISO C90 and C99 features, as well as features from the Single Unix Specification and
    some BSD and GNU extensions. Other library implementations may not support all these features;
    GCC does not support warning about features that go beyond a particular library's limitations.
    However, if -pedantic is used with -Wformat, warnings will be given about format features not in
    the selected standard version (but not for "strfmon" formats, since those are not in any version
    of the C standard).
    </description>
    <internalKey>-Wformat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-contains-nul</key>
    <name>Warn about format strings that contain NUL bytes</name>
    <description>
    Warn about format strings that contain NUL bytes.
    </description>
    <internalKey>-Wformat-contains-nul</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-extra-args</key>
    <name>Warn if passing too many arguments to a function for its format string</name>
    <description>
    Warn about excess arguments to a "printf" or "scanf" format function. The C standard
    specifies that such arguments are ignored.

    Where the unused arguments lie between used arguments that are specified with $ operand number
    specifications, normally warnings are still given, since the implementation could not know what
    type to pass to "va_arg" to skip the unused arguments. However, in the case of "scanf" formats,
    this option will suppress the warning if the unused arguments are all pointers, since the Single
    Unix Specification says that such unused arguments are allowed.
    </description>
    <internalKey>-Wformat-extra-args</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-nonliteral</key>
    <name>Warn about format strings that are not literals</name>
    <description>
    Warn if the format string is not a string literal and so cannot be checked, unless
    the format function takes its format arguments as a "va_list".
    </description>
    <internalKey>-Wformat-nonliteral</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-security</key>
    <name>Warn about possible security problems with format functions</name>
    <description>
    Warn about uses of format functions that represent possible security problems. At
    present, this warns about calls to "printf" and "scanf" functions where the format string is not
    a string literal and there are no format arguments, as in "printf (foo);". This may be a security
    hole if the format string came from untrusted input and contains %n.
    </description>
    <internalKey>-Wformat-security</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-y2k</key>
    <name>Warn about strftime formats yielding 2-digit years</name>
    <description>
    Warn about "strftime" formats which may yield only a two-digit year.
    </description>
    <internalKey>-Wformat-y2k</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wformat-zero-length</key>
    <name>Warn about zero-length formats</name>
    <description>
    Warn about zero-length formats. The C standard specifies that zero-length formats are
    allowed.
    </description>
    <internalKey>-Wformat-zero-length</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wframe-larger-than</key>
    <name>Warn about large frames</name>
    <description>
    Warn if the size of a function frame is larger than len bytes. The computation done
    to determine the stack frame size is approximate and not conservative.  The actual requirements
    may be somewhat greater than len even if you do not get a warning. In addition, any space allocated
    via "alloca", variable-length arrays, or related constructs is not included by the compiler when
    determining whether or not to issue a warning.
    </description>
    <internalKey>-Wframe-larger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfree-nonheap-object</key>
    <name>Warn when attempting to free a non-heap object</name>
    <description>
    Warn when attempting to free a non-heap object.
    </description>
    <internalKey>-Wfree-nonheap-object</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wfunction-elimination</key>
    <name>Warn about function call elimination</name>
    <description>
    Warn about function call elimination.
    </description>
    <internalKey>-Wfunction-elimination</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wignored-qualifiers</key>
    <name>Warn whenever type qualifiers are ignored.</name>
    <description>
    Warn if the return type of a function has a type qualifier such as "const". For ISO
    C such a type qualifier has no effect, since the value returned by a function is not an lvalue.
    For C++, the warning is only emitted for scalar types or "void". ISO C prohibits qualified "void"
    return types on function definitions, so such return types always receive a warning even without
    this option.
    </description>
    <internalKey>-Wignored-qualifiers</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-function-declaration</key>
    <name>Warn about implicit function declarations</name>
    <description>
    Give a warning whenever a function is used before being declared.
    </description>
    <internalKey>-Wimplicit-function-declaration</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-int</key>
    <name>Warn when a declaration does not specify a type</name>
    <description>
    Warn when a declaration does not specify a type.
    </description>
    <internalKey>-Wimplicit-int</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-interface</key>
    <name>Warn about calls with implicit interface</name>
    <description>
    Warn about calls with implicit interface.
    </description>
    <internalKey>-Wimplicit-interface</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wimplicit-procedure</key>
    <name>Warn about called procedures not explicitly declared</name>
    <description>
    Warn about called procedures not explicitly declared.
    </description>
    <internalKey>-Wimplicit-procedure</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winit-self</key>
    <name>Warn about variables which are initialized to themselves</name>
    <description>
    Warn about uninitialized variables which are initialized with themselves.

    For example, GCC will warn about "i" being uninitialized in the following snippet only when
    -Winit-self has been specified:

            int f()
            {
              int i = i;
              return i;
            }
    </description>
    <internalKey>-Winit-self</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winline</key>
    <name>Warn when an inlined function cannot be inlined</name>
    <description>
    Warn if a function can not be inlined and it was declared as inline. Even with this
    option, the compiler will not warn about failures to inline functions declared in system headers.

    The compiler uses a variety of heuristics to determine whether or not to inline a function. For
    example, the compiler takes into account the size of the function being inlined and the amount of
    inlining that has already been done in the current function. Therefore, seemingly insignificant
    changes in the source program can cause the warnings produced by -Winline to appear or disappear.
    </description>
    <internalKey>-Winline</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wint-to-pointer-cast</key>
    <name>Warn when there is a cast to a pointer from an integer of a different size</name>
    <description>
    Warn when casting to pointer type of an integer of a different size. In C++, casting
    to a pointer type of smaller size is an error.
    </description>
    <internalKey>-Wint-to-pointer-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wintrinsic-shadow</key>
    <name>Warn if a user-procedure has the same name as an intrinsic</name>
    <description>
    Warn if a user-procedure has the same name as an intrinsic.
    </description>
    <internalKey>-Wintrinsic-shadow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wintrinsics-std</key>
    <name>Warn on intrinsics not part of the selected standard</name>
    <description>
    Warn on intrinsics not part of the selected standard.
    </description>
    <internalKey>-Wintrinsics-std</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winvalid-memory-model</key>
    <name>Warn when an atomic memory model parameter is known to be outside the valid range.</name>
    <description>
    Warn when an atomic memory model parameter is known to be outside the valid range.
    </description>
    <internalKey>-Winvalid-memory-model</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winvalid-offsetof</key>
    <name>Warn about invalid uses of the "offsetof" macro</name>
    <description>
    Warn when applying the offsetof macro to a non-POD type. According to the 1998 ISO
    C++ standard, applying offsetof to a non-POD type is undefined. In existing C++ implementations,
    however, offsetof typically gives meaningful results even when applied to certain kinds of non-POD
    types. (Such as a simple struct that fails to be a POD type only by virtue of having a constructor.)

    The restrictions on offsetof may be relaxed in a future version of the C++ standard.

    </description>
    <internalKey>-Winvalid-offsetof</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Winvalid-pch</key>
    <name>Warn about PCH files that are found but not used</name>
    <description>
    Warn if a precompiled header is found in the search path but can't be used.
    </description>
    <internalKey>-Winvalid-pch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wjump-misses-init</key>
    <name>Warn when a jump misses a variable initialization</name>
    <description>
    Warn if a "goto" statement or a "switch" statement jumps forward across the
    initialization of a variable, or jumps backward to a label after the variable has been initialized.
    This only warns about variables which are initialized when they are declared.  This warning is
    only supported for C and Objective C; in C++ this sort of branch is an error in any case.
    </description>
    <internalKey>-Wjump-misses-init</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlarger-than</key>
    <name>Warn if an object is larger than specified number of bytes</name>
    <description>
    Warn whenever an object larger than the specified length (in bytes) is defined.
    </description>
    <internalKey>-Wlarger-than</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wline-truncation</key>
    <name>Warn about truncated source lines</name>
    <description>
    Warn about truncated source lines.
    </description>
    <internalKey>-Wline-truncation</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlogical-op</key>
    <name>Warn when a logical operator is suspiciously always evaluating to true or false</name>
    <description>
    Warn about suspicious uses of logical operators in expressions. This includes using
    logical operators in contexts where a bit-wise operator is likely to be expected.
    </description>
    <internalKey>-Wlogical-op</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wlong-long</key>
    <name>Warn if long long type is used. </name>
    <description>
    Warn if long long type is used.
    </description>
    <internalKey>-Wlong-long</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmain</key>
    <name>Warn about suspicious declarations of "main"</name>
    <description>
    Warn if the type of main is suspicious. main should be a function with external
    linkage, returning int, taking either zero arguments, two, or three arguments of appropriate
    types.
    </description>
    <internalKey>-Wmain</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmaybe-uninitialized</key>
    <name>Warn about maybe uninitialized automatic variables</name>
    <description>
    Warn about maybe uninitialized automatic variables
    </description>
    <internalKey>-Wmaybe-uninitialized</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-braces</key>
    <name>Warn about possibly missing braces around initializers</name>
    <description>
    Warn if an aggregate or union initializer is not fully bracketed. In the following
    example, the initializer for a is not fully bracketed, but that for b is fully bracketed.

            int a[2][2] = { 0, 1, 2, 3 };
            int b[2][2] = { { 0, 1 }, { 2, 3 } };
    </description>
    <internalKey>-Wmissing-braces</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-declarations</key>
    <name>Warn about global functions without previous declarations</name>
    <description>
    Warn if a global function is defined without a previous declaration. Do so even if
    the definition itself provides a prototype. Use this option to detect global functions that are
    not declared in header files. In C++, no warnings are issued for function templates, or for inline
    functions, or for functions in anonymous namespaces.
    </description>
    <internalKey>-Wmissing-declarations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-field-initializers</key>
    <name>Warn about missing fields in struct initializers</name>
    <description>
    Warn if a structure's initializer has some fields missing. For example, the following
    code would cause such a warning, because "x.h" is implicitly zero:

            struct s { int f, g, h; };
            struct s x = { 3, 4 };

    This option does not warn about designated initializers, so the following modification would not
    trigger a warning:

            struct s { int f, g, h; };
            struct s x = { .f = 3, .g = 4 };
    </description>
    <internalKey>-Wmissing-field-initializers</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-format-attribute</key>
    <name>Warn about functions which might be candidates for format attributes</name>
    <description>
    Warn about function pointers that might be candidates for "format" attributes. Note
    these are only possible candidates, not absolute ones. GCC will guess that function pointers with
    "format" attributes that are used in assignment, initialization, parameter passing or return
    statements should have a corresponding "format" attribute in the resulting type. I.e. the left-hand
    side of the assignment or initialization, the type of the parameter variable, or the return type
    of the containing function respectively should also have a "format" attribute to avoid the warning.

    GCC will also warn about function definitions that might be candidates for "format" attributes.
    Again, these are only possible candidates. GCC will guess that "format" attributes might be
    appropriate for any function that calls a function like "vprintf" or "vscanf", but this might not
    always be the case, and some functions for which "format" attributes are appropriate may not be
    detected.
    </description>
    <internalKey>-Wmissing-format-attribute</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-include-dirs</key>
    <name>Warn about user-specified include directories that do not exist</name>
    <description>
    Warn if a user-supplied include directory does not exist.
    </description>
    <internalKey>-Wmissing-include-dirs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-noreturn</key>
    <name>Warn about functions which might be candidates for __attribute__((noreturn))</name>
    <description>
    Warn about functions which might be candidates for __attribute__((noreturn))
    </description>
    <internalKey>-Wmissing-noreturn</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-parameter-type</key>
    <name>Warn about function parameters declared without a type specifier in K&amp;R-style functions</name>
    <description>
    A function parameter is declared without a type specifier in K&amp;R-style functions:

            void foo(bar) { }
    </description>
    <internalKey>-Wmissing-parameter-type</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmissing-prototypes</key>
    <name>Warn about global functions without prototypes</name>
    <description>
    Warn if a global function is defined without a previous prototype declaration. This
    warning is issued even if the definition itself provides a prototype. The aim is to detect global
    functions that are not declared in header files.
    </description>
    <internalKey>-Wmissing-prototypes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmudflap</key>
    <name>Warn about constructs not instrumented by -fmudflap</name>
    <description>
    Warn about constructs that cannot be instrumented by -fmudflap.
    </description>
    <internalKey>-Wmudflap</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wmultichar</key>
    <name>Warn about use of multi-character character constants</name>
    <description>
    Warn if a multicharacter constant ('FOOF') is used. Usually they indicate a typo in
    the user's code, as they have implementation-defined values, and should not be used in portable
    code.
    </description>
    <internalKey>-Wmultichar</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnarrowing</key>
    <name>Warn about narrowing conversions within { } that are ill-formed in C++11</name>
    <description>
    Warn when a narrowing conversion prohibited by C++11 occurs within { }, e.g.

            int i = { 2.2 }; // error: narrowing from double to int

    This flag is included in -Wall and -Wc++11-compat.

    With -std=c++11, -Wno-narrowing suppresses the diagnostic required by the standard. Note that this
    does not affect the meaning of well-formed code; narrowing conversions are still considered ill-formed
    in SFINAE context.
    </description>
    <internalKey>-Wnarrowing</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnested-externs</key>
    <name>Warn about "extern" declarations not at file scope</name>
    <description>
    Warn if an "extern" declaration is encountered within a function.
    </description>
    <internalKey>-Wnested-externs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnoexcept</key>
    <name>Warn when a noexcept expression evaluates to false even though the expression can't actually throw</name>
    <description>
    Warn when a noexcept-expression evaluates to false because of a call to a function
    that does not have a non-throwing exception specification (i.e. throw() or noexcept) but is known
    by the compiler to never throw an exception.
    </description>
    <internalKey>-Wnoexcept</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnon-template-friend</key>
    <name>Warn when non-templatized friend functions are declared within a template</name>
    <description>
    Disable warnings when non-templatized friend functions are declared within a template.
    Since the advent of explicit template specification support in G++, if the name of the friend is
    an unqualified-id (i.e., friend foo(int)), the C++ language specification demands that the friend
    declare or define an ordinary, nontemplate function. (Section 14.5.3). Before G++ implemented
    explicit specification, unqualified-ids could be interpreted as a particular specialization of a
    templatized function. Because this non-conforming behavior is no longer the default behavior for
    G++, -Wnon-template-friend allows the compiler to check existing code for potential trouble spots
    and is on by default. This new compiler behavior can be turned off with -Wno-non-template-friend,
    which keeps the conformant compiler code but disables the helpful warning.
    </description>
    <internalKey>-Wnon-template-friend</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnon-virtual-dtor</key>
    <name>Warn about non-virtual destructors</name>
    <description>
    Warn when a class has virtual functions and accessible non-virtual destructor, in which
    case it would be possible but unsafe to delete an instance of a derived class through a pointer
    to the base class.
    </description>
    <internalKey>-Wnon-virtual-dtor</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnonnull</key>
    <name>Warn about NULL being passed to argument slots marked as requiring non-NULL</name>
    <description>
    Warn about passing a null pointer for arguments marked as requiring a non-null value
    by the "nonnull" function attribute.
    </description>
    <internalKey>-Wnonnull</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wnormalized</key>
    <name>Warn about non-normalised Unicode strings</name>
    <description>
    In ISO C and ISO C++, two identifiers are different if they are different sequences
    of characters. However, sometimes when characters outside the basic ASCII character set are used,
    you can have two different character sequences that look the same. To avoid confusion, the ISO
    10646 standard sets out some normalization rules which when applied ensure that two sequences that
    look the same are turned into the same sequence. GCC can warn you if you are using identifiers
    that have not been normalized; this option controls that warning.

    There are four levels of warning supported by GCC. The default is -Wnormalized=nfc, which warns
    about any identifier that is not in the ISO 10646 "C" normalized form, NFC. NFC is the recommended
    form for most uses.

    Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when
    turned into NFC, are not allowed in identifiers. That is, there's no way to use these symbols in
    portable ISO C or C++ and have all your identifiers in NFC. -Wnormalized=id suppresses the warning
    for these characters. It is hoped that future versions of the standards involved will correct
    this, which is why this option is not the default.

    You can switch the warning off for all characters by writing -Wnormalized=none. You would only
    want to do this if you were using some other normalization scheme (like "D"), because otherwise
    you can easily create bugs that are literally impossible to see.

    Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display
    methodologies, especially once formatting has been applied. For instance "\u207F", "SUPERSCRIPT
    LATIN SMALL LETTER N", will display just like a regular "n" that has been placed in a superscript.
    ISO 10646 defines the NFKC normalization scheme to convert all these into a standard form as well,
    and GCC will warn if your code is not in NFKC if you use -Wnormalized=nfkc. This warning is
    comparable to warning about every identifier that contains the letter O because it might be confused
    with the digit 0, and so is not the default, but may be useful as a local coding convention if the
    programming environment is unable to be fixed to display these characters distinctly.
    </description>
    <internalKey>-Wnormalized</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wold-style-cast</key>
    <name>Warn if a C-style cast is used in a program</name>
    <description>
    Warn if an old-style (C-style) cast to a non-void type is used within a C++ program.
    The new-style casts (dynamic_cast, static_cast, reinterpret_cast, and const_cast) are less vulnerable
    to unintended effects and much easier to search for.
    </description>
    <internalKey>-Wold-style-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wold-style-declaration</key>
    <name>Warn for obsolescent usage in a declaration</name>
    <description>
    Warn for obsolescent usages, according to the C Standard, in a declaration. For
    example, warn if storage-class specifiers like "static" are not the first things in a declaration.
    </description>
    <internalKey>-Wold-style-declaration</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wold-style-definition</key>
    <name>Warn if an old-style parameter definition is used</name>
    <description>
    Warn if an old-style function definition is used. A warning is given even if there
    is a previous prototype.
    </description>
    <internalKey>-Wold-style-definition</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverflow</key>
    <name>Warn about overflow in arithmetic expressions</name>
    <description>
    Warn about compile-time overflow in constant expressions.
    </description>
    <internalKey>-Woverflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverlength-strings</key>
    <name>Warn if a string is longer than the maximum portable length specified by the standard</name>
    <description>
    Warn about string constants that are longer than the "minimum maximum" length specified
    in the C standard. Modern compilers generally allow string constants that are much longer than the
    standard's minimum limit, but very portable programs should avoid using longer strings.

    The limit applies after string constant concatenation, and does not count the trailing NUL. In C90,
    the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative
    minimum maximum, so we do not diagnose overlength strings in C++.
    </description>
    <internalKey>-Woverlength-strings</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverloaded-virtual</key>
    <name>Warn about overloaded virtual function names</name>
    <description>
    Warn when a function declaration hides virtual functions from a base class. For example, in:

            struct A {
              virtual void f();
            };

            struct B: public A {
              void f(int);
            };

    the "A" class version of "f" is hidden in "B", and code like:

            B* b;
            b->f();

    will fail to compile.
    </description>
    <internalKey>-Woverloaded-virtual</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Woverride-init</key>
    <name>Warn about overriding initializers without side effects</name>
    <description>
    Warn if an initialized field without side effects is overridden when using designated
    initializers.
    </description>
    <internalKey>-Woverride-init</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpacked</key>
    <name>Warn when the packed attribute has no effect on struct layout</name>
    <description>
    Warn if a structure is given the packed attribute, but the packed attribute has no
    effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit.
    For instance, in this code, the variable "f.x" in "struct bar" will be misaligned even though
    "struct bar" does not itself have the packed attribute:

            struct foo {
              int x;
              char a, b, c, d;
            } __attribute__((packed));
            struct bar {
              char z;
              struct foo f;
            };
    </description>
    <internalKey>-Wpacked</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpacked-bitfield-compat</key>
    <name>Warn about packed bit-fields whose offset changed in GCC 4.4</name>
    <description>
     The 4.1, 4.2 and 4.3 series of GCC ignore the "packed" attribute on bit-fields of
    type "char". This has been fixed in GCC 4.4 but the change can lead to differences in the structure
    layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there
    is no longer a 4-bit padding between field "a" and "b" in this structure:

            struct foo
            {
              char a:4;
              char b:8;
            } __attribute__ ((packed));
    </description>
    <internalKey>-Wpacked-bitfield-compat</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpadded</key>
    <name>Warn when padding is required to align structure members</name>
    <description>
    Warn if padding is included in a structure, either to align an element of the structure
    or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields
    of the structure to reduce the padding and so make the structure smaller.
    </description>
    <internalKey>-Wpadded</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wparentheses</key>
    <name>Warn about possibly missing parentheses</name>
    <description>
    Warn if parentheses are omitted in certain contexts, such as when there is an
    assignment in a context where a truth value is expected, or when operators are nested whose
    precedence people often get confused about.

    Also warn if a comparison like x&lt;=y&lt;=z appears; this is equivalent to (x&lt;=y ? 1 : 0) &lt;= z, which
    is a different interpretation from that of ordinary mathematical notation.

    Also warn about constructions where there may be confusion to which "if" statement an "else"
    branch belongs. Here is an example of such a case:

            {
              if (a)
                if (b)
                  foo ();
              else
                bar ();
            }

    In C/C++, every "else" branch belongs to the innermost possible "if" statement, which in this
    example is "if (b)". This is often not what the programmer expected, as illustrated in the above
    example by indentation the programmer chose. When there is the potential for this confusion, GCC
    will issue a warning when this flag is specified. To eliminate the warning, add explicit braces
    around the innermost "if" statement so there is no way the "else" could belong to the enclosing
    "if". The resulting code would look like this:

            {
              if (a)
                {
                  if (b)
                    foo ();
                  else
                    bar ();
                }
            }

    Also warn for dangerous uses of the ?: with omitted middle operand GNU extension. When the condition
    in the ?: operator is a boolean expression the omitted value will be always 1. Often the user
    expects it to be a value computed inside the conditional expression instead.
    </description>
    <internalKey>-Wparentheses</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpmf-conversions</key>
    <name>Warn when converting the type of pointers to member functions</name>
    <description>
    Warn when converting a bound pointer to member function to a plain pointer.
    </description>
    <internalKey>-Wpmf-conversions</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-arith</key>
    <name>Warn about function pointer arithmetic</name>
    <description>
    Warn about anything that depends on the "size of" a function type or of "void". GNU
    C assigns these types a size of 1, for convenience in calculations with "void *" pointers and
    pointers to functions.  In C++, warn also when an arithmetic operation involves "NULL".
    </description>
    <internalKey>-Wpointer-arith</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-sign</key>
    <name>Warn when a pointer differs in signedness in an assignment</name>
    <description>
    Warn for pointer argument passing or assignment with different signedness. This option
    is only supported for C and Objective-C.
    </description>
    <internalKey>-Wpointer-sign</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpointer-to-int-cast</key>
    <name>Warn when a pointer is cast to an integer of a different size</name>
    <description>
    Warn when casting casting from a pointer to an integer type of a different size.
    </description>
    <internalKey>-Wpointer-to-int-cast</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wpragmas</key>
    <name>Warn about misuses of pragmas</name>
    <description>
    Warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or
    conflicts between pragmas.
    </description>
    <internalKey>-Wpragmas</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wproperty-assign-default</key>
    <name>Warn if a property for an Objective-C object has no assign semantics specified</name>
    <description>
    Warn if a property for an Objective-C object has no assign semantics specified
    </description>
    <internalKey>-Wproperty-assign-default</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wprotocol</key>
    <name>Warn if inherited methods are unimplemented</name>
    <description>
    If a class is declared to implement a protocol, a warning is issued for every method
    in the protocol that is not implemented by the class.  The default behavior is to issue a warning
    for every method not explicitly implemented in the class, even if a method implementation is
    inherited from the superclass.  If you use the -Wno-protocol option, then methods inherited from
    the superclass are considered to be implemented, and no warning is issued for them.
    </description>
    <internalKey>-Wprotocol</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wreal-q-constant</key>
    <name>Warn about real-literal-constants with 'q' exponent-letter</name>
    <description>
    Warn about real-literal-constants with 'q' exponent-letter
    </description>
    <internalKey>-Wreal-q-constant</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wredundant-decls</key>
    <name>Warn about multiple declarations of the same object</name>
    <description>
    Warn if anything is declared more than once in the same scope, even
    in cases where multiple declaration is valid and changes nothing.
    </description>
    <internalKey>-Wredundant-decls</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wreorder</key>
    <name>Warn when the compiler reorders code</name>
    <description>
    Warn when the order of member initializers given in the code does not match the order
    in which they must be executed. For instance:

            struct A {
              int i;
              int j;
              A(): j (0), i (1) { }
            };

    The compiler will rearrange the member initializers for i and j to match the declaration order of
    the members, emitting a warning to that effect.
    </description>
    <internalKey>-Wreorder</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wreturn-type</key>
    <name>Warn whenever a function's return type defaults to "int" (C), or about inconsistent return types (C++)</name>
    <description>
    Warn whenever a function is defined with a return-type that defaults to "int". Also
    warn about any "return" statement with no return-value in a function whose return-type is not "void"
    (falling off the end of the function body is considered returning without a value), and about a
    "return" statement with an expression in a function whose return- type is "void".

    For C++, a function without return type always produces a diagnostic message, even when
    -Wno-return-type is specified. The only exceptions are main and functions defined in system headers.
    </description>
    <internalKey>-Wreturn-type</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wselector</key>
    <name>Warn if a selector has multiple methods</name>
    <description>
    Warn if multiple methods of different types for the same selector are found during
    compilation.  The check is performed on the list of methods in the final stage of compilation.
    Additionally, a check is performed for each selector appearing in a "@selector(...)"  expression,
    and a corresponding method for that selector has been found during compilation.  Because these
    checks scan the method table only at the end of compilation, these warnings are not produced if
    the final stage of compilation is not reached, for example because an error is found during
    compilation, or because the -fsyntax-only option is being used.
    </description>
    <internalKey>-Wselector</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsequence-point</key>
    <name>Warn about possible violations of sequence point rules</name>
    <description>
    Warn about code that may have undefined semantics because of violations of sequence
    point rules in the C and C++ standards.

    The C and C++ standards defines the order in which expressions in a C/C++ program are evaluated
    in terms of sequence points, which represent a partial ordering between the execution of parts of
    the program: those executed before the sequence point, and those executed after it. These occur
    after the evaluation of a full expression (one which is not part of a larger expression), after
    the evaluation of the first operand of a "&amp;&amp;", "||", "? :" or "," (comma) operator, before a
    function is called (but after the evaluation of its arguments and the expression denoting the
    called function), and in certain other places. Other than as expressed by the sequence point
    rules, the order of evaluation of subexpressions of an expression is not specified. All these
    rules describe only a partial order rather than a total order, since, for example, if two functions
    are called within one expression with no sequence point between them, the order in which the
    functions are called is not specified. However, the standards committee have ruled that function
    calls do not overlap.

    It is not specified when between sequence points modifications to the values of objects take effect.
    Programs whose behavior depends on this have undefined behavior; the C and C++ standards specify
    that "Between the previous and next sequence point an object shall have its stored value modified
    at most once by the evaluation of an expression. Furthermore, the prior value shall be read only
    to determine the value to be stored.". If a program breaks these rules, the results on any
    particular implementation are entirely unpredictable.

    Examples of code with undefined behavior are "a = a++;", "a[n] = b[n++]" and "a[i++] = i;". Some
    more complicated cases are not diagnosed by this option, and it may give an occasional false
    positive result, but in general it has been found fairly effective at detecting this sort of
    problem in programs.

    The standard is worded confusingly, therefore there is some debate over the precise meaning of the
    sequence point rules in subtle cases. Links to discussions of the problem, including proposed
    formal definitions, may be found on the GCC readings page, at http://gcc.gnu.org/readings.html.
    </description>
    <internalKey>-Wsequence-point</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wshadow</key>
    <name>Warn when one local variable shadows another</name>
    <description>
    Warn whenever a local variable or type declaration shadows another variable, parameter,
    type, or class member (in C++), or whenever a built-in function is shadowed. Note that in C++,
    the compiler will not warn if a local variable shadows a struct/class/enum, but will warn if it
    shadows an explicit typedef.
    </description>
    <internalKey>-Wshadow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsign-compare</key>
    <name>Warn about signed-unsigned comparisons</name>
    <description>
    Warn when a comparison between signed and unsigned values could produce an incorrect
    result when the signed value is converted to unsigned.
    </description>
    <internalKey>-Wsign-compare</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsign-conversion</key>
    <name>Warn about signed-unsigned conversion</name>
    <description>
    Warn for implicit conversions that may change the sign of an integer value, like
    assigning a signed integer expression to an unsigned integer variable. An explicit cast silences
    the warning.
    </description>
    <internalKey>-Wsign-conversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsign-promo</key>
    <name>Warn when overload promotes from unsigned to signed</name>
    <description>
    Warn when overload resolution chooses a promotion from unsigned or enumerated type
    to a signed type, over a conversion to an unsigned type of the same size. Previous versions of
    G++ would try to preserve unsignedness, but the standard mandates the current behavior.

            struct A {
              operator int ();
              A&amp; operator = (int);
            };

            main ()
            {
              A a,b;
              a = b;
            }

    In this example, G++ will synthesize a default A&amp; operator = (const A&amp;);, while cfront will use
    the user-defined operator =.
    </description>
    <internalKey>-Wsign-promo</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstack-protector</key>
    <name>Warn when not issuing stack smashing protection for some reason</name>
    <description>
    Warns about functions that will not be protected against stack smashing.This option
    is only active when -fstack-protector is active.
    </description>
    <internalKey>-Wstack-protector</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstack-usage</key>
    <name>Warn if stack usage might be larger than specified amount</name>
    <description>
    Warn if the stack usage of a function might be larger than len bytes.  The computation done to determine the stack
    usage is conservative.  Any space allocated via "alloca", variable-length arrays, or related constructs is included by
    the compiler when determining whether or not to issue a warning.

    The message is in keeping with the output of -fstack-usage.

      * If the stack usage is fully static but exceeds the specified amount, it's:

                  warning: stack usage is 1120 bytes

      * If the stack usage is (partly) dynamic but bounded, it's:

                  warning: stack usage might be 1648 bytes

      * If the stack usage is (partly) dynamic and not bounded, it's:

                  warning: stack usage might be unbounded
    </description>
    <internalKey>-Wstack-usage</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-aliasing</key>
    <name>Warn about code which might break strict aliasing rules</name>
    <description>
    Warn about code which might break the strict aliasing rules that the compiler is using
    for optimization. The warning does not catch all cases, but does attempt to catch the more common
    pitfalls. Higher levels correspond to higher accuracy (fewer false positives). Higher levels also
    correspond to more effort, similar to the way -O works. -Wstrict-aliasing is equivalent to
    -Wstrict-aliasing=n, with n=3.

    Level 1: Most aggressive, quick, least accurate.  Possibly useful when higher levels do not warn but
    -fstrict-aliasing still breaks the code, as it has very few false negatives.  However, it has many
    false positives.  Warns for all pointer conversions between possibly incompatible types, even if
    never dereferenced.  Runs in the frontend only.

    Level 2: Aggressive, quick, not too precise.  May still have many false positives (not as many as
    level 1 though), and few false negatives (but possibly more than level 1).  Unlike level 1, it
    only warns when an address is taken.  Warns about incomplete types.  Runs in the frontend only.

    Level 3 (default for -Wstrict-aliasing): Should have very few false positives and few false negatives.
    Slightly slower than levels 1 or 2 when optimization is enabled. Takes care of the common pun+dereference
    pattern in the frontend: "*(int*)&amp;some_float". If optimization is enabled, it also runs in the
    backend, where it deals with multiple statement cases using flow-sensitive points-to information.
    Only warns when the converted pointer is dereferenced. Does not warn about incomplete types.
    </description>
    <internalKey>-Wstrict-aliasing</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-null-sentinel</key>
    <name>Warn about uncasted NULL used as sentinel</name>
    <description>
    Warn also about the use of an uncasted "NULL" as sentinel. When compiling only with
    GCC this is a valid sentinel, as "NULL" is defined to "__null". Although it is a null pointer
    constant not a null pointer, it is guaranteed to be of the same size as a pointer. But this use
    is not portable across different compilers.
    </description>
    <internalKey>-Wstrict-null-sentinel</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-overflow</key>
    <name>Warn about optimizations that assume that signed overflow is undefined</name>
    <description>
    Warn about cases where the compiler optimizes based on the assumption that signed
    overflow does not occur.  Note that it does not warn about all cases where the code might overflow:
    it only warns about cases where the compiler implements some optimization.  Thus this warning
    depends  on the optimization level.

    An optimization which assumes that signed overflow does not occur is perfectly safe if the values
    of the variables involved are such that overflow never does, in fact, occur.  Therefore this warning
    can easily give a false positive: a warning about code which is not actually a problem. To help
    focus on important issues, several warning levels are defined. No warnings are issued for the use
    of undefined signed overflow when estimating how many iterations a loop will require, in particular
    when determining whether a loop will be executed at all.

    -Wstrict-overflow=1
        Warn about cases which are both questionable and easy to avoid.  For example: "x + 1 &gt; x"; with
        -fstrict-overflow, the compiler will simplify this to 1.  This level of -Wstrict-overflow is
        enabled by -Wall; higher levels are not, and must be explicitly requested.

    -Wstrict-overflow=2
        Also warn about other cases where a comparison is simplified to a constant.  For example:
        "abs (x) &gt;= 0".  This can only be simplified when -fstrict-overflow is in effect, because
        "abs (INT_MIN)" overflows to "INT_MIN", which is less than zero. -Wstrict-overflow (with no
        level) is the same as -Wstrict-overflow=2.

    -Wstrict-overflow=3
        Also warn about other cases where a comparison is simplified.  For example: "x + 1 &gt; 1" will
        be simplified to "x &gt; 0".

    -Wstrict-overflow=4
        Also warn about other simplifications not covered by the above cases.  For example: "(x * 10) / 5"
        will be simplified to "x * 2".

    -Wstrict-overflow=5
        Also warn about cases where the compiler reduces the magnitude of a constant involved in a
        comparison.  For example: "x + 2 &gt; y" will be simplified to "x + 1 &gt;= y". This is reported
        only at the highest warning level because this simplification applies to many comparisons,
        so this warning level will give a very large number of false positives.
    </description>
    <internalKey>-Wstrict-overflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-prototypes</key>
    <name>Warn about unprototyped function declarations</name>
    <description>
    Warn if a function is declared or defined without specifying the argument types. (An
    old-style function definition is permitted without a warning if preceded by a declaration that
    specifies the argument types.)
    </description>
    <internalKey>-Wstrict-prototypes</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wstrict-selector-match</key>
    <name>Warn if type signatures of candidate methods do not match exactly</name>
    <description>
    Warn if multiple methods with differing argument and/or return types are found for
    a given selector when attempting to send a message using this selector to a receiver of type "id"
    or "Class".  When this flag is off (which is the default behavior), the compiler will omit such
    warnings if any differences found are confined to types which share the same size and alignment.
    </description>
    <internalKey>-Wstrict-selector-match</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=const</key>
    <name>Warn about functions which might be candidates for __attribute__((const))</name>
    <description>
    Warn about functions which might be candidates for attribute "const". The compiler
    only warns for functions visible in other compilation units or (in the case of "pure" and "const")
    if it cannot prove that the function returns normally. A function returns normally if it doesn't
    contain an infinite loop nor returns abnormally by throwing, calling "abort()" or trapping. This
    analysis requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher
    optimization levels improve the accuracy of the analysis.
    </description>
    <internalKey>-Wsuggest-attribute=const</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=noreturn</key>
    <name>Warn about functions which might be candidates for __attribute__((noreturn))</name>
    <description>
    Warn about functions which might be candidates for attribute "noreturn". The compiler
    only warns for functions visible in other compilation units or (in the case of "pure" and "const")
    if it cannot prove that the function returns normally. A function returns normally if it doesn't
    contain an infinite loop nor returns abnormally by throwing, calling "abort()" or trapping. This
    analysis requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher
    optimization levels improve the accuracy of the analysis.
    </description>
    <internalKey>-Wsuggest-attribute=noreturn</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsuggest-attribute=pure</key>
    <name>Warn about functions which might be candidates for __attribute__((pure))</name>
    <description>
    Warn about functions which might be candidates for attribute "pure". The compiler
    only warns for functions visible in other compilation units or (in the case of "pure" and "const")
    if it cannot prove that the function returns normally. A function returns normally if it doesn't
    contain an infinite loop nor returns abnormally by throwing, calling "abort()" or trapping. This
    analysis requires option -fipa-pure-const, which is enabled by default at -O and higher. Higher
    optimization levels improve the accuracy of the analysis.
    </description>
    <internalKey>-Wsuggest-attribute=pure</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsurprising</key>
    <name>Warn about "suspicious" constructs</name>
    <description>
    Warn about "suspicious" constructs.
    </description>
    <internalKey>-Wsurprising</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch</key>
    <name>Warn about enumerated switches, with no default, missing a case</name>
    <description>
    Warn whenever a "switch" statement has an index of enumerated type and lacks a "case"
    for one or more of the named codes of that enumeration. (The presence of a "default" label prevents
    this warning.) "case" labels outside the enumeration range also provoke warnings when this option
    is used (even if there is a "default" label).
    </description>
    <internalKey>-Wswitch</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch-default</key>
    <name>Warn about enumerated switches missing a "default:" statement</name>
    <description>
    Warn whenever a "switch" statement does not have a "default" case.
    </description>
    <internalKey>-Wswitch-default</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wswitch-enum</key>
    <name>Warn about all enumerated switches missing a specific case</name>
    <description>
    Warn whenever a "switch" statement has an index of enumerated type and lacks a "case"
    for one or more of the named codes of that enumeration.  "case" labels outside the enumeration
    range also provoke warnings when this option is used. The only difference between -Wswitch and
    this option is that this option gives a warning about an omitted enumeration code even if there
    is a "default" label.
    </description>
    <internalKey>-Wswitch-enum</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wsync-nand</key>
    <name>Warn when __sync_fetch_and_nand and __sync_nand_and_fetch built-in functions are used</name>
    <description>
    Warn when "__sync_fetch_and_nand" and "__sync_nand_and_fetch" built-in functions are
    used. These functions changed semantics in GCC 4.4.
    </description>
    <internalKey>-Wsync-nand</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtraditional</key>
    <name>Warn about features not present in traditional C</name>
    <description>
    Warn about certain constructs that behave differently in traditional and ISO C. Also
    warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs
    which should be avoided.
      * Macro parameters that appear within string literals in the macro body.  In traditional C macro
        replacement takes place within string literals, but does not in ISO C.
      * In traditional C, some preprocessor directives did not exist.  Traditional preprocessors would
        only consider a line to be a directive if the # appeared in column 1 on the line.  Therefore
        -Wtraditional warns about directives that traditional C understands but would ignore because the #
        does not appear as the first character on the line. It also suggests you hide directives like #pragma
        not understood by traditional C by indenting them.  Some traditional implementations would not
        recognize #elif, so it suggests avoiding it altogether.
      * A function-like macro that appears without arguments.
      * The unary plus operator.
      * The U integer constant suffix, or the F or L floating point constant suffixes.  (Traditional C
        does support the L suffix on integer constants.)  Note, these suffixes appear in macros defined
        in the system headers of most modern systems, e.g. the _MIN/_MAX macros in "&lt;limits.h&gt;".
        Use of these macros in user code might normally lead to spurious warnings, however GCC's integrated
        preprocessor has enough context to avoid warning in these cases.
      * A function declared external in one block and then used after the end of the block.
      * A "switch" statement has an operand of type "long".
      * A non-"static" function declaration follows a "static" one.  This construct is not accepted by
        some traditional C compilers.
      * The ISO type of an integer constant has a different width or signedness from its traditional type.
        This warning is only issued if the base of the constant is ten.  I.e. hexadecimal or octal values,
        which typically represent bit patterns, are not warned about.
      * Usage of ISO string concatenation is detected.
      * Initialization of automatic aggregates.
      * Identifier conflicts with labels.  Traditional C lacks a separate namespace for labels.
      * Initialization of unions.  If the initializer is zero, the warning is omitted.  This is done under
        the assumption that the zero initializer in user code appears conditioned on e.g. "__STDC__" to
        avoid missing initializer warnings and relies on default initialization to zero in the traditional
        C case.
      * Conversions by prototypes between fixed/floating point values and vice versa.  The absence of
        these prototypes when compiling with traditional C would cause serious problems.  This is a subset
        of the possible conversion warnings, for the full set use -Wtraditional-conversion.
      * Use of ISO C style function definitions.  This warning intentionally is not issued for prototype
        declarations or variadic functions because these ISO C features will appear in your code when
        using libiberty's traditional C compatibility macros, "PARAMS" and "VPARAMS".  This warning is
        also bypassed for nested functions because that feature is already a GCC extension and thus not
        relevant to traditional C compatibility.
    </description>
    <internalKey>-Wtraditional</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtraditional-conversion</key>
    <name>Warn of prototypes causing type conversions different from what would happen in the absence of prototype</name>
    <description>
    Warn if a prototype causes a type conversion that is different from what would happen
    to the same argument in the absence of a prototype. This includes conversions of fixed point to
    floating and vice versa, and conversions changing the width or signedness of a fixed point argument
    except when the same as the default promotion.
    </description>
    <internalKey>-Wtraditional-conversion</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtrampolines</key>
    <name>Warn whenever a trampoline is generated</name>
    <description>
    Warn about trampolines generated for pointers to nested functions.

    A trampoline is a small piece of data or code that is created at run time on the stack when the
    address of a nested function is taken, and is used to call the nested function indirectly. For
    some targets, it is made up of data only and thus requires no special treatment. But, for most
    targets, it is made up of code and thus requires the stack to be made executable in order for
    the program to work properly.
    </description>
    <internalKey>-Wtrampolines</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtrigraphs</key>
    <name>Warn if trigraphs are encountered that might affect the meaning of the program</name>
    <description>
    Warn if any trigraphs are encountered that might change the meaning of the program
    (trigraphs within comments are not warned about).
    </description>
    <internalKey>-Wtrigraphs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wtype-limits</key>
    <name>Warn if a comparison is always true or always false due to the limited range of the data type</name>
    <description>
    Warn if a comparison is always true or always false due to the limited range of the
    data type, but do not warn for constant expressions.  For example, warn if an unsigned variable
    is compared against zero with &lt; or &gt;=.
    </description>
    <internalKey>-Wtype-limits</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wundeclared-selector</key>
    <name>Warn about @selector()s without previously declared methods</name>
    <description>
    Warn if a "@selector(...)" expression referring to an undeclared selector is found.
    A selector is considered undeclared if no method with that name has been declared before the
    "@selector(...)" expression, either explicitly in an @interface or @protocol declaration, or
    implicitly in an @implementation section.  This option always performs its checks as soon as a
    "@selector(...)" expression is found, while -Wselector only performs its checks in the final stage
    of compilation.  This also enforces the coding style convention that methods and selectors must
    be declared before being used.
    </description>
    <internalKey>-Wundeclared-selector</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wundef</key>
    <name>Warn if an undefined macro is used in an #if directive</name>
    <description>
    Warn if an undefined identifier is evaluated in an #if directive.
    </description>
    <internalKey>-Wundef</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunderflow</key>
    <name>Warn about underflow of numerical constant expressions</name>
    <description>
    Warn about underflow of numerical constant expressions
    </description>
    <internalKey>-Wunderflow</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wuninitialized</key>
    <name>Warn about uninitialized automatic variables</name>
    <description>
    Warn if an automatic variable is used without first being initialized or if a variable
    may be clobbered by a "setjmp" call. In C++, warn if a non-static reference or non-static const
    member appears in a class without constructors.

    If you want to warn about code which uses the uninitialized value of the variable in its own
    initializer, use the -Winit-self option.

    These warnings occur for individual uninitialized or clobbered elements of structure, union or
    array variables as well as for variables which are uninitialized or clobbered as a whole.  They
    do not occur for variables or elements declared "volatile".  Because these warnings depend on
    optimization, the exact variables or elements for which there are warnings will depend on the
    precise optimization options and version of GCC used.

    Note that there may be no warning about a variable that is used only to compute a value that itself
    is never used, because such computations may be deleted by data flow analysis before the warnings
    are printed.

    These warnings are made optional because GCC is not smart enough to see all the reasons why the
    code might be correct despite appearing to have an error.  Here is one example of how this can
    happen:

            {
              int x;
              switch (y)
                {
                case 1: x = 1;
                  break;
                case 2: x = 4;
                  break;
                case 3: x = 5;
                }
              foo (x);
            }

    If the value of "y" is always 1, 2 or 3, then "x" is always initialized, but GCC doesn't know this.
    Here is another common case:

            {
              int save_y;
              if (change_y) save_y = y, y = new_y;
              ...
              if (change_y) y = save_y;
            }

    This has no bug because "save_y" is used only if it is set.

    This option also warns when a non-volatile automatic variable might be changed by a call to "longjmp".
    These warnings as well are possible only in optimizing compilation.

    The compiler sees only the calls to "setjmp".  It cannot know where "longjmp" will be called; in
    fact, a signal handler could call it at any point in the code. As a result, you may get a warning
    even when there is in fact no problem because "longjmp" cannot in fact be called at the place which
    would cause a problem.

    Some spurious warnings can be avoided if you declare all the functions you use that never return as
    "noreturn".
    </description>
    <internalKey>-Wuninitialized</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunknown-pragmas</key>
    <name>Warn about unrecognized pragmas</name>
    <description>
    Warn when a #pragma directive is encountered which is not understood by GCC. If this
    command line option is used, warnings will even be issued for unknown pragmas in system header
    files. This is not the case if the warnings were only enabled by the -Wall command line option.
    </description>
    <internalKey>-Wunknown-pragmas</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunsafe-loop-optimizations</key>
    <name>Warn if the loop cannot be optimized due to nontrivial assumptions</name>
    <description>
    Warn if the loop cannot be optimized because the compiler could not assume anything
    on the bounds of the loop indices. With -funsafe-loop-optimizations warn if the compiler made such
    assumptions.
    </description>
    <internalKey>-Wunsafe-loop-optimizations</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunsuffixed-float-constants</key>
    <name>Warn about unsuffixed float constants</name>
    <description>
    GCC will issue a warning for any floating constant that does not have a suffix. When
    used together with -Wsystem-headers it will warn about such constants in system header files. This
    can be useful when preparing code to use with the "FLOAT_CONST_DECIMAL64" pragma from the decimal
    floating-point extension to C99.
    </description>
    <internalKey>-Wunsuffixed-float-constants</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-but-set-parameter</key>
    <name>Warn when a function parameter is only set, otherwise unused</name>
    <description>
    Warn whenever a function parameter is assigned to, but otherwise unused (aside from
    its declaration).

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-but-set-parameter</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-but-set-variable</key>
    <name>Warn when a variable is only set, otherwise unused</name>
    <description>
    Warn whenever a local variable is assigned to, but otherwise unused (aside from its
    declaration).

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-but-set-variable</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-dummy-argument</key>
    <name>Warn about unused dummy arguments.</name>
    <description>
    Warn about unused dummy arguments.
    </description>
    <internalKey>-Wunused-dummy-argument</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-function</key>
    <name>Warn when a function is unused</name>
    <description>
    Warn whenever a static function is declared but not defined or a non-inline static function is unused.
    </description>
    <internalKey>-Wunused-function</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-label</key>
    <name>Warn when a label is unused</name>
    <description>
    Warn whenever a label is declared but not used.

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-label</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-local-typedefs</key>
    <name>Warn when typedefs locally defined in a function are not used</name>
    <description>
    Warn when a typedef locally defined in a function is not used.
    </description>
    <internalKey>-Wunused-local-typedefs</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-macros</key>
    <name>Warn about macros defined in the main file that are not used</name>
    <description>
    Warn about macros defined in the main file that are unused.  A macro is used if it
    is expanded or tested for existence at least once.  The preprocessor will also warn if the macro
    has not been used at the time it is redefined or undefined.

    Built-in macros, macros defined on the command line, and macros defined in include files are not
    warned about.

    Note: If a macro is actually used, but only used in skipped conditional blocks, then CPP will
    report it as unused. To avoid the warning in such a case, you might improve the scope of the
    macro's definition by, for example, moving it into the first skipped block.  Alternatively, you
    could provide a dummy use with something like:

            #if defined the_macro_causing_the_warning
            #endif
    </description>
    <internalKey>-Wunused-macros</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-parameter</key>
    <name>Warn when a function parameter is unused</name>
    <description>
    Warn whenever a function parameter is unused aside from its declaration.

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-parameter</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-result</key>
    <name>Warn if a caller of a function, marked with attribute warn_unused_result, does not use its return value</name>
    <description>
    Warn if a caller of a function marked with attribute "warn_unused_result" does not
    use its return value.
    </description>
    <internalKey>-Wunused-result</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-value</key>
    <name>Warn when an expression value is unused</name>
    <description>
    Warn whenever a statement computes a result that is explicitly not used. To suppress
    this warning cast the unused expression to void. This includes an expression-statement or the
    left-hand side of a comma expression that contains no side effects. For example, an expression
    such as x[i,j] will cause a warning, while x[(void)i,j] will not.
    </description>
    <internalKey>-Wunused-value</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wunused-variable</key>
    <name>Warn when a variable is unused</name>
    <description>
    Warn whenever a local variable or non-constant static variable is unused aside from
    its declaration.

    To suppress this warning use the unused attribute.
    </description>
    <internalKey>-Wunused-variable</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvariadic-macros</key>
    <name>Warn if variadic macros are used</name>
    <description>
    Warn if variadic macros are used in pedantic ISO C90 mode, or the GNU alternate syntax
    when in pedantic ISO C99 mode.
    </description>
    <internalKey>-Wvariadic-macros</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvector-operation-performance</key>
    <name>Warn when a vector operation is compiled outside the SIMD</name>
    <description>
    Warn if vector operation is not implemented via SIMD capabilities of the architecture.
    Mainly useful for the performance tuning. Vector operation can be implemented "piecewise", which
    means that the scalar operation is performed on every vector element; "in parallel", which means
    that the vector operation is implemented using scalars of wider type, which normally is more performance
    efficient; and "as a single scalar", which means that vector fits into a scalar type.
    </description>
    <internalKey>-Wvector-operation-performance</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvla</key>
    <name>Warn if a variable length array is used</name>
    <description>
    Warn if variable length array is used in the code.
    </description>
    <internalKey>-Wvla</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wvolatile-register-var</key>
    <name>Warn when a register variable is declared volatile</name>
    <description>
    Warn if a register variable is declared volatile. The volatile modifier does not
    inhibit all optimizations that may eliminate reads and/or writes to register variables.
    </description>
    <internalKey>-Wvolatile-register-var</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wwrite-strings</key>
    <name>Warn about deprecated conversion from string literals to 'char *'.</name>
    <description>
    When compiling C, give string constants the type "const char[length]" so that copying
    the address of one into a non-"const" "char *" pointer will get a warning.  These warnings will
    help you find at compile time code that can try to write into a string constant, but only if you
    have been very careful about using "const" in declarations and prototypes.  Otherwise, it will
    just be a nuisance. This is why we did not make -Wall request these warnings.

    When compiling C++, warn about the deprecated conversion from string literals to "char *".  This
    warning is enabled by default for C++ programs.
    </description>
    <internalKey>-Wwrite-strings</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
  <rule>
    <key>-Wzero-as-null-pointer-constant</key>
    <name>Warn when a literal '0' is used as null pointer</name>
    <description>
    Warn when a literal '0' is used as null pointer
    </description>
    <internalKey>-Wzero-as-null-pointer-constant</internalKey>
    <severity>CRITICAL</severity>
    <type>CODE_SMELL</type>
    <remediationFunction>LINEAR</remediationFunction>
    <remediationFunctionGapMultiplier>5min</remediationFunctionGapMultiplier>
  </rule>
</rules>
